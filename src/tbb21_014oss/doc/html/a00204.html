<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>tbb::concurrent_vector&lt; T, A &gt; Class Template Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.9.1 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="modules.html">Modules</a> | <a class="qindex" href="namespaces.html">Namespace List</a> | <a class="qindex" href="hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="annotated.html">Class&nbsp;List</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="namespacemembers.html">Namespace&nbsp;Members</a> | <a class="qindex" href="functions.html">Class&nbsp;Members</a> | <a class="qindex" href="globals.html">File&nbsp;Members</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a></div>
<h1>tbb::concurrent_vector&lt; T, A &gt; Class Template Reference</h1>Concurrent vector container  
<a href="#_details">More...</a>
<p>
<code>#include &lt;<a class="el" href="a00323.html">concurrent_vector.h</a>&gt;</code>
<p>
Inherits <a class="el" href="a00205.html">tbb::internal::concurrent_vector_base_v3</a>.
<p>
Inheritance diagram for tbb::concurrent_vector&lt; T, A &gt;:<center><font size="2">[<a href="graph_legend.html">legend</a>]</font></center><a href="a00044.html">List of all members.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Public Types</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="w0" doxytag="tbb::concurrent_vector::size_type"></a>
typedef internal::concurrent_vector_base_v3::size_type&nbsp;</td><td class="memItemRight" valign="bottom"><b>size_type</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="w1" doxytag="tbb::concurrent_vector::allocator_type"></a>
typedef internal::allocator_base&lt;<br>
 T, A &gt;::allocator_type&nbsp;</td><td class="memItemRight" valign="bottom"><b>allocator_type</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="w2" doxytag="tbb::concurrent_vector::value_type"></a>
typedef T&nbsp;</td><td class="memItemRight" valign="bottom"><b>value_type</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="w3" doxytag="tbb::concurrent_vector::difference_type"></a>
typedef ptrdiff_t&nbsp;</td><td class="memItemRight" valign="bottom"><b>difference_type</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="w4" doxytag="tbb::concurrent_vector::reference"></a>
typedef T &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><b>reference</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="w5" doxytag="tbb::concurrent_vector::const_reference"></a>
typedef const T &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><b>const_reference</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="w6" doxytag="tbb::concurrent_vector::pointer"></a>
typedef T *&nbsp;</td><td class="memItemRight" valign="bottom"><b>pointer</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="w7" doxytag="tbb::concurrent_vector::const_pointer"></a>
typedef const T *&nbsp;</td><td class="memItemRight" valign="bottom"><b>const_pointer</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="w8" doxytag="tbb::concurrent_vector::iterator"></a>
typedef <a class="el" href="a00268.html">internal::vector_iterator</a>&lt;<br>
 <a class="el" href="a00204.html">concurrent_vector</a>, T &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>iterator</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="w9" doxytag="tbb::concurrent_vector::const_iterator"></a>
typedef <a class="el" href="a00268.html">internal::vector_iterator</a>&lt;<br>
 <a class="el" href="a00204.html">concurrent_vector</a>, const <br>
T &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>const_iterator</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="w10" doxytag="tbb::concurrent_vector::reverse_iterator"></a>
typedef std::reverse_iterator&lt;<br>
 <a class="el" href="a00268.html">iterator</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>reverse_iterator</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="w11" doxytag="tbb::concurrent_vector::const_reverse_iterator"></a>
typedef std::reverse_iterator&lt;<br>
 <a class="el" href="a00268.html">const_iterator</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>const_reverse_iterator</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="w12" doxytag="tbb::concurrent_vector::reverse_iterator"></a>
typedef std::reverse_iterator&lt;<br>
 <a class="el" href="a00268.html">iterator</a>, T, T &amp;, T * &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>reverse_iterator</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="w13" doxytag="tbb::concurrent_vector::const_reverse_iterator"></a>
typedef std::reverse_iterator&lt;<br>
 <a class="el" href="a00268.html">const_iterator</a>, T, const <br>
T &amp;, const T * &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>const_reverse_iterator</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="w14" doxytag="tbb::concurrent_vector::range_type"></a>
typedef generic_range_type&lt;<br>
 <a class="el" href="a00268.html">iterator</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>range_type</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="w15" doxytag="tbb::concurrent_vector::const_range_type"></a>
typedef generic_range_type&lt;<br>
 <a class="el" href="a00268.html">const_iterator</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>const_range_type</b></td></tr>

<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a0" doxytag="tbb::concurrent_vector::concurrent_vector"></a>
&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00204.html#a0">concurrent_vector</a> (const allocator_type &amp;a=allocator_type())</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Construct empty vector. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a1" doxytag="tbb::concurrent_vector::concurrent_vector"></a>
&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00204.html#a1">concurrent_vector</a> (const <a class="el" href="a00204.html">concurrent_vector</a> &amp;vector, const allocator_type &amp;a=allocator_type())</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Copying constructor. <br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="a2" doxytag="tbb::concurrent_vector::concurrent_vector"></a>
template&lt;class M&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00204.html#a2">concurrent_vector</a> (const <a class="el" href="a00204.html">concurrent_vector</a>&lt; T, M &gt; &amp;vector, const allocator_type &amp;a=allocator_type())</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Copying constructor for vector with different allocator type. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a3" doxytag="tbb::concurrent_vector::concurrent_vector"></a>
&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00204.html#a3">concurrent_vector</a> (size_type n)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Construction with initial size specified by argument n. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a4" doxytag="tbb::concurrent_vector::concurrent_vector"></a>
&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00204.html#a4">concurrent_vector</a> (size_type n, const_reference t, const allocator_type &amp;a=allocator_type())</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Construction with initial size specified by argument n, initialization by copying of t, and given allocator instance. <br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="a5" doxytag="tbb::concurrent_vector::concurrent_vector"></a>
template&lt;class I&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00204.html#a5">concurrent_vector</a> (I first, I last, const allocator_type &amp;a=allocator_type())</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Construction with copying iteration range and given allocator instance. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a6" doxytag="tbb::concurrent_vector::operator="></a>
<a class="el" href="a00204.html">concurrent_vector</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00204.html#a6">operator=</a> (const <a class="el" href="a00204.html">concurrent_vector</a> &amp;vector)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Assignment. <br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="a7" doxytag="tbb::concurrent_vector::operator="></a>
template&lt;class M&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="a00204.html">concurrent_vector</a> &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00204.html#a7">operator=</a> (const <a class="el" href="a00204.html">concurrent_vector</a>&lt; T, M &gt; &amp;vector)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Assignment for vector with different allocator type. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">size_type&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00204.html#a8">grow_by</a> (size_type delta)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Grow by "delta" elements.  <a href="#a8"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">size_type&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00204.html#a9">grow_by</a> (size_type delta, const_reference t)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Grow by "delta" elements using copying constuctor.  <a href="#a9"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a10" doxytag="tbb::concurrent_vector::grow_to_at_least"></a>
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00204.html#a10">grow_to_at_least</a> (size_type n)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Grow array until it has at least n elements. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a11" doxytag="tbb::concurrent_vector::push_back"></a>
size_type&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00204.html#a11">push_back</a> (const_reference item)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Push item. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">reference&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00204.html#a12">operator[]</a> (size_type index)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get reference to element at given index.  <a href="#a12"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a13" doxytag="tbb::concurrent_vector::operator[]"></a>
const_reference&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00204.html#a13">operator[]</a> (size_type index) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get const reference to element at given index. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a14" doxytag="tbb::concurrent_vector::at"></a>
reference&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00204.html#a14">at</a> (size_type index)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get reference to element at given index. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a15" doxytag="tbb::concurrent_vector::at"></a>
const_reference&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00204.html#a15">at</a> (size_type index) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get const reference to element at given index. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a16" doxytag="tbb::concurrent_vector::range"></a>
range_type&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00204.html#a16">range</a> (size_t grainsize=1)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get range for iterating with parallel algorithms. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a17" doxytag="tbb::concurrent_vector::range"></a>
const_range_type&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00204.html#a17">range</a> (size_t grainsize=1) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get const range for iterating with parallel algorithms. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a18" doxytag="tbb::concurrent_vector::size"></a>
size_type&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00204.html#a18">size</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return size of vector. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a19" doxytag="tbb::concurrent_vector::empty"></a>
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00204.html#a19">empty</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return size of vector. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a20" doxytag="tbb::concurrent_vector::capacity"></a>
size_type&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00204.html#a20">capacity</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Maximum size to which array can grow without allocating more memory. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00204.html#a21">reserve</a> (size_type n)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Allocate enough space to grow to size n without having to allocate more memory later.  <a href="#a21"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a22" doxytag="tbb::concurrent_vector::compact"></a>
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00204.html#a22">compact</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Optimize memory usage and fragmentation. Returns true if optimization occurred. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a23" doxytag="tbb::concurrent_vector::max_size"></a>
size_type&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00204.html#a23">max_size</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Upper bound on argument to reserve. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a24" doxytag="tbb::concurrent_vector::begin"></a>
<a class="el" href="a00268.html">iterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00204.html#a24">begin</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">start iterator <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a25" doxytag="tbb::concurrent_vector::end"></a>
<a class="el" href="a00268.html">iterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00204.html#a25">end</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">end iterator <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a26" doxytag="tbb::concurrent_vector::begin"></a>
<a class="el" href="a00268.html">const_iterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00204.html#a26">begin</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">start const iterator <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a27" doxytag="tbb::concurrent_vector::end"></a>
<a class="el" href="a00268.html">const_iterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00204.html#a27">end</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">end const iterator <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a28" doxytag="tbb::concurrent_vector::rbegin"></a>
reverse_iterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00204.html#a28">rbegin</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">reverse start iterator <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a29" doxytag="tbb::concurrent_vector::rend"></a>
reverse_iterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00204.html#a29">rend</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">reverse end iterator <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a30" doxytag="tbb::concurrent_vector::rbegin"></a>
const_reverse_iterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00204.html#a30">rbegin</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">reverse start const iterator <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a31" doxytag="tbb::concurrent_vector::rend"></a>
const_reverse_iterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00204.html#a31">rend</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">reverse end const iterator <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a32" doxytag="tbb::concurrent_vector::front"></a>
reference&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00204.html#a32">front</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">the first item <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a33" doxytag="tbb::concurrent_vector::front"></a>
const_reference&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00204.html#a33">front</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">the first item const <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a34" doxytag="tbb::concurrent_vector::back"></a>
reference&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00204.html#a34">back</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">the last item <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a35" doxytag="tbb::concurrent_vector::back"></a>
const_reference&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00204.html#a35">back</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">the last item const <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a36" doxytag="tbb::concurrent_vector::get_allocator"></a>
allocator_type&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00204.html#a36">get_allocator</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">return allocator object <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a37" doxytag="tbb::concurrent_vector::assign"></a>
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00204.html#a37">assign</a> (size_type n, const_reference t)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">assign n items by copying t item <br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="a38" doxytag="tbb::concurrent_vector::assign"></a>
template&lt;class I&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00204.html#a38">assign</a> (I first, I last)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">assign range [first, last) <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a39" doxytag="tbb::concurrent_vector::swap"></a>
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00204.html#a39">swap</a> (<a class="el" href="a00204.html">concurrent_vector</a> &amp;vector)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">swap two instances <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00204.html#a40">clear</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Clear container while keeping memory allocated.  <a href="#a40"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a41" doxytag="tbb::concurrent_vector::~concurrent_vector"></a>
&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00204.html#a41">~concurrent_vector</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Clear and destroy vector. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a42" doxytag="tbb::concurrent_vector::internal_vector_base"></a>
const <a class="el" href="a00205.html">internal::concurrent_vector_base_v3</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><b>internal_vector_base</b> () const </td></tr>

<tr><td colspan="2"><br><h2>Friends</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="n0" doxytag="tbb::concurrent_vector::internal::vector_iterator"></a>
class&nbsp;</td><td class="memItemRight" valign="bottom"><b>internal::vector_iterator</b></td></tr>

</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
<h3>template&lt;typename T, class A&gt;<br>
 class tbb::concurrent_vector&lt; T, A &gt;</h3>

Concurrent vector container 
<p>
<a class="el" href="a00204.html">concurrent_vector</a> is a container having the following main properties:<ul>
<li>It provides random indexed access to its elements. The index of the first element is 0.</li><li>It ensures safe concurrent growing its size (different threads can safely append new elements).</li><li>Adding new elements does not invalidate existing iterators and does not change indices of existing items.</li></ul>
<p>
<dl compact><dt><b>Compatibility</b></dt><dd>The class meets all Container Requirements and Reversible Container Requirements from C++ Standard (See ISO/IEC 14882:2003(E), clause 23.1). But it doesn't meet Sequence Requirements due to absence of insert() and erase() methods.</dd></dl>
<dl compact><dt><b>Exception Safety</b></dt><dd>Methods working with memory allocation and/or new elements construction can throw an exception if allocator fails to allocate memory or element's default constructor throws one. Concurrent vector's element of type T must conform to the following requirements:<ul>
<li>Throwing an exception is forbidden for destructor of T.</li><li>Default constructor of T must not throw an exception OR its non-virtual destructor must safely work when its object memory is zero-initialized.</li></ul>
Otherwise, the program's behavior is undefined. </dd></dl>
<dl compact><dt><b></b></dt><dd>If an exception happens inside growth or assignment operation, an instance of the vector becomes invalid unless it is stated otherwise in the method documentation. Invalid state means:<ul>
<li>There are no guaranties that all items were initialized by a constructor. The rest of items is zero-filled, including item where exception happens.</li><li>An invalid vector instance cannot be repaired; it is unable to grow anymore.</li><li>Size and capacity reported by the vector are incorrect, and calculated as if the failed operation were successful.</li><li>Attempt to access not allocated elements using operator[] or iterators results in access violation or segmentation fault exception, and in case of using <a class="el" href="a00204.html#a14">at()</a> method a C++ exception is thrown.</li></ul>
If a concurrent grow operation successfully completes, all the elements it has added to the vector will remain valid and accessible even if one of subsequent grow operations fails.</dd></dl>
<dl compact><dt><b>Fragmentation</b></dt><dd>Unlike an STL vector, a <a class="el" href="a00204.html">concurrent_vector</a> does not move existing elements if it needs to allocate more memory. The container is divided into a series of contiguous arrays of elements. The first reservation, growth, or assignment operation determines the size of the first array. Using small number of elements as initial size incurs fragmentation that may increase element access time. Internal layout can be optimized by method <a class="el" href="a00204.html#a22">compact()</a> that merges several smaller arrays into one solid.</dd></dl>
<dl compact><dt><b>Changes since TBB 2.0</b></dt><dd><ul>
<li>Implemented exception-safety guaranties</li><li>Added template argument for allocator</li><li>Added allocator argument in constructors</li><li>Faster index calculation</li><li>First growth call specifies a number of segments to be merged in the first allocation.</li><li>Fixed memory blow up for swarm of vector's instances of small size</li><li>Added <a class="el" href="a00204.html#a9">grow_by(size_type n, const_reference t)</a> growth using copying constructor to init new items.</li><li>Added STL-like constructors.</li><li>Added operators ==, &lt; and derivatives</li><li>Added <a class="el" href="a00204.html#a14">at()</a> method, approved for using after an exception was thrown inside the vector</li><li>Added <a class="el" href="a00204.html#a36">get_allocator()</a> method.</li><li>Added <a class="el" href="a00204.html#a37">assign()</a> methods</li><li>Added <a class="el" href="a00204.html#a22">compact()</a> method to defragment first segments</li><li>Added <a class="el" href="a00204.html#a39">swap()</a> method</li><li><a class="el" href="a00204.html#a16">range()</a> defaults on grainsize = 1 supporting auto grainsize algorithms. </li></ul>
</dd></dl>

<p>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="a40" doxytag="tbb::concurrent_vector::clear"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;typename T, class A&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top">void <a class="el" href="a00204.html">tbb::concurrent_vector</a>&lt; T, A &gt;::clear           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [inline]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Clear container while keeping memory allocated. 
<p>
To free up the memory, use in conjunction with method <a class="el" href="a00204.html#a22">compact()</a>. Not thread safe *     </td>
  </tr>
</table>
<a class="anchor" name="a9" doxytag="tbb::concurrent_vector::grow_by"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;typename T, class A&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top">size_type <a class="el" href="a00204.html">tbb::concurrent_vector</a>&lt; T, A &gt;::grow_by           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">size_type&nbsp;</td>
          <td class="mdname" nowrap> <em>delta</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>const_reference&nbsp;</td>
          <td class="mdname" nowrap> <em>t</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [inline]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Grow by "delta" elements using copying constuctor. 
<p>
Returns old size.     </td>
  </tr>
</table>
<a class="anchor" name="a8" doxytag="tbb::concurrent_vector::grow_by"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;typename T, class A&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top">size_type <a class="el" href="a00204.html">tbb::concurrent_vector</a>&lt; T, A &gt;::grow_by           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">size_type&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>delta</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [inline]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Grow by "delta" elements. 
<p>
Returns old size.     </td>
  </tr>
</table>
<a class="anchor" name="a12" doxytag="tbb::concurrent_vector::operator[]"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;typename T, class A&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top">reference <a class="el" href="a00204.html">tbb::concurrent_vector</a>&lt; T, A &gt;::operator[]           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">size_type&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>index</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [inline]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Get reference to element at given index. 
<p>
This method is thread-safe for concurrent reads, and also while growing the vector, as long as the calling thread has checked that index&lt;<a class="el" href="a00204.html#a18">size()</a>.     </td>
  </tr>
</table>
<a class="anchor" name="a21" doxytag="tbb::concurrent_vector::reserve"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;typename T, class A&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top">void <a class="el" href="a00204.html">tbb::concurrent_vector</a>&lt; T, A &gt;::reserve           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">size_type&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>n</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [inline]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Allocate enough space to grow to size n without having to allocate more memory later. 
<p>
Like most of the methods provided for STL compatibility, this method is *not* thread safe. The capacity afterwards may be bigger than the requested reservation.     </td>
  </tr>
</table>
<hr>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="a00323.html">concurrent_vector.h</a></ul>
<hr>
<p></p>
Copyright &copy; 2005-2008 Intel Corporation.  All Rights Reserved.
<p></p>
Intel, Pentium, Intel Xeon, Itanium, Intel XScale and VTune are
registered trademarks or trademarks of Intel Corporation or its
subsidiaries in the United States and other countries.
<p></p>
* Other names and brands may be claimed as the property of others.
