<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>tbb::task_scheduler_init Class Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.9.1 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="modules.html">Modules</a> | <a class="qindex" href="namespaces.html">Namespace List</a> | <a class="qindex" href="hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="annotated.html">Class&nbsp;List</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="namespacemembers.html">Namespace&nbsp;Members</a> | <a class="qindex" href="functions.html">Class&nbsp;Members</a> | <a class="qindex" href="globals.html">File&nbsp;Members</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a></div>
<h1>tbb::task_scheduler_init Class Reference</h1>Class representing reference to tbb scheduler.  
<a href="#_details">More...</a>
<p>
<code>#include &lt;<a class="el" href="a00340.html">task_scheduler_init.h</a>&gt;</code>
<p>
Inherits <a class="el" href="a00225.html">tbb::internal::no_copy</a>.
<p>
Inheritance diagram for tbb::task_scheduler_init:<center><font size="2">[<a href="graph_legend.html">legend</a>]</font></center><a href="a00120.html">List of all members.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void __TBB_EXPORTED_METHOD&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00259.html#a0">initialize</a> (int number_of_threads=<a class="el" href="a00259.html#s0">automatic</a>)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Ensure that scheduler exists for this thread.  <a href="#a0"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void __TBB_EXPORTED_METHOD&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00259.html#a1">initialize</a> (int number_of_threads, stack_size_type thread_stack_size)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The overloaded method with stack size parameter.  <a href="#a1"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a2" doxytag="tbb::task_scheduler_init::terminate"></a>
void __TBB_EXPORTED_METHOD&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00259.html#a2">terminate</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Inverse of method initialize. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a3" doxytag="tbb::task_scheduler_init::task_scheduler_init"></a>
&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00259.html#a3">task_scheduler_init</a> (int number_of_threads=<a class="el" href="a00259.html#s0">automatic</a>, stack_size_type thread_stack_size=0)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Shorthand for default constructor followed by call to intialize(number_of_threads). <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a4" doxytag="tbb::task_scheduler_init::~task_scheduler_init"></a>
&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00259.html#a4">~task_scheduler_init</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Destroy scheduler for this thread if thread has no other live task_scheduler_inits. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a5" doxytag="tbb::task_scheduler_init::is_active"></a>
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00259.html#a5">is_active</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns true if scheduler is active (initialized); false otherwise. <br></td></tr>
<tr><td colspan="2"><br><h2>Static Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int __TBB_EXPORTED_FUNC&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00259.html#e0">default_num_threads</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the number of threads tbb scheduler would create if initialized by default.  <a href="#e0"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Static Public Attributes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="s0" doxytag="tbb::task_scheduler_init::automatic"></a>
const int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00259.html#s0">automatic</a> = -1</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Typedef for number of threads that is automatic. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="s1" doxytag="tbb::task_scheduler_init::deferred"></a>
const int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00259.html#s1">deferred</a> = -2</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Argument to <a class="el" href="a00259.html#a0">initialize()</a> or constructor that causes initialization to be deferred. <br></td></tr>
</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
Class representing reference to tbb scheduler. 
<p>
A thread must construct a <a class="el" href="a00259.html">task_scheduler_init</a>, and keep it alive, during the time that it uses the services of class task. 
<p>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="e0" doxytag="tbb::task_scheduler_init::default_num_threads"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int __TBB_EXPORTED_FUNC tbb::task_scheduler_init::default_num_threads           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [static]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Returns the number of threads tbb scheduler would create if initialized by default. 
<p>
Result returned by this method does not depend on whether the scheduler has already been initialized.<p>
Because tbb 2.0 does not support blocking tasks yet, you may use this method to boost the number of threads in the tbb's internal pool, if your tasks are doing I/O operations. The optimal number of additional threads depends on how much time your tasks spend in the blocked state.     </td>
  </tr>
</table>
<a class="anchor" name="a1" doxytag="tbb::task_scheduler_init::initialize"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void __TBB_EXPORTED_METHOD tbb::task_scheduler_init::initialize           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">int&nbsp;</td>
          <td class="mdname" nowrap> <em>number_of_threads</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>stack_size_type&nbsp;</td>
          <td class="mdname" nowrap> <em>thread_stack_size</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
The overloaded method with stack size parameter. 
<p>
Overloading is necessary to preserve ABI compatibility     </td>
  </tr>
</table>
<a class="anchor" name="a0" doxytag="tbb::task_scheduler_init::initialize"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void __TBB_EXPORTED_METHOD tbb::task_scheduler_init::initialize           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">int&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>number_of_threads</em> = <code><a class="el" href="a00259.html#s0">automatic</a></code>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Ensure that scheduler exists for this thread. 
<p>
A value of -1 lets tbb decide on the number of threads, which is typically the number of hardware threads. For production code, the default value of -1 should be used, particularly if the client code is mixed with third party clients that might also use tbb.<p>
The number_of_threads is ignored if any other task_scheduler_inits currently exist. A thread may construct multiple task_scheduler_inits. Doing so does no harm because the underlying scheduler is reference counted.     </td>
  </tr>
</table>
<hr>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="a00340.html">task_scheduler_init.h</a></ul>
<hr>
<p></p>
Copyright &copy; 2005-2008 Intel Corporation.  All Rights Reserved.
<p></p>
Intel, Pentium, Intel Xeon, Itanium, Intel XScale and VTune are
registered trademarks or trademarks of Intel Corporation or its
subsidiaries in the United States and other countries.
<p></p>
* Other names and brands may be claimed as the property of others.
