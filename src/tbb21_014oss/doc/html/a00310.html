<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>tbb Namespace Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.9.1 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="modules.html">Modules</a> | <a class="qindex" href="namespaces.html">Namespace List</a> | <a class="qindex" href="hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="annotated.html">Class&nbsp;List</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="namespacemembers.html">Namespace&nbsp;Members</a> | <a class="qindex" href="functions.html">Class&nbsp;Members</a> | <a class="qindex" href="globals.html">File&nbsp;Members</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a></div>
<h1>tbb Namespace Reference</h1>The namespace tbb contains all components of the library.  
<a href="#_details">More...</a>
<p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Classes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00185.html">tbb::aligned_space&lt; T, N &gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Block of space aligned sufficiently to construct an array T with N elements.  <a href="a00185.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00186.html">tbb::atomic&lt; T &gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Primary template for atomic.  <a href="a00186.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><b>tbb::atomic&lt; void * &gt;</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><b>tbb::atomic&lt; bool &gt;</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00190.html">tbb::blocked_range&lt; Value &gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A range over which to iterate.  <a href="a00190.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00191.html">tbb::blocked_range2d&lt; RowValue, ColValue &gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A 2-dimensional range that models the Range concept.  <a href="a00191.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00192.html">tbb::blocked_range3d&lt; PageValue, RowValue, ColValue &gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A 3-dimensional range that models the Range concept.  <a href="a00192.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00193.html">tbb::cache_aligned_allocator&lt; T &gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Meets "allocator" requirements of ISO C++ Standard, Section 20.1.5.  <a href="a00193.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><b>tbb::cache_aligned_allocator&lt; T &gt;::rebind&lt; U &gt;</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00194.html">tbb::cache_aligned_allocator&lt; void &gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Analogous to std::allocator&lt;void&gt;, as defined in ISO C++ Standard, Section 20.4.1.  <a href="a00194.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><b>tbb::cache_aligned_allocator&lt; void &gt;::rebind&lt; U &gt;</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00263.html">tbb::tbb_hash_compare&lt; T &gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">hash_compare - default argument  <a href="a00263.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00196.html">tbb::concurrent_hash_map&lt; Key, T, HashCompare, A &gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Unordered map from Key to T.  <a href="a00196.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00198.html">tbb::concurrent_hash_map&lt; Key, T, HashCompare, A &gt;::const_accessor</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Combines data access, locking, and garbage collection.  <a href="a00198.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00197.html">tbb::concurrent_hash_map&lt; Key, T, HashCompare, A &gt;::accessor</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Allows write access to elements and combines data access, locking, and garbage collection.  <a href="a00197.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><b>tbb::concurrent_hash_map&lt; Key, T, HashCompare, A &gt;::node</b></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Basic unit of storage used in chain. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><b>tbb::concurrent_hash_map&lt; Key, T, HashCompare, A &gt;::chain</b></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A linked-list of nodes. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><b>tbb::concurrent_hash_map&lt; Key, T, HashCompare, A &gt;::segment</b></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Segment of the table. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00199.html">tbb::concurrent_queue&lt; T, A &gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A high-performance thread-safe queue.  <a href="a00199.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><b>tbb::concurrent_queue&lt; T, A &gt;::destroyer</b></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Class used to ensure exception-safety of method "pop". <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00204.html">tbb::concurrent_vector&lt; T, A &gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Concurrent vector container  <a href="a00204.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><b>tbb::concurrent_vector&lt; T, A &gt;::generic_range_type&lt; I &gt;</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><b>tbb::concurrent_vector&lt; T, A &gt;::internal_loop_guide</b></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Exception-aware helper class for filling a segment by exception-danger operators of user class. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00222.html">tbb::mutex</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Wrapper around the platform's native reader-writer lock.  <a href="a00222.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00223.html">tbb::mutex::scoped_lock</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The scoped locking pattern.  <a href="a00223.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00226.html">tbb::parallel_do_feeder&lt; Item &gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Class the user supplied algorithm body uses to add new tasks  <a href="a00226.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00232.html">tbb::pre_scan_tag</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Used to indicate that the initial scan is being performed.  <a href="a00232.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00212.html">tbb::final_scan_tag</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Used to indicate that the final scan is being performed.  <a href="a00212.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00229.html">tbb::parallel_while&lt; Body &gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Parallel iteration over a stream, with optional addition of more work.  <a href="a00229.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00243.html">tbb::simple_partitioner</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A simple partitioner  <a href="a00243.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><b>tbb::simple_partitioner::partition_type</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00188.html">tbb::auto_partitioner</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">An auto partitioner.  <a href="a00188.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><b>tbb::auto_partitioner::partition_type</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00183.html">tbb::affinity_partitioner</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">An affinity partitioner.  <a href="a00183.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00211.html">tbb::filter</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A stage in a pipeline.  <a href="a00211.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00231.html">tbb::pipeline</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A processing pipeling that applies filters to items.  <a href="a00231.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00233.html">tbb::queuing_mutex</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Queuing lock with local-only spinning.  <a href="a00233.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00234.html">tbb::queuing_mutex::scoped_lock</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The scoped locking pattern.  <a href="a00234.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00235.html">tbb::queuing_rw_mutex</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Reader-writer lock with local-only spinning.  <a href="a00235.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00236.html">tbb::queuing_rw_mutex::scoped_lock</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The scoped locking pattern.  <a href="a00236.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00239.html">tbb::recursive_mutex</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Mutex that allows recursive mutex acquisition.  <a href="a00239.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00240.html">tbb::recursive_mutex::scoped_lock</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The scoped locking pattern.  <a href="a00240.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00241.html">tbb::scalable_allocator&lt; T &gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Meets "allocator" requirements of ISO C++ Standard, Section 20.1.5.  <a href="a00241.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><b>tbb::scalable_allocator&lt; T &gt;::rebind&lt; U &gt;</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00242.html">tbb::scalable_allocator&lt; void &gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Analogous to std::allocator&lt;void&gt;, as defined in ISO C++ Standard, Section 20.4.1.  <a href="a00242.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><b>tbb::scalable_allocator&lt; void &gt;::rebind&lt; U &gt;</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00244.html">tbb::spin_mutex</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A lock that occupies a single byte.  <a href="a00244.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00245.html">tbb::spin_mutex::scoped_lock</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Represents acquisition of a mutex.  <a href="a00245.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00246.html">tbb::spin_rw_mutex_v3</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Fast, unfair, spinning reader-writer lock with backoff and writer-preference.  <a href="a00246.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00247.html">tbb::spin_rw_mutex_v3::scoped_lock</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The scoped locking pattern.  <a href="a00247.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00256.html">tbb::task_group_context</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Used to form groups of tasks.  <a href="a00256.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00255.html">tbb::task</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Base class for user-defined tasks.  <a href="a00255.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00210.html">tbb::empty_task</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">task that does nothing. Useful for synchronization.  <a href="a00210.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00257.html">tbb::task_list</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A list of children.  <a href="a00257.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00259.html">tbb::task_scheduler_init</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Class representing reference to tbb scheduler.  <a href="a00259.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00260.html">tbb::tbb_allocator&lt; T &gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Meets "allocator" requirements of ISO C++ Standard, Section 20.1.5.  <a href="a00260.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><b>tbb::tbb_allocator&lt; T &gt;::rebind&lt; U &gt;</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00261.html">tbb::tbb_allocator&lt; void &gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Analogous to std::allocator&lt;void&gt;, as defined in ISO C++ Standard, Section 20.4.1.  <a href="a00261.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><b>tbb::tbb_allocator&lt; void &gt;::rebind&lt; U &gt;</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00189.html">tbb::bad_last_alloc</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Exception for concurrent containers.  <a href="a00189.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00262.html">tbb::tbb_exception</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Interface to be implemented by all exceptions TBB recognizes and propagates across the threads.  <a href="a00262.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00195.html">tbb::captured_exception</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This class is used by TBB to propagate information about unhandled exceptions into the root thread.  <a href="a00195.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00221.html">tbb::movable_exception&lt; ExceptionData &gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Template that can be used to implement exception that transfers arbitrary ExceptionData to the root thread.  <a href="a00221.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00248.html">tbb::split</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Dummy type that distinguishes splitting constructor from copy constructor.  <a href="a00248.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00266.html">tbb::tick_count</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Absolute timestamp.  <a href="a00266.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00267.html">tbb::tick_count::interval_t</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Relative time interval.  <a href="a00267.html#_details">More...</a><br></td></tr>
<tr><td colspan="2"><br><h2>parallel_do</h2></td></tr>
<tr><td colspan="2">See also requirements on <a class="el" href="parallel_do_body_req.html">parallel_do Body</a>. * <br><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="ga3" doxytag="tbb::parallel_do"></a>
template&lt;typename Iterator, typename Body&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00313.html#ga3">parallel_do</a> (Iterator first, Iterator last, const Body &amp;body)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Parallel iteration over a range, with optional addition of more work. <br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="ga4" doxytag="tbb::parallel_do"></a>
template&lt;typename Iterator, typename Body&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00313.html#ga4">parallel_do</a> (Iterator first, Iterator last, const Body &amp;body, <a class="el" href="a00256.html">task_group_context</a> &amp;context)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Parallel iteration over a range, with optional addition of more work and user-supplied context. <br></td></tr>
<tr><td colspan="2"><br><h2>parallel_for</h2></td></tr>
<tr><td colspan="2">See also requirements on <a class="el" href="range_req.html">Range</a> and <a class="el" href="parallel_for_body_req.html">parallel_for Body</a>. * <br><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="ga5" doxytag="tbb::parallel_for"></a>
template&lt;typename Range, typename Body&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00313.html#ga5">parallel_for</a> (const Range &amp;range, const Body &amp;body, const <a class="el" href="a00243.html">simple_partitioner</a> &amp;partitioner=<a class="el" href="a00243.html">simple_partitioner</a>())</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Parallel iteration over range with simple partitioner, or default partitioner if no partitioner is specified. <br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="ga6" doxytag="tbb::parallel_for"></a>
template&lt;typename Range, typename Body&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00313.html#ga6">parallel_for</a> (const Range &amp;range, const Body &amp;body, const <a class="el" href="a00188.html">auto_partitioner</a> &amp;partitioner)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Parallel iteration over range with <a class="el" href="a00188.html">auto_partitioner</a>. <br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="ga7" doxytag="tbb::parallel_for"></a>
template&lt;typename Range, typename Body&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00313.html#ga7">parallel_for</a> (const Range &amp;range, const Body &amp;body, <a class="el" href="a00183.html">affinity_partitioner</a> &amp;partitioner)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Parallel iteration over range with <a class="el" href="a00183.html">affinity_partitioner</a>. <br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="ga8" doxytag="tbb::parallel_for"></a>
template&lt;typename Range, typename Body&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00313.html#ga8">parallel_for</a> (const Range &amp;range, const Body &amp;body, const <a class="el" href="a00243.html">simple_partitioner</a> &amp;partitioner, <a class="el" href="a00256.html">task_group_context</a> &amp;context)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Parallel iteration over range with simple partitioner and user-supplied context. <br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="ga9" doxytag="tbb::parallel_for"></a>
template&lt;typename Range, typename Body&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00313.html#ga9">parallel_for</a> (const Range &amp;range, const Body &amp;body, const <a class="el" href="a00188.html">auto_partitioner</a> &amp;partitioner, <a class="el" href="a00256.html">task_group_context</a> &amp;context)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Parallel iteration over range with <a class="el" href="a00188.html">auto_partitioner</a> and user-supplied context. <br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="ga10" doxytag="tbb::parallel_for"></a>
template&lt;typename Range, typename Body&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00313.html#ga10">parallel_for</a> (const Range &amp;range, const Body &amp;body, <a class="el" href="a00183.html">affinity_partitioner</a> &amp;partitioner, <a class="el" href="a00256.html">task_group_context</a> &amp;context)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Parallel iteration over range with <a class="el" href="a00183.html">affinity_partitioner</a> and user-supplied context. <br></td></tr>
<tr><td colspan="2"><br><h2>parallel_reduce</h2></td></tr>
<tr><td colspan="2">See also requirements on <a class="el" href="range_req.html">Range</a> and <a class="el" href="parallel_reduce_body_req.html">parallel_reduce Body</a>. * <br><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="ga11" doxytag="tbb::parallel_reduce"></a>
template&lt;typename Range, typename Body&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00313.html#ga11">parallel_reduce</a> (const Range &amp;range, Body &amp;body, const <a class="el" href="a00243.html">simple_partitioner</a> &amp;partitioner=<a class="el" href="a00243.html">simple_partitioner</a>())</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Parallel iteration with reduction and <a class="el" href="a00243.html">simple_partitioner</a>, or no partitioner specified. <br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="ga12" doxytag="tbb::parallel_reduce"></a>
template&lt;typename Range, typename Body&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00313.html#ga12">parallel_reduce</a> (const Range &amp;range, Body &amp;body, const <a class="el" href="a00188.html">auto_partitioner</a> &amp;partitioner)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Parallel iteration with reduction and <a class="el" href="a00188.html">auto_partitioner</a>. <br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="ga13" doxytag="tbb::parallel_reduce"></a>
template&lt;typename Range, typename Body&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00313.html#ga13">parallel_reduce</a> (const Range &amp;range, Body &amp;body, <a class="el" href="a00183.html">affinity_partitioner</a> &amp;partitioner)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Parallel iteration with reduction and <a class="el" href="a00183.html">affinity_partitioner</a>. <br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="ga14" doxytag="tbb::parallel_reduce"></a>
template&lt;typename Range, typename Body&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00313.html#ga14">parallel_reduce</a> (const Range &amp;range, Body &amp;body, const <a class="el" href="a00243.html">simple_partitioner</a> &amp;partitioner, <a class="el" href="a00256.html">task_group_context</a> &amp;context)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Parallel iteration with reduction, simple partitioner and user-supplied context. <br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="ga15" doxytag="tbb::parallel_reduce"></a>
template&lt;typename Range, typename Body&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00313.html#ga15">parallel_reduce</a> (const Range &amp;range, Body &amp;body, const <a class="el" href="a00188.html">auto_partitioner</a> &amp;partitioner, <a class="el" href="a00256.html">task_group_context</a> &amp;context)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Parallel iteration with reduction, <a class="el" href="a00188.html">auto_partitioner</a> and user-supplied context. <br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="ga16" doxytag="tbb::parallel_reduce"></a>
template&lt;typename Range, typename Body&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00313.html#ga16">parallel_reduce</a> (const Range &amp;range, Body &amp;body, <a class="el" href="a00183.html">affinity_partitioner</a> &amp;partitioner, <a class="el" href="a00256.html">task_group_context</a> &amp;context)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Parallel iteration with reduction, <a class="el" href="a00183.html">affinity_partitioner</a> and user-supplied context. <br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="ga17" doxytag="tbb::parallel_reduce"></a>
template&lt;typename Range, typename Value, typename RealBody, typename Reduction&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">Value&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00313.html#ga17">parallel_reduce</a> (const Range &amp;range, const Value &amp;identity, const RealBody &amp;real_body, const Reduction &amp;reduction, const <a class="el" href="a00243.html">simple_partitioner</a> &amp;partitioner=<a class="el" href="a00243.html">simple_partitioner</a>())</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Parallel iteration with reduction and <a class="el" href="a00243.html">simple_partitioner</a>, or no partitioner specified. <br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="ga18" doxytag="tbb::parallel_reduce"></a>
template&lt;typename Range, typename Value, typename RealBody, typename Reduction&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">Value&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00313.html#ga18">parallel_reduce</a> (const Range &amp;range, const Value &amp;identity, const RealBody &amp;real_body, const Reduction &amp;reduction, const <a class="el" href="a00188.html">auto_partitioner</a> &amp;partitioner)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Parallel iteration with reduction and <a class="el" href="a00188.html">auto_partitioner</a>. <br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="ga19" doxytag="tbb::parallel_reduce"></a>
template&lt;typename Range, typename Value, typename RealBody, typename Reduction&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">Value&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00313.html#ga19">parallel_reduce</a> (const Range &amp;range, const Value &amp;identity, const RealBody &amp;real_body, const Reduction &amp;reduction, <a class="el" href="a00183.html">affinity_partitioner</a> &amp;partitioner)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Parallel iteration with reduction and <a class="el" href="a00183.html">affinity_partitioner</a>. <br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="ga20" doxytag="tbb::parallel_reduce"></a>
template&lt;typename Range, typename Value, typename RealBody, typename Reduction&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">Value&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00313.html#ga20">parallel_reduce</a> (const Range &amp;range, const Value &amp;identity, const RealBody &amp;real_body, const Reduction &amp;reduction, const <a class="el" href="a00243.html">simple_partitioner</a> &amp;partitioner, <a class="el" href="a00256.html">task_group_context</a> &amp;context)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Parallel iteration with reduction, simple partitioner and user-supplied context. <br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="ga21" doxytag="tbb::parallel_reduce"></a>
template&lt;typename Range, typename Value, typename RealBody, typename Reduction&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">Value&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00313.html#ga21">parallel_reduce</a> (const Range &amp;range, const Value &amp;identity, const RealBody &amp;real_body, const Reduction &amp;reduction, const <a class="el" href="a00188.html">auto_partitioner</a> &amp;partitioner, <a class="el" href="a00256.html">task_group_context</a> &amp;context)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Parallel iteration with reduction, <a class="el" href="a00188.html">auto_partitioner</a> and user-supplied context. <br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="ga22" doxytag="tbb::parallel_reduce"></a>
template&lt;typename Range, typename Value, typename RealBody, typename Reduction&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">Value&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00313.html#ga22">parallel_reduce</a> (const Range &amp;range, const Value &amp;identity, const RealBody &amp;real_body, const Reduction &amp;reduction, <a class="el" href="a00183.html">affinity_partitioner</a> &amp;partitioner, <a class="el" href="a00256.html">task_group_context</a> &amp;context)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Parallel iteration with reduction, <a class="el" href="a00183.html">affinity_partitioner</a> and user-supplied context. <br></td></tr>
<tr><td colspan="2"><br><h2>parallel_scan</h2></td></tr>
<tr><td colspan="2">See also requirements on <a class="el" href="range_req.html">Range</a> and <a class="el" href="parallel_scan_body_req.html">parallel_scan Body</a>. * <br><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="ga23" doxytag="tbb::parallel_scan"></a>
template&lt;typename Range, typename Body&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00313.html#ga23">parallel_scan</a> (const Range &amp;range, Body &amp;body, const <a class="el" href="a00243.html">simple_partitioner</a> &amp;partitioner=<a class="el" href="a00243.html">simple_partitioner</a>())</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Parallel prefix with <a class="el" href="a00243.html">simple_partitioner</a>. <br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="ga24" doxytag="tbb::parallel_scan"></a>
template&lt;typename Range, typename Body&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00313.html#ga24">parallel_scan</a> (const Range &amp;range, Body &amp;body, const <a class="el" href="a00188.html">auto_partitioner</a> &amp;partitioner)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Parallel prefix with <a class="el" href="a00188.html">auto_partitioner</a>. <br></td></tr>
<tr><td colspan="2"><br><h2>parallel_sort</h2></td></tr>
<tr><td colspan="2">See also requirements on <a class="el" href="parallel_sort_iter_req.html">iterators for parallel_sort</a>. * <br><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename RandomAccessIterator, typename Compare&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00313.html#ga26">parallel_sort</a> (RandomAccessIterator begin, RandomAccessIterator end, const Compare &amp;comp)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sorts the data in [begin,end) using the given comparator.  <a href="a00313.html#ga26"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="ga27" doxytag="tbb::parallel_sort"></a>
template&lt;typename RandomAccessIterator&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00313.html#ga27">parallel_sort</a> (RandomAccessIterator begin, RandomAccessIterator end)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sorts the data in [begin,end) with a default comparator <code>std::less&lt;RandomAccessIterator&gt;</code>. <br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="ga28" doxytag="tbb::parallel_sort"></a>
template&lt;typename T&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00313.html#ga28">parallel_sort</a> (T *begin, T *end)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sorts the data in the range <code></code>[begin,end) with a default comparator <code>std::less&lt;T&gt;</code>. <br></td></tr>
<tr><td colspan="2"><br><h2>Typedefs</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a3" doxytag="tbb::spin_rw_mutex"></a>
typedef <a class="el" href="a00246.html">spin_rw_mutex_v3</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>spin_rw_mutex</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a4" doxytag="tbb::stack_size_type"></a>
typedef std::size_t&nbsp;</td><td class="memItemRight" valign="bottom"><b>stack_size_type</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a5" doxytag="tbb::task_scheduler_observer"></a>
typedef internal::task_scheduler_observer_v3&nbsp;</td><td class="memItemRight" valign="bottom"><b>task_scheduler_observer</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a6" doxytag="tbb::assertion_handler_type"></a>
typedef void(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00310.html#a6">assertion_handler_type</a> )(const char *filename, int line, const char *expression, const char *comment)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Type for an assertion handler. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a7" doxytag="tbb::tbb_thread"></a>
typedef <a class="el" href="a00264.html">internal::tbb_thread_v3</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00310.html#a7">tbb_thread</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Users reference thread class by name tbb_thread. <br></td></tr>
<tr><td colspan="2"><br><h2>Enumerations</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00310.html#a57">memory_semantics</a> { <a class="el" href="a00310.html#a57a0">__TBB_full_fence</a>, 
<a class="el" href="a00310.html#a57a1">acquire</a>, 
<a class="el" href="a00310.html#a57a2">release</a>
 }</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Specifies memory fencing.  <a href="#a57">More...</a><br></td></tr>
<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a8" doxytag="tbb::__TBB_DECL_ATOMIC"></a>
&nbsp;</td><td class="memItemRight" valign="bottom"><b>__TBB_DECL_ATOMIC</b> (__TBB_LONG_LONG) __TBB_DECL_ATOMIC(unsigned __TBB_LONG_LONG) __TBB_DECL_ATOMIC(long) __TBB_DECL_ATOMIC(unsigned long) __TBB_DECL_ATOMIC_ALT(unsigned</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a9" doxytag="tbb::__TBB_DECL_ATOMIC_ALT"></a>
size_t&nbsp;</td><td class="memItemRight" valign="bottom"><b>__TBB_DECL_ATOMIC_ALT</b> (int, ptrdiff_t) __TBB_DECL_ATOMIC(unsigned) __TBB_DECL_ATOMIC(int) __TBB_DECL_ATOMIC(unsigned short) __TBB_DECL_ATOMIC(short) __TBB_DECL_ATOMIC(char) __TBB_DECL_ATOMIC(signed char) __TBB_DECL_ATOMIC(unsigned char) __TBB_DECL_ATOMIC(wchar_t) template&lt; typename T &gt; struct <a class="el" href="a00186.html">atomic</a>&lt; T * &gt;</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="a10" doxytag="tbb::operator=="></a>
template&lt;typename T, typename U&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>operator==</b> (const <a class="el" href="a00193.html">cache_aligned_allocator</a>&lt; T &gt; &amp;, const <a class="el" href="a00193.html">cache_aligned_allocator</a>&lt; U &gt; &amp;)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="a11" doxytag="tbb::operator!="></a>
template&lt;typename T, typename U&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>operator!=</b> (const <a class="el" href="a00193.html">cache_aligned_allocator</a>&lt; T &gt; &amp;, const <a class="el" href="a00193.html">cache_aligned_allocator</a>&lt; U &gt; &amp;)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="a12" doxytag="tbb::operator=="></a>
template&lt;typename Key, typename T, typename HashCompare, typename A1, typename A2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>operator==</b> (const <a class="el" href="a00196.html">concurrent_hash_map</a>&lt; Key, T, HashCompare, A1 &gt; &amp;a, const <a class="el" href="a00196.html">concurrent_hash_map</a>&lt; Key, T, HashCompare, A2 &gt; &amp;b)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="a13" doxytag="tbb::operator!="></a>
template&lt;typename Key, typename T, typename HashCompare, typename A1, typename A2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>operator!=</b> (const <a class="el" href="a00196.html">concurrent_hash_map</a>&lt; Key, T, HashCompare, A1 &gt; &amp;a, const <a class="el" href="a00196.html">concurrent_hash_map</a>&lt; Key, T, HashCompare, A2 &gt; &amp;b)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="a14" doxytag="tbb::swap"></a>
template&lt;typename Key, typename T, typename HashCompare, typename A&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>swap</b> (<a class="el" href="a00196.html">concurrent_hash_map</a>&lt; Key, T, HashCompare, A &gt; &amp;a, <a class="el" href="a00196.html">concurrent_hash_map</a>&lt; Key, T, HashCompare, A &gt; &amp;b)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="a15" doxytag="tbb::operator=="></a>
template&lt;typename T, class A1, class A2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>operator==</b> (const <a class="el" href="a00204.html">concurrent_vector</a>&lt; T, A1 &gt; &amp;a, const <a class="el" href="a00204.html">concurrent_vector</a>&lt; T, A2 &gt; &amp;b)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="a16" doxytag="tbb::operator!="></a>
template&lt;typename T, class A1, class A2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>operator!=</b> (const <a class="el" href="a00204.html">concurrent_vector</a>&lt; T, A1 &gt; &amp;a, const <a class="el" href="a00204.html">concurrent_vector</a>&lt; T, A2 &gt; &amp;b)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="a17" doxytag="tbb::operator<"></a>
template&lt;typename T, class A1, class A2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;</b> (const <a class="el" href="a00204.html">concurrent_vector</a>&lt; T, A1 &gt; &amp;a, const <a class="el" href="a00204.html">concurrent_vector</a>&lt; T, A2 &gt; &amp;b)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="a18" doxytag="tbb::operator>"></a>
template&lt;typename T, class A1, class A2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;</b> (const <a class="el" href="a00204.html">concurrent_vector</a>&lt; T, A1 &gt; &amp;a, const <a class="el" href="a00204.html">concurrent_vector</a>&lt; T, A2 &gt; &amp;b)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="a19" doxytag="tbb::operator<="></a>
template&lt;typename T, class A1, class A2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;=</b> (const <a class="el" href="a00204.html">concurrent_vector</a>&lt; T, A1 &gt; &amp;a, const <a class="el" href="a00204.html">concurrent_vector</a>&lt; T, A2 &gt; &amp;b)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="a20" doxytag="tbb::operator>="></a>
template&lt;typename T, class A1, class A2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;=</b> (const <a class="el" href="a00204.html">concurrent_vector</a>&lt; T, A1 &gt; &amp;a, const <a class="el" href="a00204.html">concurrent_vector</a>&lt; T, A2 &gt; &amp;b)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="a21" doxytag="tbb::swap"></a>
template&lt;typename T, class A&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>swap</b> (<a class="el" href="a00204.html">concurrent_vector</a>&lt; T, A &gt; &amp;a, <a class="el" href="a00204.html">concurrent_vector</a>&lt; T, A &gt; &amp;b)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="a47" doxytag="tbb::operator=="></a>
template&lt;typename T, typename U&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>operator==</b> (const <a class="el" href="a00241.html">scalable_allocator</a>&lt; T &gt; &amp;, const <a class="el" href="a00241.html">scalable_allocator</a>&lt; U &gt; &amp;)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="a48" doxytag="tbb::operator!="></a>
template&lt;typename T, typename U&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>operator!=</b> (const <a class="el" href="a00241.html">scalable_allocator</a>&lt; T &gt; &amp;, const <a class="el" href="a00241.html">scalable_allocator</a>&lt; U &gt; &amp;)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="a49" doxytag="tbb::operator=="></a>
template&lt;typename T, typename U&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>operator==</b> (const <a class="el" href="a00260.html">tbb_allocator</a>&lt; T &gt; &amp;, const <a class="el" href="a00260.html">tbb_allocator</a>&lt; U &gt; &amp;)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="a50" doxytag="tbb::operator!="></a>
template&lt;typename T, typename U&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>operator!=</b> (const <a class="el" href="a00260.html">tbb_allocator</a>&lt; T &gt; &amp;, const <a class="el" href="a00260.html">tbb_allocator</a>&lt; U &gt; &amp;)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a51" doxytag="tbb::set_assertion_handler"></a>
<a class="el" href="a00310.html#a6">assertion_handler_type</a> __TBB_EXPORTED_FUNC&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00310.html#a51">set_assertion_handler</a> (<a class="el" href="a00310.html#a6">assertion_handler_type</a> new_handler)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set assertion handler and return previous value of it. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void __TBB_EXPORTED_FUNC&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00310.html#a52">assertion_failure</a> (const char *filename, int line, const char *expression, const char *comment)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Process an assertion failure.  <a href="#a52"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00310.html#a53">TBB_runtime_interface_version</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The function returns the interface version of the TBB shared library being used.  <a href="#a53"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a54" doxytag="tbb::swap"></a>
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>swap</b> (<a class="el" href="a00264.html">internal::tbb_thread_v3</a> &amp;t1, <a class="el" href="a00264.html">internal::tbb_thread_v3</a> &amp;t2)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a55" doxytag="tbb::move"></a>
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>move</b> (<a class="el" href="a00264.html">tbb_thread</a> &amp;t1, <a class="el" href="a00264.html">tbb_thread</a> &amp;t2)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a56" doxytag="tbb::operator-"></a>
<a class="el" href="a00267.html">tick_count::interval_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>operator-</b> (const <a class="el" href="a00266.html">tick_count</a> &amp;t1, const <a class="el" href="a00266.html">tick_count</a> &amp;t0)</td></tr>

</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
The namespace tbb contains all components of the library. <hr><h2>Enumeration Type Documentation</h2>
<a class="anchor" name="a57" doxytag="tbb::memory_semantics"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">enum <a class="el" href="a00310.html#a57">memory_semantics</a>          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Specifies memory fencing. 
<p>
<dl compact><dt><b>Enumeration values: </b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" name="a57a0" doxytag="__TBB_full_fence"></a>__TBB_full_fence</em>&nbsp;</td><td>
For internal use only. </td></tr>
<tr><td valign="top"><em><a class="anchor" name="a57a1" doxytag="acquire"></a>acquire</em>&nbsp;</td><td>
Acquire fence. </td></tr>
<tr><td valign="top"><em><a class="anchor" name="a57a2" doxytag="release"></a>release</em>&nbsp;</td><td>
Release fence. </td></tr>
</table>
</dl>
    </td>
  </tr>
</table>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="a52" doxytag="tbb::assertion_failure"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void __TBB_EXPORTED_FUNC assertion_failure           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const char *&nbsp;</td>
          <td class="mdname" nowrap> <em>filename</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>line</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>const char *&nbsp;</td>
          <td class="mdname" nowrap> <em>expression</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>const char *&nbsp;</td>
          <td class="mdname" nowrap> <em>comment</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Process an assertion failure. 
<p>
Normally called from __TBB_ASSERT macro. If assertion handler is null, print message for assertion failure and abort. Otherwise call the assertion handler.     </td>
  </tr>
</table>
<a class="anchor" name="a53" doxytag="tbb::TBB_runtime_interface_version"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int TBB_runtime_interface_version           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
The function returns the interface version of the TBB shared library being used. 
<p>
The version it returns is determined at runtime, not at compile/link time. So it can be different than the value of TBB_INTERFACE_VERSION obtained at compile time.     </td>
  </tr>
</table>
<hr>
<p></p>
Copyright &copy; 2005-2008 Intel Corporation.  All Rights Reserved.
<p></p>
Intel, Pentium, Intel Xeon, Itanium, Intel XScale and VTune are
registered trademarks or trademarks of Intel Corporation or its
subsidiaries in the United States and other countries.
<p></p>
* Other names and brands may be claimed as the property of others.
