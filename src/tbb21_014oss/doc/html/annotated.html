<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>Class List</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.9.1 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="modules.html">Modules</a> | <a class="qindex" href="namespaces.html">Namespace List</a> | <a class="qindex" href="hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindexHL" href="annotated.html">Class&nbsp;List</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="namespacemembers.html">Namespace&nbsp;Members</a> | <a class="qindex" href="functions.html">Class&nbsp;Members</a> | <a class="qindex" href="globals.html">File&nbsp;Members</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a></div>
<h1>Class List</h1>Here are the classes, structs, unions and interfaces with brief descriptions:<table>
  <tr><td class="indexkey"><a class="el" href="a00183.html">tbb::affinity_partitioner</a></td><td class="indexvalue">An affinity partitioner </td></tr>
  <tr><td class="indexkey"><a class="el" href="a00184.html">tbb::internal::affinity_partitioner_base_v3</a></td><td class="indexvalue">Defines entry points into tbb run-time library; </td></tr>
  <tr><td class="indexkey"><a class="el" href="a00185.html">tbb::aligned_space&lt; T, N &gt;</a></td><td class="indexvalue">Block of space aligned sufficiently to construct an array T with N elements </td></tr>
  <tr><td class="indexkey"><a class="el" href="a00186.html">tbb::atomic&lt; T &gt;</a></td><td class="indexvalue">Primary template for atomic </td></tr>
  <tr><td class="indexkey"><a class="el" href="a00187.html">tbb::internal::AtomicBackoff</a></td><td class="indexvalue">Class that implements exponential backoff </td></tr>
  <tr><td class="indexkey"><a class="el" href="a00188.html">tbb::auto_partitioner</a></td><td class="indexvalue">An auto partitioner </td></tr>
  <tr><td class="indexkey"><a class="el" href="a00189.html">tbb::bad_last_alloc</a></td><td class="indexvalue">Exception for concurrent containers </td></tr>
  <tr><td class="indexkey"><a class="el" href="a00190.html">tbb::blocked_range&lt; Value &gt;</a></td><td class="indexvalue">A range over which to iterate </td></tr>
  <tr><td class="indexkey"><a class="el" href="a00191.html">tbb::blocked_range2d&lt; RowValue, ColValue &gt;</a></td><td class="indexvalue">A 2-dimensional range that models the Range concept </td></tr>
  <tr><td class="indexkey"><a class="el" href="a00192.html">tbb::blocked_range3d&lt; PageValue, RowValue, ColValue &gt;</a></td><td class="indexvalue">A 3-dimensional range that models the Range concept </td></tr>
  <tr><td class="indexkey"><a class="el" href="a00193.html">tbb::cache_aligned_allocator&lt; T &gt;</a></td><td class="indexvalue">Meets "allocator" requirements of ISO C++ Standard, Section 20.1.5 </td></tr>
  <tr><td class="indexkey"><a class="el" href="a00194.html">tbb::cache_aligned_allocator&lt; void &gt;</a></td><td class="indexvalue">Analogous to std::allocator&lt;void&gt;, as defined in ISO C++ Standard, Section 20.4.1 </td></tr>
  <tr><td class="indexkey"><a class="el" href="a00195.html">tbb::captured_exception</a></td><td class="indexvalue">This class is used by TBB to propagate information about unhandled exceptions into the root thread </td></tr>
  <tr><td class="indexkey"><a class="el" href="a00196.html">tbb::concurrent_hash_map&lt; Key, T, HashCompare, A &gt;</a></td><td class="indexvalue">Unordered map from Key to T </td></tr>
  <tr><td class="indexkey"><a class="el" href="a00197.html">tbb::concurrent_hash_map&lt; Key, T, HashCompare, A &gt;::accessor</a></td><td class="indexvalue">Allows write access to elements and combines data access, locking, and garbage collection </td></tr>
  <tr><td class="indexkey"><a class="el" href="a00198.html">tbb::concurrent_hash_map&lt; Key, T, HashCompare, A &gt;::const_accessor</a></td><td class="indexvalue">Combines data access, locking, and garbage collection </td></tr>
  <tr><td class="indexkey"><a class="el" href="a00199.html">tbb::concurrent_queue&lt; T, A &gt;</a></td><td class="indexvalue">A high-performance thread-safe queue </td></tr>
  <tr><td class="indexkey"><a class="el" href="a00200.html">tbb::internal::concurrent_queue_base_v3</a></td><td class="indexvalue">For internal use only </td></tr>
  <tr><td class="indexkey"><a class="el" href="a00201.html">tbb::internal::concurrent_queue_base_v3::page</a></td><td class="indexvalue">Prefix on a page </td></tr>
  <tr><td class="indexkey"><a class="el" href="a00202.html">tbb::internal::concurrent_queue_iterator&lt; Container, Value &gt;</a></td><td class="indexvalue">Meets requirements of a forward iterator for STL </td></tr>
  <tr><td class="indexkey"><a class="el" href="a00203.html">tbb::internal::concurrent_queue_iterator_base_v3</a></td><td class="indexvalue">Type-independent portion of <a class="el" href="a00202.html">concurrent_queue_iterator</a> </td></tr>
  <tr><td class="indexkey"><a class="el" href="a00204.html">tbb::concurrent_vector&lt; T, A &gt;</a></td><td class="indexvalue">Concurrent vector container </td></tr>
  <tr><td class="indexkey"><a class="el" href="a00205.html">tbb::internal::concurrent_vector_base_v3</a></td><td class="indexvalue">Base class of concurrent vector implementation </td></tr>
  <tr><td class="indexkey"><a class="el" href="a00206.html">tbb::internal::concurrent_vector_base_v3::internal_segments_table</a></td><td class="indexvalue">Internal structure for compact() </td></tr>
  <tr><td class="indexkey"><a class="el" href="a00207.html">tbb::internal::do_group_task_forward&lt; Iterator, Body, Item &gt;</a></td><td class="indexvalue">For internal use only </td></tr>
  <tr><td class="indexkey"><a class="el" href="a00208.html">tbb::internal::do_iteration_task&lt; Body, Item &gt;</a></td><td class="indexvalue">For internal use only </td></tr>
  <tr><td class="indexkey"><a class="el" href="a00209.html">tbb::internal::do_task_iter&lt; Iterator, Body, Item &gt;</a></td><td class="indexvalue">For internal use only </td></tr>
  <tr><td class="indexkey"><a class="el" href="a00210.html">tbb::empty_task</a></td><td class="indexvalue">Task that does nothing. Useful for synchronization </td></tr>
  <tr><td class="indexkey"><a class="el" href="a00211.html">tbb::filter</a></td><td class="indexvalue">A stage in a pipeline </td></tr>
  <tr><td class="indexkey"><a class="el" href="a00212.html">tbb::final_scan_tag</a></td><td class="indexvalue">Used to indicate that the final scan is being performed </td></tr>
  <tr><td class="indexkey"><a class="el" href="a00213.html">tbb::internal::final_sum&lt; Range, Body &gt;</a></td><td class="indexvalue">Performs final scan for a leaf </td></tr>
  <tr><td class="indexkey"><a class="el" href="a00214.html">tbb::internal::finish_reduce&lt; Body &gt;</a></td><td class="indexvalue">Task type use to combine the partial results of parallel_reduce </td></tr>
  <tr><td class="indexkey"><a class="el" href="a00215.html">tbb::internal::finish_reduce_with_affinity&lt; Body &gt;</a></td><td class="indexvalue">Task type use to combine the partial results of parallel_reduce with <a class="el" href="a00183.html">affinity_partitioner</a> </td></tr>
  <tr><td class="indexkey"><a class="el" href="a00216.html">tbb::internal::finish_scan&lt; Range, Body &gt;</a></td><td class="indexvalue">Combine partial results </td></tr>
  <tr><td class="indexkey"><a class="el" href="a00217.html">tbb::internal::hash_map_base</a></td><td class="indexvalue">Base class of <a class="el" href="a00196.html">concurrent_hash_map</a> </td></tr>
  <tr><td class="indexkey"><a class="el" href="a00218.html">tbb::internal::hash_map_iterator&lt; Container, Value &gt;</a></td><td class="indexvalue">Meets requirements of a forward iterator for STL */ </td></tr>
  <tr><td class="indexkey"><a class="el" href="a00219.html">tbb::internal::hash_map_range&lt; Iterator &gt;</a></td><td class="indexvalue">Range class used with <a class="el" href="a00196.html">concurrent_hash_map</a> </td></tr>
  <tr><td class="indexkey"><a class="el" href="a00220.html">tbb::internal::lambda_reduce_body&lt; Range, Value, RealBody, Reduction &gt;</a></td><td class="indexvalue">Auxiliary class for parallel_reduce; for internal use only </td></tr>
  <tr><td class="indexkey"><a class="el" href="a00221.html">tbb::movable_exception&lt; ExceptionData &gt;</a></td><td class="indexvalue">Template that can be used to implement exception that transfers arbitrary ExceptionData to the root thread </td></tr>
  <tr><td class="indexkey"><a class="el" href="a00222.html">tbb::mutex</a></td><td class="indexvalue">Wrapper around the platform's native reader-writer lock </td></tr>
  <tr><td class="indexkey"><a class="el" href="a00223.html">tbb::mutex::scoped_lock</a></td><td class="indexvalue">The scoped locking pattern </td></tr>
  <tr><td class="indexkey"><a class="el" href="a00224.html">tbb::internal::no_assign</a></td><td class="indexvalue">Base class for types that should not be assigned </td></tr>
  <tr><td class="indexkey"><a class="el" href="a00225.html">tbb::internal::no_copy</a></td><td class="indexvalue">Base class for types that should not be copied or assigned </td></tr>
  <tr><td class="indexkey"><a class="el" href="a00226.html">tbb::parallel_do_feeder&lt; Item &gt;</a></td><td class="indexvalue">Class the user supplied algorithm body uses to add new tasks </td></tr>
  <tr><td class="indexkey"><a class="el" href="a00227.html">tbb::internal::parallel_do_feeder_impl&lt; Body, Item &gt;</a></td><td class="indexvalue">For internal use only </td></tr>
  <tr><td class="indexkey"><a class="el" href="a00228.html">tbb::internal::parallel_do_operator_selector&lt; Body, Item &gt;</a></td><td class="indexvalue">For internal use only </td></tr>
  <tr><td class="indexkey"><a class="el" href="a00229.html">tbb::parallel_while&lt; Body &gt;</a></td><td class="indexvalue">Parallel iteration over a stream, with optional addition of more work </td></tr>
  <tr><td class="indexkey"><a class="el" href="a00230.html">tbb::internal::partition_type_base</a></td><td class="indexvalue">Provides default methods for partition objects without affinity </td></tr>
  <tr><td class="indexkey"><a class="el" href="a00231.html">tbb::pipeline</a></td><td class="indexvalue">A processing pipeling that applies filters to items </td></tr>
  <tr><td class="indexkey"><a class="el" href="a00232.html">tbb::pre_scan_tag</a></td><td class="indexvalue">Used to indicate that the initial scan is being performed </td></tr>
  <tr><td class="indexkey"><a class="el" href="a00233.html">tbb::queuing_mutex</a></td><td class="indexvalue">Queuing lock with local-only spinning </td></tr>
  <tr><td class="indexkey"><a class="el" href="a00234.html">tbb::queuing_mutex::scoped_lock</a></td><td class="indexvalue">The scoped locking pattern </td></tr>
  <tr><td class="indexkey"><a class="el" href="a00235.html">tbb::queuing_rw_mutex</a></td><td class="indexvalue">Reader-writer lock with local-only spinning </td></tr>
  <tr><td class="indexkey"><a class="el" href="a00236.html">tbb::queuing_rw_mutex::scoped_lock</a></td><td class="indexvalue">The scoped locking pattern </td></tr>
  <tr><td class="indexkey"><a class="el" href="a00237.html">tbb::internal::quick_sort_body&lt; RandomAccessIterator, Compare &gt;</a></td><td class="indexvalue">Body class used to sort elements in a range that is smaller than the grainsize </td></tr>
  <tr><td class="indexkey"><a class="el" href="a00238.html">tbb::internal::quick_sort_range&lt; RandomAccessIterator, Compare &gt;</a></td><td class="indexvalue">Range used in quicksort to split elements into subranges based on a value </td></tr>
  <tr><td class="indexkey"><a class="el" href="a00239.html">tbb::recursive_mutex</a></td><td class="indexvalue">Mutex that allows recursive mutex acquisition </td></tr>
  <tr><td class="indexkey"><a class="el" href="a00240.html">tbb::recursive_mutex::scoped_lock</a></td><td class="indexvalue">The scoped locking pattern </td></tr>
  <tr><td class="indexkey"><a class="el" href="a00241.html">tbb::scalable_allocator&lt; T &gt;</a></td><td class="indexvalue">Meets "allocator" requirements of ISO C++ Standard, Section 20.1.5 </td></tr>
  <tr><td class="indexkey"><a class="el" href="a00242.html">tbb::scalable_allocator&lt; void &gt;</a></td><td class="indexvalue">Analogous to std::allocator&lt;void&gt;, as defined in ISO C++ Standard, Section 20.4.1 </td></tr>
  <tr><td class="indexkey"><a class="el" href="a00243.html">tbb::simple_partitioner</a></td><td class="indexvalue">A simple partitioner </td></tr>
  <tr><td class="indexkey"><a class="el" href="a00244.html">tbb::spin_mutex</a></td><td class="indexvalue">A lock that occupies a single byte </td></tr>
  <tr><td class="indexkey"><a class="el" href="a00245.html">tbb::spin_mutex::scoped_lock</a></td><td class="indexvalue">Represents acquisition of a mutex </td></tr>
  <tr><td class="indexkey"><a class="el" href="a00246.html">tbb::spin_rw_mutex_v3</a></td><td class="indexvalue">Fast, unfair, spinning reader-writer lock with backoff and writer-preference </td></tr>
  <tr><td class="indexkey"><a class="el" href="a00247.html">tbb::spin_rw_mutex_v3::scoped_lock</a></td><td class="indexvalue">The scoped locking pattern </td></tr>
  <tr><td class="indexkey"><a class="el" href="a00248.html">tbb::split</a></td><td class="indexvalue">Dummy type that distinguishes splitting constructor from copy constructor </td></tr>
  <tr><td class="indexkey"><a class="el" href="a00249.html">tbb::internal::start_for&lt; Range, Body, Partitioner &gt;</a></td><td class="indexvalue">Task type used in parallel_for </td></tr>
  <tr><td class="indexkey"><a class="el" href="a00250.html">tbb::internal::start_reduce&lt; Range, Body, Partitioner &gt;</a></td><td class="indexvalue">Task type used to split the work of parallel_reduce </td></tr>
  <tr><td class="indexkey"><a class="el" href="a00251.html">tbb::internal::start_reduce_with_affinity&lt; Range, Body &gt;</a></td><td class="indexvalue">Task type used to split the work of parallel_reduce with <a class="el" href="a00183.html">affinity_partitioner</a> </td></tr>
  <tr><td class="indexkey"><a class="el" href="a00252.html">tbb::internal::start_scan&lt; Range, Body, Partitioner &gt;</a></td><td class="indexvalue">Initial task to split the work </td></tr>
  <tr><td class="indexkey"><a class="el" href="a00253.html">tbb::internal::strip&lt; T &gt;</a></td><td class="indexvalue">Strips its template type argument from 'cv' and '&amp;' qualifiers </td></tr>
  <tr><td class="indexkey"><a class="el" href="a00254.html">tbb::internal::sum_node&lt; Range, Body &gt;</a></td><td class="indexvalue">Split work to be done in the scan </td></tr>
  <tr><td class="indexkey"><a class="el" href="a00255.html">tbb::task</a></td><td class="indexvalue">Base class for user-defined tasks </td></tr>
  <tr><td class="indexkey"><a class="el" href="a00256.html">tbb::task_group_context</a></td><td class="indexvalue">Used to form groups of tasks </td></tr>
  <tr><td class="indexkey"><a class="el" href="a00257.html">tbb::task_list</a></td><td class="indexvalue">A list of children </td></tr>
  <tr><td class="indexkey"><a class="el" href="a00258.html">tbb::internal::task_prefix</a></td><td class="indexvalue">Memory prefix to a task object </td></tr>
  <tr><td class="indexkey"><a class="el" href="a00259.html">tbb::task_scheduler_init</a></td><td class="indexvalue">Class representing reference to tbb scheduler </td></tr>
  <tr><td class="indexkey"><a class="el" href="a00260.html">tbb::tbb_allocator&lt; T &gt;</a></td><td class="indexvalue">Meets "allocator" requirements of ISO C++ Standard, Section 20.1.5 </td></tr>
  <tr><td class="indexkey"><a class="el" href="a00261.html">tbb::tbb_allocator&lt; void &gt;</a></td><td class="indexvalue">Analogous to std::allocator&lt;void&gt;, as defined in ISO C++ Standard, Section 20.4.1 </td></tr>
  <tr><td class="indexkey"><a class="el" href="a00262.html">tbb::tbb_exception</a></td><td class="indexvalue">Interface to be implemented by all exceptions TBB recognizes and propagates across the threads </td></tr>
  <tr><td class="indexkey"><a class="el" href="a00263.html">tbb::tbb_hash_compare&lt; T &gt;</a></td><td class="indexvalue">hash_compare - default argument </td></tr>
  <tr><td class="indexkey"><a class="el" href="a00264.html">tbb::internal::tbb_thread_v3</a></td><td class="indexvalue">Versioned thread class </td></tr>
  <tr><td class="indexkey"><a class="el" href="a00265.html">tbb::internal::thread_closure_1&lt; F, X &gt;</a></td><td class="indexvalue">Structure used to pass user function with 1 argument to thread </td></tr>
  <tr><td class="indexkey"><a class="el" href="a00266.html">tbb::tick_count</a></td><td class="indexvalue">Absolute timestamp </td></tr>
  <tr><td class="indexkey"><a class="el" href="a00267.html">tbb::tick_count::interval_t</a></td><td class="indexvalue">Relative time interval </td></tr>
  <tr><td class="indexkey"><a class="el" href="a00268.html">tbb::internal::vector_iterator&lt; Container, Value &gt;</a></td><td class="indexvalue">Meets requirements of a forward iterator for STL and a Value for a <a class="el" href="a00190.html">blocked_range</a>.*/ </td></tr>
  <tr><td class="indexkey"><a class="el" href="a00269.html">tbb::internal::version_tag_v3</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="a00270.html">tbb::internal::while_group_task&lt; Body &gt;</a></td><td class="indexvalue">For internal use only </td></tr>
  <tr><td class="indexkey"><a class="el" href="a00271.html">tbb::internal::while_iteration_task&lt; Body &gt;</a></td><td class="indexvalue">For internal use only </td></tr>
  <tr><td class="indexkey"><a class="el" href="a00272.html">tbb::internal::while_task&lt; Stream, Body &gt;</a></td><td class="indexvalue">For internal use only </td></tr>
  <tr><td class="indexkey"><a class="el" href="a00273.html">tbb::internal::work_around_alignment_bug&lt; Size, T &gt;</a></td><td class="indexvalue">Work around for bug in GNU 3.2 and MSVC compilers </td></tr>
</table>
<hr>
<p></p>
Copyright &copy; 2005-2008 Intel Corporation.  All Rights Reserved.
<p></p>
Intel, Pentium, Intel Xeon, Itanium, Intel XScale and VTune are
registered trademarks or trademarks of Intel Corporation or its
subsidiaries in the United States and other countries.
<p></p>
* Other names and brands may be claimed as the property of others.
