<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>concurrent_hash_map.h Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.9.1 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="modules.html">Modules</a> | <a class="qindex" href="namespaces.html">Namespace List</a> | <a class="qindex" href="hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="annotated.html">Class&nbsp;List</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="namespacemembers.html">Namespace&nbsp;Members</a> | <a class="qindex" href="functions.html">Class&nbsp;Members</a> | <a class="qindex" href="globals.html">File&nbsp;Members</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a></div>
<h1>concurrent_hash_map.h</h1><div class="fragment"><pre class="fragment">00001 <span class="comment">/*</span>
00002 <span class="comment">    Copyright 2005-2008 Intel Corporation.  All Rights Reserved.</span>
00003 <span class="comment"></span>
00004 <span class="comment">    The source code contained or described herein and all documents related</span>
00005 <span class="comment">    to the source code ("Material") are owned by Intel Corporation or its</span>
00006 <span class="comment">    suppliers or licensors.  Title to the Material remains with Intel</span>
00007 <span class="comment">    Corporation or its suppliers and licensors.  The Material is protected</span>
00008 <span class="comment">    by worldwide copyright laws and treaty provisions.  No part of the</span>
00009 <span class="comment">    Material may be used, copied, reproduced, modified, published, uploaded,</span>
00010 <span class="comment">    posted, transmitted, distributed, or disclosed in any way without</span>
00011 <span class="comment">    Intel's prior express written permission.</span>
00012 <span class="comment"></span>
00013 <span class="comment">    No license under any patent, copyright, trade secret or other</span>
00014 <span class="comment">    intellectual property right is granted to or conferred upon you by</span>
00015 <span class="comment">    disclosure or delivery of the Materials, either expressly, by</span>
00016 <span class="comment">    implication, inducement, estoppel or otherwise.  Any license under such</span>
00017 <span class="comment">    intellectual property rights must be express and approved by Intel in</span>
00018 <span class="comment">    writing.</span>
00019 <span class="comment">*/</span>
00020 
00021 <span class="preprocessor">#ifndef __TBB_concurrent_hash_map_H</span>
00022 <span class="preprocessor"></span><span class="preprocessor">#define __TBB_concurrent_hash_map_H</span>
00023 <span class="preprocessor"></span>
00024 <span class="preprocessor">#include &lt;stdexcept&gt;</span>
00025 <span class="preprocessor">#include &lt;iterator&gt;</span>
00026 <span class="preprocessor">#include &lt;utility&gt;</span>      <span class="comment">// Need std::pair</span>
00027 <span class="preprocessor">#include &lt;cstring&gt;</span>      <span class="comment">// Need std::memset</span>
00028 <span class="preprocessor">#include &lt;string&gt;</span>
00029 <span class="preprocessor">#include "tbb_stddef.h"</span>
00030 <span class="preprocessor">#include "cache_aligned_allocator.h"</span>
00031 <span class="preprocessor">#include "tbb_allocator.h"</span>
00032 <span class="preprocessor">#include "spin_rw_mutex.h"</span>
00033 <span class="preprocessor">#include "atomic.h"</span>
00034 <span class="preprocessor">#if TBB_USE_PERFORMANCE_WARNINGS</span>
00035 <span class="preprocessor"></span><span class="preprocessor">#include &lt;typeinfo&gt;</span>
00036 <span class="preprocessor">#endif</span>
00037 <span class="preprocessor"></span>
00038 <span class="keyword">namespace </span>tbb {
00039 
00040 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keyword">struct </span>tbb_hash_compare;
00041 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Key, <span class="keyword">typename</span> T, <span class="keyword">typename</span> HashCompare = tbb_hash_compare&lt;Key&gt;, <span class="keyword">typename</span> A = tbb_allocator&lt;std::pair&lt;Key, T&gt; &gt; &gt;
00042 <span class="keyword">class </span>concurrent_hash_map;
00043 
00045 <span class="keyword">namespace </span>internal {
<a name="l00047"></a><a class="code" href="a00311.html#a2">00047</a>     <span class="keyword">typedef</span> size_t hashcode_t;
<a name="l00049"></a><a class="code" href="a00217.html">00049</a>     <span class="keyword">class </span><a class="code" href="a00217.html">hash_map_base</a> {
00050     <span class="keyword">public</span>:
00051         <span class="comment">// Mutex types for each layer of the container</span>
00052         <span class="keyword">typedef</span> <a class="code" href="a00246.html">spin_rw_mutex</a> <a class="code" href="a00246.html">node_mutex_t</a>;
00053         <span class="keyword">typedef</span> <a class="code" href="a00246.html">spin_rw_mutex</a> <a class="code" href="a00246.html">chain_mutex_t</a>;
00054         <span class="keyword">typedef</span> <a class="code" href="a00246.html">spin_rw_mutex</a> <a class="code" href="a00246.html">segment_mutex_t</a>;
00055 
<a name="l00057"></a><a class="code" href="a00217.html#w3">00057</a>         <span class="keyword">typedef</span> <a class="code" href="a00311.html#a2">internal::hashcode_t</a> hashcode_t;
<a name="l00059"></a><a class="code" href="a00217.html#s0">00059</a>         <span class="keyword">static</span> <span class="keyword">const</span> size_t n_segment_bits = 6;
<a name="l00061"></a><a class="code" href="a00217.html#s1">00061</a>         <span class="keyword">static</span> <span class="keyword">const</span> size_t n_segment = size_t(1)&lt;&lt;n_segment_bits; 
<a name="l00063"></a><a class="code" href="a00217.html#s2">00063</a>         <span class="keyword">static</span> <span class="keyword">const</span> size_t max_physical_size = size_t(1)&lt;&lt;(8*<span class="keyword">sizeof</span>(hashcode_t)-n_segment_bits);
00064     };
00065 
00066     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Iterator&gt;
00067     <span class="keyword">class </span><a class="code" href="a00219.html">hash_map_range</a>;
00068 
00069     <span class="keyword">struct </span>hash_map_segment_base {
00071         <a class="code" href="a00246.html">hash_map_base::segment_mutex_t</a> my_mutex;
00072 
00073         <span class="comment">// Number of nodes</span>
00074         <a class="code" href="a00186.html">atomic&lt;size_t&gt;</a> my_logical_size;
00075 
00076         <span class="comment">// Size of chains</span>
00078 <span class="comment"></span>        size_t my_physical_size;
00079 
00081 
00082         <span class="keywordtype">bool</span> __TBB_EXPORTED_METHOD internal_grow_predicate() <span class="keyword">const</span>;
00083     };
00084 
00086 
00088     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Container, <span class="keyword">typename</span> Value&gt;
<a name="l00089"></a><a class="code" href="a00218.html">00089</a>     <span class="keyword">class </span><a class="code" href="a00218.html">hash_map_iterator</a>
00090         : <span class="keyword">public</span> std::iterator&lt;std::forward_iterator_tag,Value&gt;
00091     {
00092         <span class="keyword">typedef</span> <span class="keyword">typename</span> Container::node node;
00093         <span class="keyword">typedef</span> <span class="keyword">typename</span> Container::chain chain;
00094         <span class="keyword">typedef</span> <span class="keyword">typename</span> Container::segment segment;
00095 
00097         Container* my_table;
00098 
00100         node* my_node;
00101 
00103         size_t my_array_index;
00104 
00106         size_t my_segment_index;
00107 
00108         <span class="keyword">template</span>&lt;<span class="keyword">typename</span> C, <span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;
00109         <span class="keyword">friend</span> <span class="keywordtype">bool</span> operator==( <span class="keyword">const</span> <a class="code" href="a00218.html">hash_map_iterator&lt;C,T&gt;</a>&amp; i, <span class="keyword">const</span> <a class="code" href="a00218.html">hash_map_iterator&lt;C,U&gt;</a>&amp; j );
00110 
00111         <span class="keyword">template</span>&lt;<span class="keyword">typename</span> C, <span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;
00112         <span class="keyword">friend</span> <span class="keywordtype">bool</span> operator!=( <span class="keyword">const</span> <a class="code" href="a00218.html">hash_map_iterator&lt;C,T&gt;</a>&amp; i, <span class="keyword">const</span> <a class="code" href="a00218.html">hash_map_iterator&lt;C,U&gt;</a>&amp; j );
00113 
00114         <span class="keyword">template</span>&lt;<span class="keyword">typename</span> C, <span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;
00115         <span class="keyword">friend</span> ptrdiff_t operator-( <span class="keyword">const</span> <a class="code" href="a00218.html">hash_map_iterator&lt;C,T&gt;</a>&amp; i, <span class="keyword">const</span> <a class="code" href="a00218.html">hash_map_iterator&lt;C,U&gt;</a>&amp; j );
00116     
00117         <span class="keyword">template</span>&lt;<span class="keyword">typename</span> C, <span class="keyword">typename</span> U&gt;
00118         <span class="keyword">friend</span> <span class="keyword">class </span><a class="code" href="a00218.html">internal::hash_map_iterator</a>;
00119 
00120         <span class="keyword">template</span>&lt;<span class="keyword">typename</span> I&gt;
00121         <span class="keyword">friend</span> <span class="keyword">class </span><a class="code" href="a00219.html">internal::hash_map_range</a>;
00122 
00123         <span class="keywordtype">void</span> advance_to_next_node() {
00124             size_t i = my_array_index+1;
00125             <span class="keywordflow">do</span> {
00126                 segment &amp;s = my_table-&gt;my_segment[my_segment_index];
00127                 <span class="keywordflow">while</span>( i&lt;s.my_physical_size ) {
00128                     my_node = s.my_array[i].node_list;
00129                     <span class="keywordflow">if</span>( my_node ) <span class="keywordflow">goto</span> done;
00130                     ++i;
00131                 }
00132                 i = 0;
00133             } <span class="keywordflow">while</span>( ++my_segment_index&lt;my_table-&gt;n_segment );
00134         done:
00135             my_array_index = i;
00136         }
00137 <span class="preprocessor">#if !defined(_MSC_VER) || defined(__INTEL_COMPILER)</span>
00138 <span class="preprocessor"></span>        <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Key, <span class="keyword">typename</span> T, <span class="keyword">typename</span> HashCompare, <span class="keyword">typename</span> A&gt;
00139         <span class="keyword">friend</span> <span class="keyword">class </span><a class="code" href="a00196.html">tbb::concurrent_hash_map</a>;
00140 <span class="preprocessor">#else</span>
00141 <span class="preprocessor"></span>    <span class="keyword">public</span>: <span class="comment">// workaround</span>
00142 <span class="preprocessor">#endif</span>
00143 <span class="preprocessor"></span>        <a class="code" href="a00218.html">hash_map_iterator</a>( <span class="keyword">const</span> Container&amp; table, size_t segment_index, size_t array_index=0, node* b=NULL );
00144     <span class="keyword">public</span>:
<a name="l00146"></a><a class="code" href="a00218.html#a1">00146</a>         <a class="code" href="a00218.html">hash_map_iterator</a>() {}
00147         <a class="code" href="a00218.html">hash_map_iterator</a>( <span class="keyword">const</span> <a class="code" href="a00218.html">hash_map_iterator&lt;Container,typename Container::value_type&gt;</a>&amp; other ) :
00148             my_table(other.my_table),
00149             my_node(other.my_node),
00150             my_array_index(other.my_array_index),
00151             my_segment_index(other.my_segment_index)
00152         {}
00153         Value&amp; operator*()<span class="keyword"> const </span>{
00154             __TBB_ASSERT( my_node, <span class="stringliteral">"iterator uninitialized or at end of container?"</span> );
00155             <span class="keywordflow">return</span> my_node-&gt;item;
00156         }
00157         Value* operator-&gt;()<span class="keyword"> const </span>{<span class="keywordflow">return</span> &amp;operator*();}
00158         hash_map_iterator&amp; operator++();
00159         
<a name="l00161"></a><a class="code" href="a00218.html#a6">00161</a>         Value* operator++(<span class="keywordtype">int</span>) {
00162             Value* result = &amp;operator*();
00163             operator++();
00164             <span class="keywordflow">return</span> result;
00165         }
00166     };
00167 
00168     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Container, <span class="keyword">typename</span> Value&gt;
00169     hash_map_iterator&lt;Container,Value&gt;::hash_map_iterator( <span class="keyword">const</span> Container&amp; table, size_t segment_index, size_t array_index, node* b ) : 
00170         my_table(const_cast&lt;Container*&gt;(&amp;table)),
00171         my_node(b),
00172         my_array_index(array_index),
00173         my_segment_index(segment_index)
00174     {
00175         <span class="keywordflow">if</span>( segment_index&lt;my_table-&gt;n_segment ) {
00176             <span class="keywordflow">if</span>( !my_node ) {
00177                 segment &amp;s = my_table-&gt;my_segment[segment_index];
00178                 chain* first_chain = s.my_array;
00179                 <span class="keywordflow">if</span>( first_chain &amp;&amp; my_array_index &lt; s.my_physical_size)
00180                     my_node = first_chain[my_array_index].node_list;
00181             }
00182             <span class="keywordflow">if</span>( !my_node ) advance_to_next_node();
00183         }
00184     }
00185 
00186     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Container, <span class="keyword">typename</span> Value&gt;
00187     hash_map_iterator&lt;Container,Value&gt;&amp; hash_map_iterator&lt;Container,Value&gt;::operator++() {
00188         my_node=my_node-&gt;next;
00189         <span class="keywordflow">if</span>( !my_node ) advance_to_next_node();
00190         <span class="keywordflow">return</span> *<span class="keyword">this</span>;
00191     }
00192 
00193     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Container, <span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;
00194     <span class="keywordtype">bool</span> operator==( <span class="keyword">const</span> hash_map_iterator&lt;Container,T&gt;&amp; i, <span class="keyword">const</span> hash_map_iterator&lt;Container,U&gt;&amp; j ) {
00195         <span class="keywordflow">return</span> i.<a class="code" href="a00218.html#r1">my_node</a>==j.<a class="code" href="a00218.html#r1">my_node</a>;
00196     }
00197 
00198     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Container, <span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;
00199     <span class="keywordtype">bool</span> operator!=( <span class="keyword">const</span> hash_map_iterator&lt;Container,T&gt;&amp; i, <span class="keyword">const</span> hash_map_iterator&lt;Container,U&gt;&amp; j ) {
00200         <span class="keywordflow">return</span> i.<a class="code" href="a00218.html#r1">my_node</a>!=j.<a class="code" href="a00218.html#r1">my_node</a>;
00201     }
00202 
00204 
00205     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Iterator&gt;
<a name="l00206"></a><a class="code" href="a00219.html">00206</a>     <span class="keyword">class </span><a class="code" href="a00219.html">hash_map_range</a> {
00207     <span class="keyword">private</span>:
00208         Iterator my_begin;
00209         Iterator my_end;
00210         <span class="keyword">mutable</span> Iterator my_midpoint;
00211         size_t my_grainsize;
00213         <span class="keywordtype">void</span> set_midpoint() <span class="keyword">const</span>;
00214         <span class="keyword">template</span>&lt;<span class="keyword">typename</span> U&gt; <span class="keyword">friend</span> <span class="keyword">class </span><a class="code" href="a00219.html">hash_map_range</a>;
00215     <span class="keyword">public</span>:
<a name="l00217"></a><a class="code" href="a00219.html#w0">00217</a>         <span class="keyword">typedef</span> std::size_t size_type;
00218         <span class="keyword">typedef</span> <span class="keyword">typename</span> Iterator::value_type value_type;
00219         <span class="keyword">typedef</span> <span class="keyword">typename</span> Iterator::reference reference;
00220         <span class="keyword">typedef</span> <span class="keyword">typename</span> Iterator::difference_type difference_type;
00221         <span class="keyword">typedef</span> Iterator iterator;
00222 
<a name="l00224"></a><a class="code" href="a00219.html#a0">00224</a>         <span class="keywordtype">bool</span> empty()<span class="keyword"> const </span>{<span class="keywordflow">return</span> my_begin==my_end;}
00225 
<a name="l00227"></a><a class="code" href="a00219.html#a1">00227</a>         <span class="keywordtype">bool</span> is_divisible()<span class="keyword"> const </span>{
00228             <span class="keywordflow">return</span> my_midpoint!=my_end;
00229         }
<a name="l00231"></a><a class="code" href="a00219.html#a2">00231</a>         <a class="code" href="a00219.html">hash_map_range</a>( <a class="code" href="a00219.html">hash_map_range</a>&amp; r, <a class="code" href="a00248.html">split</a> ) : 
00232             my_end(r.my_end),
00233             my_grainsize(r.my_grainsize)
00234         {
00235             r.<a class="code" href="a00219.html#r1">my_end</a> = my_begin = r.<a class="code" href="a00219.html#r2">my_midpoint</a>;
00236             __TBB_ASSERT( my_begin!=my_end, <span class="stringliteral">"Splitting despite the range is not divisible"</span> );
00237             __TBB_ASSERT( r.<a class="code" href="a00219.html#r0">my_begin</a>!=r.<a class="code" href="a00219.html#r1">my_end</a>, <span class="stringliteral">"Splitting despite the range is not divisible"</span> );
00238             set_midpoint();
00239             r.<a class="code" href="a00219.html#d0">set_midpoint</a>();
00240         }
00242         <span class="keyword">template</span>&lt;<span class="keyword">typename</span> U&gt;
<a name="l00243"></a><a class="code" href="a00219.html#a3">00243</a>         <a class="code" href="a00219.html">hash_map_range</a>( <a class="code" href="a00219.html">hash_map_range&lt;U&gt;</a>&amp; r) : 
00244             my_begin(r.my_begin),
00245             my_end(r.my_end),
00246             my_midpoint(r.my_midpoint),
00247             my_grainsize(r.my_grainsize)
00248         {}
<a name="l00250"></a><a class="code" href="a00219.html#a4">00250</a>         <a class="code" href="a00219.html">hash_map_range</a>( <span class="keyword">const</span> Iterator&amp; begin_, <span class="keyword">const</span> Iterator&amp; end_, size_type grainsize = 1 ) : 
00251             my_begin(begin_), 
00252             my_end(end_), 
00253             my_grainsize(grainsize) 
00254         {
00255             set_midpoint();
00256             __TBB_ASSERT( grainsize&gt;0, <span class="stringliteral">"grainsize must be positive"</span> );
00257         }
00258         <span class="keyword">const</span> Iterator&amp; begin()<span class="keyword"> const </span>{<span class="keywordflow">return</span> my_begin;}
00259         <span class="keyword">const</span> Iterator&amp; end()<span class="keyword"> const </span>{<span class="keywordflow">return</span> my_end;}
<a name="l00261"></a><a class="code" href="a00219.html#a7">00261</a>         size_type grainsize()<span class="keyword"> const </span>{<span class="keywordflow">return</span> my_grainsize;}
00262     };
00263 
00264     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Iterator&gt;
00265     <span class="keywordtype">void</span> hash_map_range&lt;Iterator&gt;::set_midpoint()<span class="keyword"> const </span>{
00266         size_t n = my_end.my_segment_index - my_begin.my_segment_index;
00267         <span class="keywordflow">if</span>( n &gt; 1 || (n == 1 &amp;&amp; my_end.my_array_index &gt; my_grainsize/2) ) {
00268             <span class="comment">// Split by groups of segments</span>
00269             my_midpoint = Iterator(*my_begin.my_table,(my_end.my_segment_index+my_begin.my_segment_index+1)/2u);
00270         } <span class="keywordflow">else</span> {
00271             <span class="comment">// Split by groups of nodes</span>
00272             size_t m = my_end.my_array_index-my_begin.my_array_index;
00273             <span class="keywordflow">if</span>( n ) m += my_begin.my_table-&gt;my_segment[my_begin.my_segment_index].my_physical_size;
00274             <span class="keywordflow">if</span>( m &gt; my_grainsize ) {
00275                 my_midpoint = Iterator(*my_begin.my_table,my_begin.my_segment_index,my_begin.my_array_index + m/2u);
00276             } <span class="keywordflow">else</span> {
00277                 my_midpoint = my_end;
00278             }
00279         }
00280         __TBB_ASSERT( my_begin.my_segment_index &lt; my_midpoint.my_segment_index
00281             || (my_begin.my_segment_index == my_midpoint.my_segment_index
00282             &amp;&amp; my_begin.my_array_index &lt;= my_midpoint.my_array_index),
00283             <span class="stringliteral">"my_begin is after my_midpoint"</span> );
00284         __TBB_ASSERT( my_midpoint.my_segment_index &lt; my_end.my_segment_index
00285             || (my_midpoint.my_segment_index == my_end.my_segment_index
00286             &amp;&amp; my_midpoint.my_array_index &lt;= my_end.my_array_index),
00287             <span class="stringliteral">"my_midpoint is after my_end"</span> );
00288         __TBB_ASSERT( my_begin != my_midpoint || my_begin == my_end,
00289             <span class="stringliteral">"[my_begin, my_midpoint) range should not be empty"</span> );
00290     }
<a name="l00292"></a><a class="code" href="a00311.html#a3">00292</a>     <span class="keyword">static</span> <span class="keyword">const</span> <a class="code" href="a00311.html#a2">hashcode_t</a> <a class="code" href="a00311.html#a3">hash_multiplier</a> = <span class="keyword">sizeof</span>(hashcode_t)==4? 2654435769U : 11400714819323198485ULL;
00294     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;
<a name="l00295"></a><a class="code" href="a00311.html#a36">00295</a>     <span class="keyword">inline</span> <span class="keyword">static</span> <a class="code" href="a00311.html#a2">hashcode_t</a> <a class="code" href="a00311.html#a36">hasher</a>( <span class="keyword">const</span> T&amp; t ) {
00296         <span class="keywordflow">return</span> static_cast&lt;hashcode_t&gt;( t ) * hash_multiplier;
00297     }
00298     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> P&gt;
00299     <span class="keyword">inline</span> <span class="keyword">static</span> hashcode_t <a class="code" href="a00311.html#a36">hasher</a>( P* ptr ) {
00300         hashcode_t <span class="keyword">const</span> h = reinterpret_cast&lt;hashcode_t&gt;( ptr );
00301         <span class="keywordflow">return</span> (h &gt;&gt; 3) ^ h;
00302     }
00303     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> E, <span class="keyword">typename</span> S, <span class="keyword">typename</span> A&gt;
00304     <span class="keyword">inline</span> <span class="keyword">static</span> hashcode_t <a class="code" href="a00311.html#a36">hasher</a>( <span class="keyword">const</span> std::basic_string&lt;E,S,A&gt;&amp; s ) {
00305         hashcode_t h = 0;
00306         <span class="keywordflow">for</span>( <span class="keyword">const</span> E* c = s.c_str(); *c; c++ )
00307             h = static_cast&lt;hashcode_t&gt;(*c) ^ (h * hash_multiplier);
00308         <span class="keywordflow">return</span> h;
00309     }
00310     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> F, <span class="keyword">typename</span> S&gt;
00311     <span class="keyword">inline</span> <span class="keyword">static</span> <a class="code" href="a00311.html#a2">hashcode_t</a> <a class="code" href="a00311.html#a36">hasher</a>( <span class="keyword">const</span> std::pair&lt;F,S&gt;&amp; p ) {
00312         <span class="keywordflow">return</span> <a class="code" href="a00311.html#a36">hasher</a>(p.first) ^ <a class="code" href="a00311.html#a36">hasher</a>(p.second);
00313     }
00314 } <span class="comment">// namespace internal</span>
00316 <span class="comment"></span>
00318 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;
<a name="l00319"></a><a class="code" href="a00263.html">00319</a> <span class="keyword">struct </span><a class="code" href="a00263.html">tbb_hash_compare</a> {
00320     <span class="keyword">static</span> <a class="code" href="a00311.html#a2">internal::hashcode_t</a> hash( <span class="keyword">const</span> T&amp; t ) { <span class="keywordflow">return</span> internal::hasher(t); }
00321     <span class="keyword">static</span> <span class="keywordtype">bool</span> equal( <span class="keyword">const</span> T&amp; a, <span class="keyword">const</span> T&amp; b ) { <span class="keywordflow">return</span> a == b; }
00322 };
00323 
00325 
00350 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Key, <span class="keyword">typename</span> T, <span class="keyword">typename</span> HashCompare, <span class="keyword">typename</span> A&gt;
<a name="l00351"></a><a class="code" href="a00196.html">00351</a> <span class="keyword">class </span><a class="code" href="a00196.html">concurrent_hash_map</a> : <span class="keyword">protected</span> internal::hash_map_base {
00352     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Container, <span class="keyword">typename</span> Value&gt;
00353     <span class="keyword">friend</span> <span class="keyword">class </span><a class="code" href="a00218.html">internal::hash_map_iterator</a>;
00354 
00355     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> I&gt;
00356     <span class="keyword">friend</span> <span class="keyword">class </span><a class="code" href="a00219.html">internal::hash_map_range</a>;
00357 
00358     <span class="keyword">struct </span>node;
00359     <span class="keyword">friend</span> <span class="keyword">struct </span>node;
00360     <span class="keyword">typedef</span> <span class="keyword">typename</span> A::template rebind&lt;node&gt;::other node_allocator_type;
00361 
00362 <span class="keyword">public</span>:
00363     <span class="keyword">class </span><a class="code" href="a00198.html">const_accessor</a>;
00364     <span class="keyword">friend</span> <span class="keyword">class </span><a class="code" href="a00198.html">const_accessor</a>;
00365     <span class="keyword">class </span><a class="code" href="a00197.html">accessor</a>;
00366 
00367     <span class="keyword">typedef</span> Key key_type;
00368     <span class="keyword">typedef</span> T mapped_type;
00369     <span class="keyword">typedef</span> std::pair&lt;const Key,T&gt; value_type;
00370     <span class="keyword">typedef</span> size_t size_type;
00371     <span class="keyword">typedef</span> ptrdiff_t difference_type;
00372     <span class="keyword">typedef</span> value_type *pointer;
00373     <span class="keyword">typedef</span> <span class="keyword">const</span> value_type *const_pointer;
00374     <span class="keyword">typedef</span> value_type &amp;reference;
00375     <span class="keyword">typedef</span> <span class="keyword">const</span> value_type &amp;const_reference;
00376     <span class="keyword">typedef</span> <a class="code" href="a00218.html">internal::hash_map_iterator&lt;concurrent_hash_map,value_type&gt;</a> <a class="code" href="a00218.html">iterator</a>;
00377     <span class="keyword">typedef</span> <a class="code" href="a00218.html">internal::hash_map_iterator&lt;concurrent_hash_map,const value_type&gt;</a> <a class="code" href="a00218.html">const_iterator</a>;
00378     <span class="keyword">typedef</span> <a class="code" href="a00219.html">internal::hash_map_range&lt;iterator&gt;</a> <a class="code" href="a00219.html">range_type</a>;
00379     <span class="keyword">typedef</span> <a class="code" href="a00219.html">internal::hash_map_range&lt;const_iterator&gt;</a> <a class="code" href="a00219.html">const_range_type</a>;
00380     <span class="keyword">typedef</span> A allocator_type;
00381 
<a name="l00383"></a><a class="code" href="a00198.html">00383</a>     <span class="keyword">class </span><a class="code" href="a00198.html">const_accessor</a> {
00384         <span class="keyword">friend</span> <span class="keyword">class </span><a class="code" href="a00196.html">concurrent_hash_map</a>&lt;Key,T,HashCompare,A&gt;;
00385         <span class="keyword">friend</span> <span class="keyword">class </span><a class="code" href="a00197.html">accessor</a>;
00386         <span class="keywordtype">void</span> operator=( <span class="keyword">const</span> <a class="code" href="a00197.html">accessor</a>&amp; ) <span class="keyword">const</span>; <span class="comment">// Deny access</span>
00387         <a class="code" href="a00198.html">const_accessor</a>( <span class="keyword">const</span> <a class="code" href="a00197.html">accessor</a>&amp; );       <span class="comment">// Deny access</span>
00388     <span class="keyword">public</span>:
<a name="l00390"></a><a class="code" href="a00198.html#w0">00390</a>         <span class="keyword">typedef</span> <span class="keyword">const</span> std::pair&lt;const Key,T&gt; value_type;
00391 
<a name="l00393"></a><a class="code" href="a00198.html#a0">00393</a>         <span class="keywordtype">bool</span> empty()<span class="keyword"> const </span>{<span class="keywordflow">return</span> !my_node;}
00394 
<a name="l00396"></a><a class="code" href="a00198.html#a1">00396</a>         <span class="keywordtype">void</span> <a class="code" href="a00310.html#a57a2">release</a>() {
00397             <span class="keywordflow">if</span>( my_node ) {
00398                 my_lock.release();
00399                 my_node = NULL;
00400             }
00401         }
00402 
<a name="l00404"></a><a class="code" href="a00198.html#a2">00404</a>         const_reference operator*()<span class="keyword"> const </span>{
00405             __TBB_ASSERT( my_node, <span class="stringliteral">"attempt to dereference empty accessor"</span> );
00406             <span class="keywordflow">return</span> my_node-&gt;item;
00407         }
00408 
<a name="l00410"></a><a class="code" href="a00198.html#a3">00410</a>         const_pointer operator-&gt;()<span class="keyword"> const </span>{
00411             <span class="keywordflow">return</span> &amp;operator*();
00412         }
00413 
<a name="l00415"></a><a class="code" href="a00198.html#a4">00415</a>         <a class="code" href="a00198.html">const_accessor</a>() : my_node(NULL) {}
00416 
<a name="l00418"></a><a class="code" href="a00198.html#a5">00418</a>         ~<a class="code" href="a00198.html">const_accessor</a>() {
00419             my_node = NULL; <span class="comment">// my_lock.release() is called in scoped_lock destructor</span>
00420         }
00421     <span class="keyword">private</span>:
00422         node* my_node;
00423         node_mutex_t::scoped_lock my_lock;
00424         hashcode_t my_hash;
00425     };
00426 
<a name="l00428"></a><a class="code" href="a00197.html">00428</a>     <span class="keyword">class </span><a class="code" href="a00197.html">accessor</a>: <span class="keyword">public</span> <a class="code" href="a00198.html">const_accessor</a> {
00429     <span class="keyword">public</span>:
<a name="l00431"></a><a class="code" href="a00197.html#w0">00431</a>         <span class="keyword">typedef</span> std::pair&lt;const Key,T&gt; value_type;
00432 
<a name="l00434"></a><a class="code" href="a00197.html#a0">00434</a>         reference operator*()<span class="keyword"> const </span>{
00435             __TBB_ASSERT( this-&gt;my_node, <span class="stringliteral">"attempt to dereference empty accessor"</span> );
00436             <span class="keywordflow">return</span> this-&gt;my_node-&gt;item;
00437         }
00438 
<a name="l00440"></a><a class="code" href="a00197.html#a1">00440</a>         pointer operator-&gt;()<span class="keyword"> const </span>{
00441             <span class="keywordflow">return</span> &amp;operator*();
00442         }       
00443     };
00444 
<a name="l00446"></a><a class="code" href="a00196.html#a0">00446</a>     <a class="code" href="a00196.html">concurrent_hash_map</a>(<span class="keyword">const</span> allocator_type &amp;a = allocator_type())
00447         : my_allocator(a)
00448 
00449     {
00450         initialize();
00451     }
00452 
<a name="l00454"></a><a class="code" href="a00196.html#a1">00454</a>     <a class="code" href="a00196.html">concurrent_hash_map</a>( <span class="keyword">const</span> <a class="code" href="a00196.html">concurrent_hash_map</a>&amp; table, <span class="keyword">const</span> allocator_type &amp;a = allocator_type())
00455         : my_allocator(a)
00456     {
00457         initialize();
00458         internal_copy(table);
00459     }
00460 
00462     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> I&gt;
<a name="l00463"></a><a class="code" href="a00196.html#a2">00463</a>     <a class="code" href="a00196.html">concurrent_hash_map</a>(I first, I last, <span class="keyword">const</span> allocator_type &amp;a = allocator_type())
00464         : my_allocator(a)
00465     {
00466         initialize();
00467         internal_copy(first, last);
00468     }
00469 
<a name="l00471"></a><a class="code" href="a00196.html#a3">00471</a>     <a class="code" href="a00196.html">concurrent_hash_map</a>&amp; operator=( <span class="keyword">const</span> <a class="code" href="a00196.html">concurrent_hash_map</a>&amp; table ) {
00472         <span class="keywordflow">if</span>( <span class="keyword">this</span>!=&amp;table ) {
00473             clear();
00474             internal_copy(table);
00475         } 
00476         <span class="keywordflow">return</span> *<span class="keyword">this</span>;
00477     }
00478 
00479 
00481     <span class="keywordtype">void</span> clear();
00482 
00484     ~<a class="code" href="a00196.html">concurrent_hash_map</a>();
00485 
00486     <span class="comment">//------------------------------------------------------------------------</span>
00487     <span class="comment">// Parallel algorithm support</span>
00488     <span class="comment">//------------------------------------------------------------------------</span>
00489     range_type range( size_type grainsize=1 ) {
00490         <span class="keywordflow">return</span> range_type( begin(), end(), grainsize );
00491     }
00492     const_range_type range( size_type grainsize=1 )<span class="keyword"> const </span>{
00493         <span class="keywordflow">return</span> const_range_type( begin(), end(), grainsize );
00494     }
00495 
00496     <span class="comment">//------------------------------------------------------------------------</span>
00497     <span class="comment">// STL support - not thread-safe methods</span>
00498     <span class="comment">//------------------------------------------------------------------------</span>
00499     iterator begin() {<span class="keywordflow">return</span> iterator(*<span class="keyword">this</span>,0);}
00500     iterator end() {<span class="keywordflow">return</span> iterator(*<span class="keyword">this</span>,n_segment);}
00501     const_iterator begin()<span class="keyword"> const </span>{<span class="keywordflow">return</span> const_iterator(*<span class="keyword">this</span>,0);}
00502     const_iterator end()<span class="keyword"> const </span>{<span class="keywordflow">return</span> const_iterator(*<span class="keyword">this</span>,n_segment);}
00503     std::pair&lt;iterator, iterator&gt; equal_range( <span class="keyword">const</span> Key&amp; key ) { <span class="keywordflow">return</span> internal_equal_range(key, end()); }
00504     std::pair&lt;const_iterator, const_iterator&gt; equal_range( <span class="keyword">const</span> Key&amp; key )<span class="keyword"> const </span>{ <span class="keywordflow">return</span> internal_equal_range(key, end()); }
00505     
00507 
00509     size_type size() <span class="keyword">const</span>;
00510 
00512     <span class="keywordtype">bool</span> empty() <span class="keyword">const</span>;
00513 
<a name="l00515"></a><a class="code" href="a00196.html#a16">00515</a>     size_type max_size()<span class="keyword"> const </span>{<span class="keywordflow">return</span> (~size_type(0))/<span class="keyword">sizeof</span>(node);}
00516 
<a name="l00518"></a><a class="code" href="a00196.html#a17">00518</a>     allocator_type get_allocator()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> this-&gt;my_allocator; }
00519 
00521     <span class="keywordtype">void</span> swap(<a class="code" href="a00196.html">concurrent_hash_map</a> &amp;table);
00522 
00523     <span class="comment">//------------------------------------------------------------------------</span>
00524     <span class="comment">// concurrent map operations</span>
00525     <span class="comment">//------------------------------------------------------------------------</span>
00526 
<a name="l00528"></a><a class="code" href="a00196.html#a19">00528</a>     size_type count( <span class="keyword">const</span> Key&amp; key )<span class="keyword"> const </span>{
00529         <span class="keywordflow">return</span> const_cast&lt;concurrent_hash_map*&gt;(<span class="keyword">this</span>)-&gt;<a class="code" href="a00196.html#d7">lookup</a>&lt;<span class="comment">/*insert*/</span><span class="keyword">false</span>&gt;(NULL, key, <span class="comment">/*write=*/</span><span class="keyword">false</span>, NULL );
00530     }
00531 
00533 
<a name="l00534"></a><a class="code" href="a00196.html#a20">00534</a>     <span class="keywordtype">bool</span> find( <a class="code" href="a00198.html">const_accessor</a>&amp; result, <span class="keyword">const</span> Key&amp; key )<span class="keyword"> const </span>{
00535         <span class="keywordflow">return</span> const_cast&lt;concurrent_hash_map*&gt;(<span class="keyword">this</span>)-&gt;<a class="code" href="a00196.html#d7">lookup</a>&lt;<span class="comment">/*insert*/</span><span class="keyword">false</span>&gt;(&amp;result, key, <span class="comment">/*write=*/</span><span class="keyword">false</span>, NULL );
00536     }
00537 
00539 
<a name="l00540"></a><a class="code" href="a00196.html#a21">00540</a>     <span class="keywordtype">bool</span> find( <a class="code" href="a00197.html">accessor</a>&amp; result, <span class="keyword">const</span> Key&amp; key ) {
00541         <span class="keywordflow">return</span> lookup&lt;<span class="comment">/*insert*/</span><span class="keyword">false</span>&gt;(&amp;result, key, <span class="comment">/*write=*/</span><span class="keyword">true</span>, NULL );
00542     }
00543         
00545 
<a name="l00546"></a><a class="code" href="a00196.html#a22">00546</a>     <span class="keywordtype">bool</span> insert( <a class="code" href="a00198.html">const_accessor</a>&amp; result, <span class="keyword">const</span> Key&amp; key ) {
00547         <span class="keywordflow">return</span> lookup&lt;<span class="comment">/*insert*/</span><span class="keyword">true</span>&gt;(&amp;result, key, <span class="comment">/*write=*/</span><span class="keyword">false</span>, NULL );
00548     }
00549 
00551 
<a name="l00552"></a><a class="code" href="a00196.html#a23">00552</a>     <span class="keywordtype">bool</span> insert( <a class="code" href="a00197.html">accessor</a>&amp; result, <span class="keyword">const</span> Key&amp; key ) {
00553         <span class="keywordflow">return</span> lookup&lt;<span class="comment">/*insert*/</span><span class="keyword">true</span>&gt;(&amp;result, key, <span class="comment">/*write=*/</span><span class="keyword">true</span>, NULL );
00554     }
00555 
00557 
<a name="l00558"></a><a class="code" href="a00196.html#a24">00558</a>     <span class="keywordtype">bool</span> insert( <a class="code" href="a00198.html">const_accessor</a>&amp; result, <span class="keyword">const</span> value_type&amp; value ) {
00559         <span class="keywordflow">return</span> lookup&lt;<span class="comment">/*insert*/</span><span class="keyword">true</span>&gt;(&amp;result, value.first, <span class="comment">/*write=*/</span><span class="keyword">false</span>, &amp;value.second );
00560     }
00561 
00563 
<a name="l00564"></a><a class="code" href="a00196.html#a25">00564</a>     <span class="keywordtype">bool</span> insert( <a class="code" href="a00197.html">accessor</a>&amp; result, <span class="keyword">const</span> value_type&amp; value ) {
00565         <span class="keywordflow">return</span> lookup&lt;<span class="comment">/*insert*/</span><span class="keyword">true</span>&gt;(&amp;result, value.first, <span class="comment">/*write=*/</span><span class="keyword">true</span>, &amp;value.second );
00566     }
00567 
00569 
<a name="l00570"></a><a class="code" href="a00196.html#a26">00570</a>     <span class="keywordtype">bool</span> insert( <span class="keyword">const</span> value_type&amp; value ) {
00571         <span class="keywordflow">return</span> lookup&lt;<span class="comment">/*insert*/</span><span class="keyword">true</span>&gt;(NULL, value.first, <span class="comment">/*write=*/</span><span class="keyword">false</span>, &amp;value.second );
00572     }
00573 
00575     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> I&gt;
<a name="l00576"></a><a class="code" href="a00196.html#a27">00576</a>     <span class="keywordtype">void</span> insert(I first, I last) {
00577         <span class="keywordflow">for</span>(; first != last; ++first)
00578             insert( *first );
00579     }
00580 
00582 
00583     <span class="keywordtype">bool</span> erase( <span class="keyword">const</span> Key&amp; key );
00584 
00586 
<a name="l00587"></a><a class="code" href="a00196.html#a29">00587</a>     <span class="keywordtype">bool</span> erase( <a class="code" href="a00198.html">const_accessor</a>&amp; item_accessor ) {
00588         <span class="keywordflow">return</span> exclude( item_accessor, <span class="comment">/*readonly=*/</span> <span class="keyword">true</span> );
00589     }
00590 
00592 
<a name="l00593"></a><a class="code" href="a00196.html#a30">00593</a>     <span class="keywordtype">bool</span> erase( <a class="code" href="a00197.html">accessor</a>&amp; item_accessor ) {
00594         <span class="keywordflow">return</span> exclude( item_accessor, <span class="comment">/*readonly=*/</span> <span class="keyword">false</span> );
00595     }
00596 
00597 <span class="keyword">private</span>:
00599     <span class="keyword">struct </span>node: internal::no_copy {
00601         node* next;
00602         node_mutex_t <a class="code" href="a00222.html">mutex</a>;
00603         value_type item;
00604         node( <span class="keyword">const</span> Key&amp; key ) : item(key, T()) {}
00605         node( <span class="keyword">const</span> Key&amp; key, <span class="keyword">const</span> T&amp; t ) : item(key, t) {}
00606         <span class="comment">// exception-safe allocation, see C++ Standard 2003, clause 5.3.4p17</span>
00607         <span class="keywordtype">void</span>* operator new( size_t <span class="comment">/*size*/</span>, node_allocator_type&amp; a ) {
00608             <span class="keywordtype">void</span> *ptr = a.allocate(1);
00609             <span class="keywordflow">if</span>(!ptr) <span class="keywordflow">throw</span> std::bad_alloc();
00610             <span class="keywordflow">return</span> ptr;
00611         }
00612         <span class="comment">// match placement-new form above to be called if exception thrown in constructor</span>
00613         <span class="keywordtype">void</span> operator delete( <span class="keywordtype">void</span>* ptr, node_allocator_type&amp; a ) {<span class="keywordflow">return</span> a.deallocate(static_cast&lt;node*&gt;(ptr),1); }
00614     };
00615 
00616     <span class="keyword">struct </span>chain;
00617     <span class="keyword">friend</span> <span class="keyword">struct </span>chain;
00618 
00620 
00621     <span class="keyword">struct </span>chain {
00622         <span class="keywordtype">void</span> push_front( node&amp; b ) {
00623             b.next = node_list;
00624             node_list = &amp;b;
00625         }
00626         chain_mutex_t mutex;
00627         node* node_list;
00628     };
00629 
00630     <span class="keyword">struct </span>segment;
00631     <span class="keyword">friend</span> <span class="keyword">struct </span>segment;
00632 
00634 
00636     <span class="keyword">struct </span>segment: internal::hash_map_segment_base {
00637 <span class="preprocessor">#if TBB_USE_ASSERT</span>
00638 <span class="preprocessor"></span>        ~segment() {
00639             __TBB_ASSERT( !my_array, <span class="stringliteral">"should have been cleared earlier"</span> );
00640         }
00641 <span class="preprocessor">#endif </span><span class="comment">/* TBB_USE_ASSERT */</span>
00642 
00643         <span class="comment">// Pointer to array of chains</span>
00644         chain* my_array;
00645 
00646         <span class="comment">// Get chain in this segment that corresponds to given hash code.</span>
00647         chain&amp; get_chain( hashcode_t hashcode, size_t n_segment_bits ) {
00648             <span class="keywordflow">return</span> my_array[(hashcode&gt;&gt;n_segment_bits)&amp;(my_physical_size-1)];
00649         }
00650      
00652 
00654         <span class="keywordtype">void</span> allocate_array( size_t new_size ) {
00655             size_t n=(internal::NFS_GetLineSize()+<span class="keyword">sizeof</span>(chain)-1)/<span class="keyword">sizeof</span>(chain);
00656             __TBB_ASSERT((n&amp;(n-1))==0, NULL);
00657             <span class="keywordflow">while</span>( n&lt;new_size ) n&lt;&lt;=1;
00658             chain* array = cache_aligned_allocator&lt;chain&gt;().allocate( n );
00659             <span class="comment">// storing earlier might help overcome false positives of in deducing "bool grow" in concurrent threads</span>
00660             __TBB_store_with_release(my_physical_size, n);
00661             std::memset( array, 0, n*<span class="keyword">sizeof</span>(chain) );
00662             my_array = array;
00663         }
00664     };
00665 
00666     segment&amp; get_segment( hashcode_t hashcode ) {
00667         <span class="keywordflow">return</span> my_segment[hashcode&amp;(n_segment-1)];
00668     }
00669 
00670     node_allocator_type my_allocator;
00671 
00672     HashCompare my_hash_compare;
00673 
00674     segment* my_segment;
00675 
00676     node* create_node(<span class="keyword">const</span> Key&amp; key, <span class="keyword">const</span> T* t) {
00677         <span class="comment">// exception-safe allocation and construction</span>
00678         <span class="keywordflow">if</span>(t) <span class="keywordflow">return</span> <span class="keyword">new</span>( my_allocator ) node(key, *t);
00679         <span class="keywordflow">else</span>  <span class="keywordflow">return</span> <span class="keyword">new</span>( my_allocator ) node(key);
00680     }
00681 
00682     <span class="keywordtype">void</span> delete_node(node* b) {
00683         my_allocator.destroy(b);
00684         my_allocator.deallocate(b, 1);
00685     }
00686 
00687     node* search_list( <span class="keyword">const</span> Key&amp; key, chain&amp; c )<span class="keyword"> const </span>{
00688         node* b = c.node_list;
00689         <span class="keywordflow">while</span>( b &amp;&amp; !my_hash_compare.equal(key, b-&gt;item.first) )
00690             b = b-&gt;next;
00691         <span class="keywordflow">return</span> b;
00692     }
00694     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> I&gt;
00695     std::pair&lt;I, I&gt; internal_equal_range( <span class="keyword">const</span> Key&amp; key, I end ) <span class="keyword">const</span>;
00696 
00698     <span class="keywordtype">bool</span> exclude( const_accessor&amp; item_accessor, <span class="keywordtype">bool</span> readonly );
00699 
00701     <span class="keywordtype">void</span> grow_segment( segment_mutex_t::scoped_lock&amp; segment_lock, segment&amp; s );
00702 
00704     <span class="keyword">template</span>&lt;<span class="keywordtype">bool</span> op_insert&gt;
00705     <span class="keywordtype">bool</span> lookup( const_accessor* result, <span class="keyword">const</span> Key&amp; key, <span class="keywordtype">bool</span> write, <span class="keyword">const</span> T* t );
00706 
00708     <span class="keywordtype">void</span> initialize() {
00709         my_segment = cache_aligned_allocator&lt;segment&gt;().allocate(n_segment);
00710         std::memset( my_segment, 0, <span class="keyword">sizeof</span>(segment)*n_segment );
00711      }
00712 
00714     <span class="keywordtype">void</span> internal_copy( <span class="keyword">const</span> concurrent_hash_map&amp; source );
00715 
00716     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> I&gt;
00717     <span class="keywordtype">void</span> internal_copy(I first, I last);
00718 };
00719 
00720 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Key, <span class="keyword">typename</span> T, <span class="keyword">typename</span> HashCompare, <span class="keyword">typename</span> A&gt;
<a name="l00721"></a><a class="code" href="a00196.html#a5">00721</a> <a class="code" href="a00196.html">concurrent_hash_map&lt;Key,T,HashCompare,A&gt;::~concurrent_hash_map</a>() {
00722     <a class="code" href="a00196.html#a4">clear</a>();
00723     <a class="code" href="a00193.html">cache_aligned_allocator&lt;segment&gt;</a>().deallocate( my_segment, n_segment );
00724 }
00725 
00726 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Key, <span class="keyword">typename</span> T, <span class="keyword">typename</span> HashCompare, <span class="keyword">typename</span> A&gt;
<a name="l00727"></a><a class="code" href="a00196.html#a14">00727</a> <span class="keyword">typename</span> <a class="code" href="a00196.html">concurrent_hash_map&lt;Key,T,HashCompare,A&gt;</a>::size_type <a class="code" href="a00196.html">concurrent_hash_map&lt;Key,T,HashCompare,A&gt;::size</a>()<span class="keyword"> const </span>{
00728     size_type result = 0;
00729     <span class="keywordflow">for</span>( size_t k=0; k&lt;n_segment; ++k )
00730         result += my_segment[k].my_logical_size;
00731     <span class="keywordflow">return</span> result;
00732 }
00733 
00734 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Key, <span class="keyword">typename</span> T, <span class="keyword">typename</span> HashCompare, <span class="keyword">typename</span> A&gt;
<a name="l00735"></a><a class="code" href="a00196.html#a15">00735</a> <span class="keywordtype">bool</span> <a class="code" href="a00196.html">concurrent_hash_map&lt;Key,T,HashCompare,A&gt;::empty</a>()<span class="keyword"> const </span>{
00736     <span class="keywordflow">for</span>( size_t k=0; k&lt;n_segment; ++k )
00737         <span class="keywordflow">if</span>( my_segment[k].my_logical_size )
00738             <span class="keywordflow">return</span> <span class="keyword">false</span>;
00739     <span class="keywordflow">return</span> <span class="keyword">true</span>;
00740 }
00741 
00742 <span class="preprocessor">#if _MSC_VER &amp;&amp; !defined(__INTEL_COMPILER)</span>
00743 <span class="preprocessor"></span>    <span class="comment">// Suppress "conditional expression is constant" warning.</span>
00744 <span class="preprocessor">    #pragma warning( push )</span>
00745 <span class="preprocessor"></span><span class="preprocessor">    #pragma warning( disable: 4127 )</span>
00746 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00747 <span class="preprocessor"></span>
00748 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Key, <span class="keyword">typename</span> T, <span class="keyword">typename</span> HashCompare, <span class="keyword">typename</span> A&gt;
00749 <span class="keyword">template</span>&lt;<span class="keywordtype">bool</span> op_insert&gt;
00750 <span class="keywordtype">bool</span> <a class="code" href="a00196.html">concurrent_hash_map&lt;Key,T,HashCompare,A&gt;::lookup</a>( const_accessor* result, <span class="keyword">const</span> Key&amp; key, <span class="keywordtype">bool</span> write, <span class="keyword">const</span> T* t ) {
00751     <span class="keywordflow">if</span>( result )
00752         result-&gt;release();
00753     <span class="keyword">const</span> hashcode_t h = my_hash_compare.hash( key );
00754     segment&amp; s = get_segment(h);
00755 restart:
00756     <span class="keywordtype">bool</span> return_value = <span class="keyword">false</span>;
00757     <span class="comment">// first check in double-check sequence</span>
00758 <span class="preprocessor">#if TBB_USE_THREADING_TOOLS</span>
00759 <span class="preprocessor"></span>    <span class="keywordtype">bool</span> grow = op_insert &amp;&amp; s.internal_grow_predicate();
00760 <span class="preprocessor">#else</span>
00761 <span class="preprocessor"></span>    <span class="keywordtype">bool</span> grow = op_insert &amp;&amp; s.my_logical_size &gt;= s.my_physical_size
00762         &amp;&amp; s.my_physical_size &lt; max_physical_size; <span class="comment">// check whether there are free bits</span>
00763 <span class="preprocessor">#endif </span><span class="comment">/* TBB_USE_THREADING_TOOLS */</span>
00764     segment_mutex_t::scoped_lock segment_lock( s.my_mutex, <span class="comment">/*write=*/</span>grow );
00765     <span class="keywordflow">if</span>( grow ) { <span class="comment">// Load factor is too high  </span>
00766         grow_segment( segment_lock, s );
00767     }
00768     <span class="keywordflow">if</span>( !s.my_array ) {
00769         __TBB_ASSERT( !op_insert, NULL );
00770         <span class="keywordflow">return</span> <span class="keyword">false</span>;
00771     }
00772     __TBB_ASSERT( (s.my_physical_size&amp;(s.my_physical_size-1))==0, NULL );
00773     chain&amp; c = s.get_chain( h, n_segment_bits );
00774     chain_mutex_t::scoped_lock chain_lock( c.mutex, <span class="comment">/*write=*/</span><span class="keyword">false</span> );
00775 
00776     node* b = search_list( key, c );
00777     <span class="keywordflow">if</span>( op_insert ) {
00778         <span class="keywordflow">if</span>( !b ) {
00779             b = create_node(key, t);
00780             <span class="comment">// Search failed</span>
00781             <span class="keywordflow">if</span>( !chain_lock.upgrade_to_writer() ) {
00782                 <span class="comment">// Rerun search_list, in case another thread inserted the item during the upgrade.</span>
00783                 node* b_temp = search_list( key, c );
00784                 <span class="keywordflow">if</span>( b_temp ) { <span class="comment">// unfortunately, it did</span>
00785                     chain_lock.downgrade_to_reader();
00786                     delete_node( b );
00787                     b = b_temp;
00788                     <span class="keywordflow">goto</span> done;
00789                 }
00790             }
00791             ++s.my_logical_size; <span class="comment">// we can't change it earlier due to correctness of size() and exception safety of equal()</span>
00792             return_value = <span class="keyword">true</span>;
00793             c.push_front( *b );
00794         }
00795     } <span class="keywordflow">else</span> { <span class="comment">// find or count</span>
00796         <span class="keywordflow">if</span>( !b )      <span class="keywordflow">return</span> <span class="keyword">false</span>;
00797         return_value = <span class="keyword">true</span>;
00798     }
00799 done:
00800     <span class="keywordflow">if</span>( !result ) <span class="keywordflow">return</span> return_value;
00801     <span class="keywordflow">if</span>( !result-&gt;my_lock.try_acquire( b-&gt;mutex, write ) ) {
00802         <span class="comment">// we are unlucky, prepare for longer wait</span>
00803         internal::AtomicBackoff trials;
00804         <span class="keywordflow">do</span> {
00805             <span class="keywordflow">if</span>( !trials.bounded_pause() ) {
00806                 <span class="comment">// the wait takes really long, restart the operation</span>
00807                 chain_lock.release(); segment_lock.release();
00808                 __TBB_Yield();
00809                 <span class="keywordflow">goto</span> restart;
00810             }
00811         } <span class="keywordflow">while</span>( !result-&gt;my_lock.try_acquire( b-&gt;mutex, write ) );
00812     }
00813     result-&gt;my_node = b;
00814     result-&gt;my_hash = h;
00815     <span class="keywordflow">return</span> return_value;
00816 }
00817 
00818 <span class="preprocessor">#if _MSC_VER &amp;&amp; !defined(__INTEL_COMPILER)</span>
00819 <span class="preprocessor"></span><span class="preprocessor">    #pragma warning( pop )</span>
00820 <span class="preprocessor"></span><span class="preprocessor">#endif // warning 4127 is back</span>
00821 <span class="preprocessor"></span>
00822 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Key, <span class="keyword">typename</span> T, <span class="keyword">typename</span> HashCompare, <span class="keyword">typename</span> A&gt;
00823 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> I&gt;
00824 std::pair&lt;I, I&gt; concurrent_hash_map&lt;Key,T,HashCompare,A&gt;::internal_equal_range( <span class="keyword">const</span> Key&amp; key, I end )<span class="keyword"> const </span>{
00825     <a class="code" href="a00217.html#w3">hashcode_t</a> h = my_hash_compare.hash( key );
00826     size_t segment_index = h&amp;(<a class="code" href="a00217.html#s1">n_segment</a>-1);
00827     segment&amp; s = my_segment[segment_index ];
00828     size_t chain_index = (h&gt;&gt;n_segment_bits)&amp;(s.my_physical_size-1);
00829     <span class="keywordflow">if</span>( !s.my_array )
00830         <span class="keywordflow">return</span> std::make_pair(end, end);
00831     chain&amp; c = s.my_array[chain_index];
00832     node* b = search_list( key, c );
00833     <span class="keywordflow">if</span>( !b )
00834         <span class="keywordflow">return</span> std::make_pair(end, end);
00835     iterator lower(*<span class="keyword">this</span>, segment_index, chain_index, b), upper(lower);
00836     <span class="keywordflow">return</span> std::make_pair(lower, ++upper);
00837 }
00838 
00839 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Key, <span class="keyword">typename</span> T, <span class="keyword">typename</span> HashCompare, <span class="keyword">typename</span> A&gt;
<a name="l00840"></a><a class="code" href="a00196.html#a28">00840</a> <span class="keywordtype">bool</span> <a class="code" href="a00196.html">concurrent_hash_map&lt;Key,T,HashCompare,A&gt;::erase</a>( <span class="keyword">const</span> Key &amp;key ) {
00841     hashcode_t h = my_hash_compare.hash( key );
00842     segment&amp; s = get_segment( h );
00843     node* b=NULL; <span class="comment">// explicitly initialized to prevent compiler warnings</span>
00844     {
00845         <span class="keywordtype">bool</span> chain_locked_for_write = <span class="keyword">false</span>;
00846         segment_mutex_t::scoped_lock segment_lock( s.my_mutex, <span class="comment">/*write=*/</span><span class="keyword">false</span> );
00847         <span class="keywordflow">if</span>( !s.my_array ) <span class="keywordflow">return</span> <span class="keyword">false</span>;
00848         __TBB_ASSERT( (s.my_physical_size&amp;(s.my_physical_size-1))==0, NULL );
00849         chain&amp; c = s.get_chain( h, n_segment_bits );
00850         chain_mutex_t::scoped_lock chain_lock( c.mutex, <span class="comment">/*write=*/</span><span class="keyword">false</span> );
00851     search:
00852         node** p = &amp;c.node_list;
00853         b = *p;
00854         <span class="keywordflow">while</span>( b &amp;&amp; !my_hash_compare.equal(key, b-&gt;item.first ) ) {
00855             p = &amp;b-&gt;next;
00856             b = *p;
00857         }
00858         <span class="keywordflow">if</span>( !b ) <span class="keywordflow">return</span> <span class="keyword">false</span>;
00859         <span class="keywordflow">if</span>( !chain_locked_for_write &amp;&amp; !chain_lock.upgrade_to_writer() ) {
00860             chain_locked_for_write = <span class="keyword">true</span>;
00861             <span class="keywordflow">goto</span> search;
00862         }
00863         *p = b-&gt;next;
00864         --s.my_logical_size;
00865     }
00866     {
00867         node_mutex_t::scoped_lock item_locker( b-&gt;mutex, <span class="comment">/*write=*/</span><span class="keyword">true</span> );
00868     }
00869     <span class="comment">// note: there should be no threads pretending to acquire this mutex again, do not try to upgrade const_accessor!</span>
00870     delete_node( b ); <span class="comment">// Only one thread can delete it due to write lock on the chain_mutex</span>
00871     <span class="keywordflow">return</span> <span class="keyword">true</span>;        
00872 }
00873 
00874 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Key, <span class="keyword">typename</span> T, <span class="keyword">typename</span> HashCompare, <span class="keyword">typename</span> A&gt;
00875 <span class="keywordtype">bool</span> <a class="code" href="a00196.html">concurrent_hash_map&lt;Key,T,HashCompare,A&gt;::exclude</a>( const_accessor &amp;item_accessor, <span class="keywordtype">bool</span> readonly ) {
00876     __TBB_ASSERT( item_accessor.my_node, NULL );
00877     <span class="keyword">const</span> hashcode_t h = item_accessor.my_hash;
00878     node *<span class="keyword">const</span> b = item_accessor.my_node;
00879     item_accessor.my_node = NULL; <span class="comment">// we ought release accessor anyway</span>
00880     segment&amp; s = get_segment( h );
00881     {
00882         segment_mutex_t::scoped_lock segment_lock( s.my_mutex, <span class="comment">/*write=*/</span><span class="keyword">false</span> );
00883         __TBB_ASSERT( s.my_array, NULL );
00884         __TBB_ASSERT( (s.my_physical_size&amp;(s.my_physical_size-1))==0, NULL );
00885         chain&amp; c = s.get_chain( h, n_segment_bits );
00886         chain_mutex_t::scoped_lock chain_lock( c.mutex, <span class="comment">/*write=*/</span><span class="keyword">true</span> );
00887         node** p = &amp;c.node_list;
00888         <span class="keywordflow">while</span>( *p &amp;&amp; *p != b )
00889             p = &amp;(*p)-&gt;next;
00890         <span class="keywordflow">if</span>( !*p ) { <span class="comment">// someone else was the first</span>
00891             item_accessor.my_lock.release();
00892             <span class="keywordflow">return</span> <span class="keyword">false</span>;
00893         }
00894         __TBB_ASSERT( *p == b, NULL );
00895         *p = b-&gt;next;
00896         --s.my_logical_size;
00897     }
00898     <span class="keywordflow">if</span>( readonly ) <span class="comment">// need to get exclusive lock</span>
00899         item_accessor.my_lock.upgrade_to_writer(); <span class="comment">// return value means nothing here</span>
00900     item_accessor.my_lock.release();
00901     delete_node( b ); <span class="comment">// Only one thread can delete it due to write lock on the chain_mutex</span>
00902     <span class="keywordflow">return</span> <span class="keyword">true</span>;
00903 }
00904 
00905 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Key, <span class="keyword">typename</span> T, <span class="keyword">typename</span> HashCompare, <span class="keyword">typename</span> A&gt;
<a name="l00906"></a><a class="code" href="a00196.html#a18">00906</a> <span class="keywordtype">void</span> <a class="code" href="a00196.html">concurrent_hash_map&lt;Key,T,HashCompare,A&gt;::swap</a>(<a class="code" href="a00196.html">concurrent_hash_map&lt;Key,T,HashCompare,A&gt;</a> &amp;table) {
00907     std::swap(this-&gt;my_allocator, table.<a class="code" href="a00196.html#r0">my_allocator</a>);
00908     std::swap(this-&gt;my_hash_compare, table.<a class="code" href="a00196.html#r1">my_hash_compare</a>);
00909     std::swap(this-&gt;my_segment, table.<a class="code" href="a00196.html#r2">my_segment</a>);
00910 }
00911 
00912 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Key, <span class="keyword">typename</span> T, <span class="keyword">typename</span> HashCompare, <span class="keyword">typename</span> A&gt;
<a name="l00913"></a><a class="code" href="a00196.html#a4">00913</a> <span class="keywordtype">void</span> <a class="code" href="a00196.html">concurrent_hash_map&lt;Key,T,HashCompare,A&gt;::clear</a>() {
00914 <span class="preprocessor">#if TBB_USE_PERFORMANCE_WARNINGS</span>
00915 <span class="preprocessor"></span>    size_t total_physical_size = 0, min_physical_size = size_t(-1L), max_physical_size = 0; <span class="comment">//&lt; usage statistics</span>
00916     <span class="keyword">static</span> <span class="keywordtype">bool</span> reported = <span class="keyword">false</span>;
00917 <span class="preprocessor">#endif</span>
00918 <span class="preprocessor"></span>    <span class="keywordflow">for</span>( size_t i=0; i&lt;n_segment; ++i ) {
00919         segment&amp; s = my_segment[i];
00920         size_t n = s.my_physical_size;
00921         <span class="keywordflow">if</span>( chain* array = s.my_array ) {
00922             s.my_array = NULL;
00923             s.my_physical_size = 0;
00924             s.my_logical_size = 0;
00925             <span class="keywordflow">for</span>( size_t j=0; j&lt;n; ++j ) {
00926                 <span class="keywordflow">while</span>( node* b = array[j].node_list ) {
00927                     array[j].node_list = b-&gt;next;
00928                     delete_node(b);
00929                 }
00930             }
00931             <a class="code" href="a00193.html">cache_aligned_allocator&lt;chain&gt;</a>().deallocate( array, n );
00932         }
00933 <span class="preprocessor">#if TBB_USE_PERFORMANCE_WARNINGS</span>
00934 <span class="preprocessor"></span>        total_physical_size += n;
00935         <span class="keywordflow">if</span>(min_physical_size &gt; n) min_physical_size = n;
00936         <span class="keywordflow">if</span>(max_physical_size &lt; n) max_physical_size = n;
00937     }
00938     <span class="keywordflow">if</span>( !reported
00939         &amp;&amp; ( (total_physical_size &gt;= n_segment*48 &amp;&amp; min_physical_size &lt; total_physical_size/n_segment/2)
00940          || (total_physical_size &gt;= n_segment*128 &amp;&amp; max_physical_size &gt; total_physical_size/n_segment*2) ) )
00941     {
00942         reported = <span class="keyword">true</span>;
00943         internal::runtime_warning(
00944             <span class="stringliteral">"Performance is not optimal because the hash function produces bad randomness in lower bits in %s"</span>,
00945             <span class="keyword">typeid</span>(*this).name() );
00946 <span class="preprocessor">#endif</span>
00947 <span class="preprocessor"></span>    }
00948 }
00949 
00950 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Key, <span class="keyword">typename</span> T, <span class="keyword">typename</span> HashCompare, <span class="keyword">typename</span> A&gt;
00951 <span class="keywordtype">void</span> <a class="code" href="a00196.html">concurrent_hash_map&lt;Key,T,HashCompare,A&gt;::grow_segment</a>( segment_mutex_t::scoped_lock&amp; segment_lock, segment&amp; s ) {
00952     <span class="comment">// Following is second check in a double-check.</span>
00953     <span class="keywordflow">if</span>( s.my_logical_size &gt;= s.my_physical_size ) {
00954         chain* old_array = s.my_array;
00955         size_t old_size = s.my_physical_size;
00956         s.allocate_array( s.my_logical_size+1 );
00957         <span class="keywordflow">for</span>( size_t k=0; k&lt;old_size; ++k )
00958             <span class="keywordflow">while</span>( node* b = old_array[k].node_list ) {
00959                 old_array[k].node_list = b-&gt;next;
00960                 hashcode_t h = my_hash_compare.hash( b-&gt;item.first );
00961                 __TBB_ASSERT( &amp;get_segment(h)==&amp;s, <span class="stringliteral">"hash function changed?"</span> );
00962                 s.get_chain(h,n_segment_bits).push_front(*b);
00963             }
00964         cache_aligned_allocator&lt;chain&gt;().deallocate( old_array, old_size );
00965     }
00966     segment_lock.downgrade_to_reader();
00967 }
00968 
00969 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Key, <span class="keyword">typename</span> T, <span class="keyword">typename</span> HashCompare, <span class="keyword">typename</span> A&gt;
00970 <span class="keywordtype">void</span> concurrent_hash_map&lt;Key,T,HashCompare,A&gt;::internal_copy( <span class="keyword">const</span> concurrent_hash_map&amp; source ) {
00971     <span class="keywordflow">for</span>( size_t i=0; i&lt;n_segment; ++i ) {
00972         segment&amp; s = source.my_segment[i];
00973         __TBB_ASSERT( !my_segment[i].my_array, <span class="stringliteral">"caller should have cleared"</span> );
00974         <span class="keywordflow">if</span>( s.my_logical_size ) {
00975             segment&amp; d = my_segment[i];
00976             d.allocate_array( s.my_logical_size );
00977             d.my_logical_size = s.my_logical_size;
00978             size_t s_size = s.my_physical_size;
00979             chain* s_array = s.my_array;
00980             chain* d_array = d.my_array;
00981             <span class="keywordflow">for</span>( size_t k=0; k&lt;s_size; ++k )
00982                 <span class="keywordflow">for</span>( node* b = s_array[k].node_list; b; b=b-&gt;next ) {
00983                     __TBB_ASSERT( &amp;get_segment(my_hash_compare.hash( b-&gt;item.first ))==&amp;d, <span class="stringliteral">"hash function changed?"</span> );
00984                     node* b_new = create_node(b-&gt;item.first, &amp;b-&gt;item.second);
00985                     d_array[k].push_front(*b_new); <span class="comment">// hashcode is the same and segment and my_physical sizes are the same</span>
00986                 }
00987         }
00988     }
00989 }
00990 
00991 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Key, <span class="keyword">typename</span> T, <span class="keyword">typename</span> HashCompare, <span class="keyword">typename</span> A&gt;
00992 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> I&gt;
00993 <span class="keywordtype">void</span> concurrent_hash_map&lt;Key,T,HashCompare,A&gt;::internal_copy(I first, I last) {
00994     <span class="keywordflow">for</span>(; first != last; ++first)
00995         <a class="code" href="a00196.html#a22">insert</a>( *first );
00996 }
00997 
00998 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Key, <span class="keyword">typename</span> T, <span class="keyword">typename</span> HashCompare, <span class="keyword">typename</span> A1, <span class="keyword">typename</span> A2&gt;
00999 <span class="keyword">inline</span> <span class="keywordtype">bool</span> operator==(<span class="keyword">const</span> concurrent_hash_map&lt;Key, T, HashCompare, A1&gt; &amp;a, <span class="keyword">const</span> concurrent_hash_map&lt;Key, T, HashCompare, A2&gt; &amp;b) {
01000     <span class="keywordflow">if</span>(a.size() != b.size()) <span class="keywordflow">return</span> <span class="keyword">false</span>;
01001     <span class="keyword">typename</span> concurrent_hash_map&lt;Key, T, HashCompare, A1&gt;::const_iterator i(a.begin()), i_end(a.end());
01002     <span class="keyword">typename</span> concurrent_hash_map&lt;Key, T, HashCompare, A2&gt;::const_iterator j, j_end(b.end());
01003     <span class="keywordflow">for</span>(; i != i_end; ++i) {
01004         j = b.equal_range(i-&gt;first).first;
01005         <span class="keywordflow">if</span>( j == j_end || !(i-&gt;second == j-&gt;second) ) <span class="keywordflow">return</span> <span class="keyword">false</span>;
01006     }
01007     <span class="keywordflow">return</span> <span class="keyword">true</span>;
01008 }
01009 
01010 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Key, <span class="keyword">typename</span> T, <span class="keyword">typename</span> HashCompare, <span class="keyword">typename</span> A1, <span class="keyword">typename</span> A2&gt;
01011 <span class="keyword">inline</span> <span class="keywordtype">bool</span> operator!=(<span class="keyword">const</span> concurrent_hash_map&lt;Key, T, HashCompare, A1&gt; &amp;a, <span class="keyword">const</span> concurrent_hash_map&lt;Key, T, HashCompare, A2&gt; &amp;b)
01012 {    <span class="keywordflow">return</span> !(a == b); }
01013 
01014 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Key, <span class="keyword">typename</span> T, <span class="keyword">typename</span> HashCompare, <span class="keyword">typename</span> A&gt;
01015 <span class="keyword">inline</span> <span class="keywordtype">void</span> swap(concurrent_hash_map&lt;Key, T, HashCompare, A&gt; &amp;a, concurrent_hash_map&lt;Key, T, HashCompare, A&gt; &amp;b)
01016 {    a.swap( b ); }
01017 
01018 } <span class="comment">// namespace tbb</span>
01019 
01020 <span class="preprocessor">#endif </span><span class="comment">/* __TBB_concurrent_hash_map_H */</span>
</pre></div><hr>
<p></p>
Copyright &copy; 2005-2008 Intel Corporation.  All Rights Reserved.
<p></p>
Intel, Pentium, Intel Xeon, Itanium, Intel XScale and VTune are
registered trademarks or trademarks of Intel Corporation or its
subsidiaries in the United States and other countries.
<p></p>
* Other names and brands may be claimed as the property of others.
