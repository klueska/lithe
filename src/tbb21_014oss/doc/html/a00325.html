<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>parallel_do.h Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.9.1 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="modules.html">Modules</a> | <a class="qindex" href="namespaces.html">Namespace List</a> | <a class="qindex" href="hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="annotated.html">Class&nbsp;List</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="namespacemembers.html">Namespace&nbsp;Members</a> | <a class="qindex" href="functions.html">Class&nbsp;Members</a> | <a class="qindex" href="globals.html">File&nbsp;Members</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a></div>
<h1>parallel_do.h</h1><div class="fragment"><pre class="fragment">00001 <span class="comment">/*</span>
00002 <span class="comment">    Copyright 2005-2008 Intel Corporation.  All Rights Reserved.</span>
00003 <span class="comment"></span>
00004 <span class="comment">    The source code contained or described herein and all documents related</span>
00005 <span class="comment">    to the source code ("Material") are owned by Intel Corporation or its</span>
00006 <span class="comment">    suppliers or licensors.  Title to the Material remains with Intel</span>
00007 <span class="comment">    Corporation or its suppliers and licensors.  The Material is protected</span>
00008 <span class="comment">    by worldwide copyright laws and treaty provisions.  No part of the</span>
00009 <span class="comment">    Material may be used, copied, reproduced, modified, published, uploaded,</span>
00010 <span class="comment">    posted, transmitted, distributed, or disclosed in any way without</span>
00011 <span class="comment">    Intel's prior express written permission.</span>
00012 <span class="comment"></span>
00013 <span class="comment">    No license under any patent, copyright, trade secret or other</span>
00014 <span class="comment">    intellectual property right is granted to or conferred upon you by</span>
00015 <span class="comment">    disclosure or delivery of the Materials, either expressly, by</span>
00016 <span class="comment">    implication, inducement, estoppel or otherwise.  Any license under such</span>
00017 <span class="comment">    intellectual property rights must be express and approved by Intel in</span>
00018 <span class="comment">    writing.</span>
00019 <span class="comment">*/</span>
00020 
00021 <span class="preprocessor">#ifndef __TBB_parallel_do_H</span>
00022 <span class="preprocessor"></span><span class="preprocessor">#define __TBB_parallel_do_H</span>
00023 <span class="preprocessor"></span>
00024 <span class="preprocessor">#include "task.h"</span>
00025 <span class="preprocessor">#include "aligned_space.h"</span>
00026 <span class="preprocessor">#include &lt;iterator&gt;</span>
00027 
00028 <span class="keyword">namespace </span>tbb {
00029 
00031 <span class="keyword">namespace </span>internal {
00032     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Body, <span class="keyword">typename</span> Item&gt; <span class="keyword">class </span>parallel_do_feeder_impl;
00033     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Body&gt; <span class="keyword">class </span>do_group_task;
00034 
00036     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;
<a name="l00037"></a><a class="code" href="a00253.html">00037</a>     <span class="keyword">struct </span><a class="code" href="a00253.html">strip</a> { <span class="keyword">typedef</span> T type; };
00038     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;
00039     <span class="keyword">struct </span><a class="code" href="a00253.html">strip</a>&lt;T&amp;&gt; { <span class="keyword">typedef</span> T type; };
00040     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;
00041     <span class="keyword">struct </span>strip&lt;const T&amp;&gt; { <span class="keyword">typedef</span> T type; };
00042     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;
00043     <span class="keyword">struct </span>strip&lt;volatile T&amp;&gt; { <span class="keyword">typedef</span> T type; };
00044     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;
00045     <span class="keyword">struct </span>strip&lt;const volatile T&amp;&gt; { <span class="keyword">typedef</span> T type; };
00046     <span class="comment">// Most of the compilers remove cv-qualifiers from non-reference function argument types. </span>
00047     <span class="comment">// But unfortunately there are those that don't.</span>
00048     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;
00049     <span class="keyword">struct </span>strip&lt;const T&gt; { <span class="keyword">typedef</span> T type; };
00050     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;
00051     <span class="keyword">struct </span>strip&lt;volatile T&gt; { <span class="keyword">typedef</span> T type; };
00052     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;
00053     <span class="keyword">struct </span>strip&lt;const volatile T&gt; { <span class="keyword">typedef</span> T type; };
00054 } <span class="comment">// namespace internal</span>
00056 <span class="comment"></span>
00058 
00059 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Item&gt;
<a name="l00060"></a><a class="code" href="a00226.html">00060</a> <span class="keyword">class </span><a class="code" href="a00226.html">parallel_do_feeder</a>: internal::no_copy
00061 {
00062     <a class="code" href="a00226.html">parallel_do_feeder</a>() {}
00063     <span class="keyword">virtual</span> ~<a class="code" href="a00226.html">parallel_do_feeder</a> () {}
00064     <span class="keyword">virtual</span> <span class="keywordtype">void</span> internal_add( <span class="keyword">const</span> Item&amp; item ) = 0;
00065     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Body_, <span class="keyword">typename</span> Item_&gt; <span class="keyword">friend</span> <span class="keyword">class </span><a class="code" href="a00227.html">internal::parallel_do_feeder_impl</a>;
00066 <span class="keyword">public</span>:
<a name="l00068"></a><a class="code" href="a00226.html#a0">00068</a>     <span class="keywordtype">void</span> add( <span class="keyword">const</span> Item&amp; item ) {internal_add(item);}
00069 };
00070 
00072 <span class="keyword">namespace </span>internal {
00074 
00076     <span class="keyword">template</span>&lt;<span class="keyword">class</span> Body, <span class="keyword">typename</span> Item&gt;
<a name="l00077"></a><a class="code" href="a00228.html">00077</a>     <span class="keyword">class </span><a class="code" href="a00228.html">parallel_do_operator_selector</a>
00078     {
00079         <span class="keyword">typedef</span> <a class="code" href="a00226.html">parallel_do_feeder&lt;Item&gt;</a> <a class="code" href="a00226.html">Feeder</a>;
00080         <span class="keyword">template</span>&lt;<span class="keyword">typename</span> A1, <span class="keyword">typename</span> A2, <span class="keyword">typename</span> CvItem &gt;
00081         <span class="keyword">static</span> <span class="keywordtype">void</span> internal_call( <span class="keyword">const</span> Body&amp; obj, A1&amp; arg1, A2&amp;, <span class="keywordtype">void</span> (Body::*)(CvItem) <span class="keyword">const</span> ) {
00082             obj(arg1);
00083         }
00084         <span class="keyword">template</span>&lt;<span class="keyword">typename</span> A1, <span class="keyword">typename</span> A2, <span class="keyword">typename</span> CvItem &gt;
00085         <span class="keyword">static</span> <span class="keywordtype">void</span> internal_call( <span class="keyword">const</span> Body&amp; obj, A1&amp; arg1, A2&amp; arg2, <span class="keywordtype">void</span> (Body::*)(CvItem, <a class="code" href="a00226.html">parallel_do_feeder&lt;Item&gt;</a>&amp;) <span class="keyword">const</span> ) {
00086             obj(arg1, arg2);
00087         }
00088 
00089     <span class="keyword">public</span>:
00090         <span class="keyword">template</span>&lt;<span class="keyword">typename</span> A1, <span class="keyword">typename</span> A2 &gt;
00091         <span class="keyword">static</span> <span class="keywordtype">void</span> call( <span class="keyword">const</span> Body&amp; obj, A1&amp; arg1, A2&amp; arg2 )
00092         {
00093             internal_call( obj, arg1, arg2, &amp;Body::operator() );
00094         }
00095     };
00096 
00098 
00100     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Body, <span class="keyword">typename</span> Item&gt;
<a name="l00101"></a><a class="code" href="a00208.html">00101</a>     <span class="keyword">class </span><a class="code" href="a00208.html">do_iteration_task</a>: <span class="keyword">public</span> <a class="code" href="a00255.html">task</a>
00102     {
00103         <span class="keyword">typedef</span> <a class="code" href="a00227.html">parallel_do_feeder_impl&lt;Body, Item&gt;</a> <a class="code" href="a00227.html">feeder_type</a>;
00104 
00105         Item my_value;
00106         <a class="code" href="a00227.html">feeder_type</a>&amp; my_feeder;
00107 
00108         <a class="code" href="a00208.html">do_iteration_task</a>( <span class="keyword">const</span> Item&amp; value, <a class="code" href="a00227.html">feeder_type</a>&amp; feeder ) : 
00109             my_value(value), my_feeder(feeder)
00110         {}
00111 
00112         <span class="comment">/*override*/</span> 
00113         <a class="code" href="a00255.html">task</a>* execute()
00114         {
00115             <a class="code" href="a00228.html">parallel_do_operator_selector&lt;Body, Item&gt;::call</a>(*my_feeder.my_body, my_value, my_feeder);
00116             <span class="keywordflow">return</span> NULL;
00117         }
00118 
00119         <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Body_, <span class="keyword">typename</span> Item_&gt; <span class="keyword">friend</span> <span class="keyword">class </span><a class="code" href="a00227.html">parallel_do_feeder_impl</a>;
00120     }; <span class="comment">// class do_iteration_task</span>
00121 
00122     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Iterator, <span class="keyword">typename</span> Body, <span class="keyword">typename</span> Item&gt;
00123     <span class="keyword">class </span>do_iteration_task_iter: <span class="keyword">public</span> <a class="code" href="a00255.html">task</a>
00124     {
00125         <span class="keyword">typedef</span> <a class="code" href="a00227.html">parallel_do_feeder_impl&lt;Body, Item&gt;</a> feeder_type;
00126 
00127         Iterator my_iter;
00128         feeder_type&amp; my_feeder;
00129 
00130         do_iteration_task_iter( <span class="keyword">const</span> Iterator&amp; iter, feeder_type&amp; feeder ) : 
00131             my_iter(iter), my_feeder(feeder)
00132         {}
00133 
00134         <span class="comment">/*override*/</span> 
00135         <a class="code" href="a00255.html">task</a>* <a class="code" href="a00255.html#a1">execute</a>()
00136         {
00137             parallel_do_operator_selector&lt;Body, Item&gt;::call(*my_feeder.my_body, *my_iter, my_feeder);
00138             <span class="keywordflow">return</span> NULL;
00139         }
00140 
00141         <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Iterator_, <span class="keyword">typename</span> Body_, <span class="keyword">typename</span> Item_&gt; <span class="keyword">friend</span> <span class="keyword">class </span>do_group_task_forward;    
00142         <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Body_, <span class="keyword">typename</span> Item_&gt; <span class="keyword">friend</span> <span class="keyword">class </span>do_group_task_input;    
00143         <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Iterator_, <span class="keyword">typename</span> Body_, <span class="keyword">typename</span> Item_&gt; <span class="keyword">friend</span> <span class="keyword">class </span>do_task_iter;    
00144     }; <span class="comment">// class do_iteration_task_iter</span>
00145 
00147 
00149     <span class="keyword">template</span>&lt;<span class="keyword">class</span> Body, <span class="keyword">typename</span> Item&gt;
<a name="l00150"></a><a class="code" href="a00227.html">00150</a>     <span class="keyword">class </span><a class="code" href="a00227.html">parallel_do_feeder_impl</a> : <span class="keyword">public</span> <a class="code" href="a00226.html">parallel_do_feeder</a>&lt;Item&gt;
00151     {
00152         <span class="comment">/*override*/</span> 
00153         <span class="keywordtype">void</span> internal_add( <span class="keyword">const</span> Item&amp; item )
00154         {
00155             <span class="keyword">typedef</span> <a class="code" href="a00208.html">do_iteration_task&lt;Body, Item&gt;</a> iteration_type;
00156 
00157             iteration_type&amp; t = *<span class="keyword">new</span> (task::self().allocate_additional_child_of(*my_barrier)) iteration_type(item, *<span class="keyword">this</span>);
00158 
00159             t.<a class="code" href="a00255.html#a14">spawn</a>( t );
00160         }
00161     <span class="keyword">public</span>:
00162         <span class="keyword">const</span> Body* my_body;
00163         <a class="code" href="a00210.html">empty_task</a>* my_barrier;
00164 
00165         <a class="code" href="a00227.html">parallel_do_feeder_impl</a>()
00166         {
00167             my_barrier = <span class="keyword">new</span>( task::allocate_root() ) <a class="code" href="a00210.html">empty_task</a>();
00168             __TBB_ASSERT(my_barrier, <span class="stringliteral">"root task allocation failed"</span>);
00169         }
00170 
00171 <span class="preprocessor">#if __TBB_EXCEPTIONS</span>
00172 <span class="preprocessor"></span>        <a class="code" href="a00227.html">parallel_do_feeder_impl</a>(<a class="code" href="a00256.html">tbb::task_group_context</a> &amp;context)
00173         {
00174             my_barrier = <span class="keyword">new</span>( task::allocate_root(context) ) <a class="code" href="a00210.html">empty_task</a>();
00175             __TBB_ASSERT(my_barrier, <span class="stringliteral">"root task allocation failed"</span>);
00176         }
00177 <span class="preprocessor">#endif</span>
00178 <span class="preprocessor"></span>
00179         ~<a class="code" href="a00227.html">parallel_do_feeder_impl</a>()
00180         {
00181             my_barrier-&gt;<a class="code" href="a00255.html#a5">destroy</a>(*my_barrier);
00182         }
00183     }; <span class="comment">// class parallel_do_feeder_impl</span>
00184 
00185 
00187 
00190     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Iterator, <span class="keyword">typename</span> Body, <span class="keyword">typename</span> Item&gt;
<a name="l00191"></a><a class="code" href="a00207.html">00191</a>     <span class="keyword">class </span><a class="code" href="a00207.html">do_group_task_forward</a>: <span class="keyword">public</span> <a class="code" href="a00255.html">task</a>
00192     {
00193         <span class="keyword">static</span> <span class="keyword">const</span> size_t max_arg_size = 4;         
00194 
00195         <span class="keyword">typedef</span> <a class="code" href="a00227.html">parallel_do_feeder_impl&lt;Body, Item&gt;</a> <a class="code" href="a00227.html">feeder_type</a>;
00196 
00197         <a class="code" href="a00227.html">feeder_type</a>&amp; my_feeder;
00198         Iterator my_first;
00199         size_t my_size;
00200         
00201         <a class="code" href="a00207.html">do_group_task_forward</a>( Iterator first, size_t size, <a class="code" href="a00227.html">feeder_type</a>&amp; feeder ) 
00202             : my_feeder(feeder), my_first(first), my_size(size)
00203         {}
00204 
00205         <span class="comment">/*override*/</span> <a class="code" href="a00255.html">task</a>* execute()
00206         {
00207             <span class="keyword">typedef</span> do_iteration_task_iter&lt;Iterator, Body, Item&gt; iteration_type;
00208             __TBB_ASSERT( my_size&gt;0, NULL );
00209             <a class="code" href="a00257.html">task_list</a> list;
00210             <a class="code" href="a00255.html">task</a>* t; 
00211             size_t k=0; 
00212             <span class="keywordflow">for</span>(;;) {
00213                 t = <span class="keyword">new</span>( allocate_child() ) iteration_type( my_first, my_feeder );
00214                 ++my_first;
00215                 <span class="keywordflow">if</span>( ++k==my_size ) <span class="keywordflow">break</span>;
00216                 list.<a class="code" href="a00257.html#a3">push_back</a>(*t);
00217             }
00218             set_ref_count(<span class="keywordtype">int</span>(k+1));
00219             spawn(list);
00220             spawn_and_wait_for_all(*t);
00221             <span class="keywordflow">return</span> NULL;
00222         }
00223 
00224         <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Iterator_, <span class="keyword">typename</span> Body_, <span class="keyword">typename</span> _Item&gt; <span class="keyword">friend</span> <span class="keyword">class </span><a class="code" href="a00209.html">do_task_iter</a>;
00225     }; <span class="comment">// class do_group_task_forward</span>
00226 
00227     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Body, <span class="keyword">typename</span> Item&gt;
00228     <span class="keyword">class </span>do_group_task_input: <span class="keyword">public</span> <a class="code" href="a00255.html">task</a>
00229     {
00230         <span class="keyword">static</span> <span class="keyword">const</span> size_t max_arg_size = 4;         
00231         
00232         <span class="keyword">typedef</span> <a class="code" href="a00227.html">parallel_do_feeder_impl&lt;Body, Item&gt;</a> feeder_type;
00233 
00234         feeder_type&amp; my_feeder;
00235         size_t my_size;
00236         <a class="code" href="a00185.html">aligned_space&lt;Item, max_arg_size&gt;</a> my_arg;
00237 
00238         do_group_task_input( feeder_type&amp; feeder ) 
00239             : my_feeder(feeder), my_size(0)
00240         {}
00241 
00242         <span class="comment">/*override*/</span> <a class="code" href="a00255.html">task</a>* <a class="code" href="a00255.html#a1">execute</a>()
00243         {
00244             <span class="keyword">typedef</span> do_iteration_task_iter&lt;Item*, Body, Item&gt; iteration_type;
00245             __TBB_ASSERT( my_size&gt;0, NULL );
00246             <a class="code" href="a00257.html">task_list</a> list;
00247             <a class="code" href="a00255.html">task</a>* t; 
00248             size_t k=0; 
00249             <span class="keywordflow">for</span>(;;) {
00250                 t = <span class="keyword">new</span>( <a class="code" href="a00255.html#a3">allocate_child</a>() ) iteration_type( my_arg.begin() + k, my_feeder );
00251                 <span class="keywordflow">if</span>( ++k==my_size ) <span class="keywordflow">break</span>;
00252                 list.<a class="code" href="a00257.html#a3">push_back</a>(*t);
00253             }
00254             <a class="code" href="a00255.html#a13">set_ref_count</a>(<span class="keywordtype">int</span>(k+1));
00255             <a class="code" href="a00255.html#a14">spawn</a>(list);
00256             <a class="code" href="a00255.html#a16">spawn_and_wait_for_all</a>(*t);
00257             <span class="keywordflow">return</span> NULL;
00258         }
00259 
00260         ~do_group_task_input(){
00261             <span class="keywordflow">for</span>( size_t k=0; k&lt;my_size; ++k)
00262                 (my_arg.begin() + k)-&gt;~Item();
00263         }
00264 
00265         <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Iterator_, <span class="keyword">typename</span> Body_, <span class="keyword">typename</span> Item_&gt; <span class="keyword">friend</span> <span class="keyword">class </span>do_task_iter;
00266     }; <span class="comment">// class do_group_task_input</span>
00267     
00269 
00271     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Iterator, <span class="keyword">typename</span> Body, <span class="keyword">typename</span> Item&gt;
<a name="l00272"></a><a class="code" href="a00209.html">00272</a>     <span class="keyword">class </span><a class="code" href="a00209.html">do_task_iter</a>: <span class="keyword">public</span> <a class="code" href="a00255.html">task</a>
00273     {
00274         <span class="comment">//typedef typename std::iterator_traits&lt;Iterator&gt;::value_type Item;</span>
00275         <span class="keyword">typedef</span> <a class="code" href="a00227.html">parallel_do_feeder_impl&lt;Body, Item&gt;</a> <a class="code" href="a00227.html">feeder_type</a>;
00276 
00277     <span class="keyword">public</span>:
00278         <a class="code" href="a00209.html">do_task_iter</a>( Iterator first, Iterator last , <a class="code" href="a00227.html">feeder_type</a>&amp; feeder ) : 
00279             my_first(first), my_last(last), my_feeder(feeder)
00280         {}
00281 
00282     <span class="keyword">private</span>:
00283         Iterator my_first;
00284         Iterator my_last;
00285         <a class="code" href="a00227.html">feeder_type</a>&amp; my_feeder;
00286 
00287         <span class="comment">/* Do not merge run(xxx) and run_xxx() methods. They are separated in order</span>
00288 <span class="comment">            to make sure that compilers will eliminate unused argument of type xxx</span>
00289 <span class="comment">            (that is will not put it on stack). The sole purpose of this argument </span>
00290 <span class="comment">            is overload resolution.</span>
00291 <span class="comment">            </span>
00292 <span class="comment">            An alternative could be using template functions, but explicit specialization </span>
00293 <span class="comment">            of member function templates is not supported for non specialized class </span>
00294 <span class="comment">            templates. Besides template functions would always fall back to the least </span>
00295 <span class="comment">            efficient variant (the one for input iterators) in case of iterators having </span>
00296 <span class="comment">            custom tags derived from basic ones. */</span>
00297         <span class="comment">/*override*/</span> <a class="code" href="a00255.html">task</a>* execute()
00298         {
00299             <span class="keyword">typedef</span> <span class="keyword">typename</span> std::iterator_traits&lt;Iterator&gt;::iterator_category iterator_tag;
00300             <span class="keywordflow">return</span> run( (iterator_tag*)NULL );
00301         }
00302 
00305         <span class="keyword">inline</span> <a class="code" href="a00255.html">task</a>* run( <span class="keywordtype">void</span>* ) { <span class="keywordflow">return</span> run_for_input_iterator(); }
00306         
00307         <a class="code" href="a00255.html">task</a>* run_for_input_iterator() {
00308             <span class="keyword">typedef</span> do_group_task_input&lt;Body, Item&gt; block_type;
00309 
00310             block_type&amp; t = *<span class="keyword">new</span>( allocate_additional_child_of(*my_feeder.my_barrier) ) block_type(my_feeder);
00311             size_t k=0; 
00312             <span class="keywordflow">while</span>( !(my_first == my_last) ) {
00313                 <span class="keyword">new</span> (t.my_arg.begin() + k) Item(*my_first);
00314                 ++my_first;
00315                 <span class="keywordflow">if</span>( ++k==block_type::max_arg_size ) {
00316                     <span class="keywordflow">if</span> ( !(my_first == my_last) )
00317                         recycle_to_reexecute();
00318                     <span class="keywordflow">break</span>;
00319                 }
00320             }
00321             <span class="keywordflow">if</span>( k==0 ) {
00322                 destroy(t);
00323                 <span class="keywordflow">return</span> NULL;
00324             } <span class="keywordflow">else</span> {
00325                 t.my_size = k;
00326                 <span class="keywordflow">return</span> &amp;t;
00327             }
00328         }
00329 
00330         <span class="keyword">inline</span> <a class="code" href="a00255.html">task</a>* run( std::forward_iterator_tag* ) { <span class="keywordflow">return</span> run_for_forward_iterator(); }
00331 
00332         <a class="code" href="a00255.html">task</a>* run_for_forward_iterator() {
00333             <span class="keyword">typedef</span> <a class="code" href="a00207.html">do_group_task_forward&lt;Iterator, Body, Item&gt;</a> block_type;
00334 
00335             Iterator first = my_first;
00336             size_t k=0; 
00337             <span class="keywordflow">while</span>( !(my_first==my_last) ) {
00338                 ++my_first;
00339                 <span class="keywordflow">if</span>( ++k==block_type::max_arg_size ) {
00340                     <span class="keywordflow">if</span> ( !(my_first==my_last) )
00341                         recycle_to_reexecute();
00342                     <span class="keywordflow">break</span>;
00343                 }
00344             }
00345             <span class="keywordflow">return</span> k==0 ? NULL : <span class="keyword">new</span>( allocate_additional_child_of(*my_feeder.my_barrier) ) block_type(first, k, my_feeder);
00346         }
00347         
00348         <span class="keyword">inline</span> <a class="code" href="a00255.html">task</a>* run( std::random_access_iterator_tag* ) { <span class="keywordflow">return</span> run_for_random_access_iterator(); }
00349 
00350         <a class="code" href="a00255.html">task</a>* run_for_random_access_iterator() {
00351             <span class="keyword">typedef</span> <a class="code" href="a00207.html">do_group_task_forward&lt;Iterator, Body, Item&gt;</a> block_type;
00352             <span class="keyword">typedef</span> do_iteration_task_iter&lt;Iterator, Body, Item&gt; iteration_type;
00353             
00354             size_t k = static_cast&lt;size_t&gt;(my_last-my_first); 
00355             <span class="keywordflow">if</span>( k &gt; block_type::max_arg_size ) {
00356                 Iterator middle = my_first + k/2;
00357 
00358                 <a class="code" href="a00210.html">empty_task</a>&amp; c = *<span class="keyword">new</span>( allocate_continuation() ) <a class="code" href="a00210.html">empty_task</a>;
00359                 <a class="code" href="a00209.html">do_task_iter</a>&amp; b = *<span class="keyword">new</span>( c.<a class="code" href="a00255.html#a3">allocate_child</a>() ) <a class="code" href="a00209.html">do_task_iter</a>(middle, my_last, my_feeder);
00360                 recycle_as_child_of(c);
00361 
00362                 my_last = middle;
00363                 c.<a class="code" href="a00255.html#a13">set_ref_count</a>(2);
00364                 c.<a class="code" href="a00255.html#a14">spawn</a>(b);
00365                 <span class="keywordflow">return</span> <span class="keyword">this</span>;
00366             }<span class="keywordflow">else</span> <span class="keywordflow">if</span>( k != 0 ) {
00367                 <a class="code" href="a00257.html">task_list</a> list;
00368                 <a class="code" href="a00255.html">task</a>* t; 
00369                 size_t k1=0; 
00370                 <span class="keywordflow">for</span>(;;) {
00371                     t = <span class="keyword">new</span>( allocate_child() ) iteration_type(my_first, my_feeder);
00372                     ++my_first;
00373                     <span class="keywordflow">if</span>( ++k1==k ) <span class="keywordflow">break</span>;
00374                     list.<a class="code" href="a00257.html#a3">push_back</a>(*t);
00375                 }
00376                 set_ref_count(<span class="keywordtype">int</span>(k+1));
00377                 spawn(list);
00378                 spawn_and_wait_for_all(*t);
00379             }
00380             <span class="keywordflow">return</span> NULL;
00381         }
00382     }; <span class="comment">// class do_task_iter</span>
00383 
00385 
00387     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Iterator, <span class="keyword">typename</span> Body, <span class="keyword">typename</span> Item&gt; 
<a name="l00388"></a><a class="code" href="a00313.html#ga0">00388</a>     <span class="keywordtype">void</span> <a class="code" href="a00313.html#ga0">run_parallel_do</a>( Iterator first, Iterator last, <span class="keyword">const</span> Body&amp; body
00389 #<span class="keywordflow">if</span> __TBB_EXCEPTIONS
00390         , task_group_context&amp; context
00391 #endif
00392         )
00393     {
00394         <span class="keyword">typedef</span> do_task_iter&lt;Iterator, Body, Item&gt; root_iteration_task;
00395 <span class="preprocessor">#if __TBB_EXCEPTIONS</span>
00396 <span class="preprocessor"></span>        parallel_do_feeder_impl&lt;Body, Item&gt; feeder(context);
00397 <span class="preprocessor">#else</span>
00398 <span class="preprocessor"></span>        parallel_do_feeder_impl&lt;Body, Item&gt; feeder;
00399 <span class="preprocessor">#endif</span>
00400 <span class="preprocessor"></span>        feeder.my_body = &amp;body;
00401 
00402         root_iteration_task &amp;t = *<span class="keyword">new</span>( feeder.my_barrier-&gt;allocate_child() ) root_iteration_task(first, last, feeder);
00403 
00404         feeder.my_barrier-&gt;set_ref_count(2);
00405         feeder.my_barrier-&gt;spawn_and_wait_for_all(t);
00406     }
00407 
00409 
00411     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Iterator, <span class="keyword">typename</span> Body, <span class="keyword">typename</span> Item&gt; 
<a name="l00412"></a><a class="code" href="a00313.html#ga1">00412</a>     <span class="keywordtype">void</span> <a class="code" href="a00313.html#ga2">select_parallel_do</a>( Iterator first, Iterator last, <span class="keyword">const</span> Body&amp; body, <span class="keywordtype">void</span> (Body::*)(Item) <span class="keyword">const</span>
00413 #<span class="keywordflow">if</span> __TBB_EXCEPTIONS
00414         , task_group_context&amp; context 
00415 #endif <span class="comment">// __TBB_EXCEPTIONS </span>
00416         )
00417     {
00418         run_parallel_do&lt;Iterator, Body, typename strip&lt;Item&gt;::type&gt;( first, last, body
00419 <span class="preprocessor">#if __TBB_EXCEPTIONS</span>
00420 <span class="preprocessor"></span>            , context
00421 <span class="preprocessor">#endif // __TBB_EXCEPTIONS </span>
00422 <span class="preprocessor"></span>            );
00423     }
00424 
00426 
00428     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Iterator, <span class="keyword">typename</span> Body, <span class="keyword">typename</span> Item, <span class="keyword">typename</span> _Item&gt; 
<a name="l00429"></a><a class="code" href="a00313.html#ga2">00429</a>     <span class="keywordtype">void</span> <a class="code" href="a00313.html#ga2">select_parallel_do</a>( Iterator first, Iterator last, <span class="keyword">const</span> Body&amp; body, <span class="keywordtype">void</span> (Body::*)(Item, parallel_do_feeder&lt;_Item&gt;&amp;) <span class="keyword">const</span>
00430 #<span class="keywordflow">if</span> __TBB_EXCEPTIONS
00431         , task_group_context&amp; context 
00432 #endif <span class="comment">// __TBB_EXCEPTIONS</span>
00433         )
00434     {
00435         run_parallel_do&lt;Iterator, Body, typename strip&lt;Item&gt;::type&gt;( first, last, body
00436 <span class="preprocessor">#if __TBB_EXCEPTIONS</span>
00437 <span class="preprocessor"></span>            , context
00438 <span class="preprocessor">#endif // __TBB_EXCEPTIONS</span>
00439 <span class="preprocessor"></span>            );
00440     }
00441 
00442 } <span class="comment">// namespace internal</span>
00444 <span class="comment"></span>
00445 
00468 
00469 
00470 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Iterator, <span class="keyword">typename</span> Body&gt; 
<a name="l00471"></a><a class="code" href="a00313.html#ga3">00471</a> <span class="keywordtype">void</span> <a class="code" href="a00313.html#ga4">parallel_do</a>( Iterator first, Iterator last, <span class="keyword">const</span> Body&amp; body )
00472 {
00473     <span class="keywordflow">if</span> ( first == last )
00474         <span class="keywordflow">return</span>;
00475 <span class="preprocessor">#if __TBB_EXCEPTIONS</span>
00476 <span class="preprocessor"></span>    task_group_context context;
00477 <span class="preprocessor">#endif // __TBB_EXCEPTIONS</span>
00478 <span class="preprocessor"></span>    <a class="code" href="a00313.html#ga2">internal::select_parallel_do</a>( first, last, body, &amp;Body::operator()
00479 #<span class="keywordflow">if</span> __TBB_EXCEPTIONS
00480         , context
00481 #endif <span class="comment">// __TBB_EXCEPTIONS</span>
00482         );
00483 }
00484 
00485 <span class="preprocessor">#if __TBB_EXCEPTIONS</span>
00486 <span class="preprocessor"></span>
00487 
00488 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Iterator, <span class="keyword">typename</span> Body&gt; 
<a name="l00489"></a><a class="code" href="a00313.html#ga4">00489</a> <span class="keywordtype">void</span> <a class="code" href="a00313.html#ga4">parallel_do</a>( Iterator first, Iterator last, <span class="keyword">const</span> Body&amp; body, task_group_context&amp; context  )
00490 {
00491     <span class="keywordflow">if</span> ( first == last )
00492         <span class="keywordflow">return</span>;
00493     <a class="code" href="a00313.html#ga2">internal::select_parallel_do</a>( first, last, body, &amp;Body::operator(), context );
00494 }
00495 <span class="preprocessor">#endif // __TBB_EXCEPTIONS</span>
00496 <span class="preprocessor"></span>
00498 
00499 } <span class="comment">// namespace </span>
00500 
00501 <span class="preprocessor">#endif </span><span class="comment">/* __TBB_parallel_do_H */</span>
</pre></div><hr>
<p></p>
Copyright &copy; 2005-2008 Intel Corporation.  All Rights Reserved.
<p></p>
Intel, Pentium, Intel Xeon, Itanium, Intel XScale and VTune are
registered trademarks or trademarks of Intel Corporation or its
subsidiaries in the United States and other countries.
<p></p>
* Other names and brands may be claimed as the property of others.
