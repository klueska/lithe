<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>tbb::internal Namespace Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.9.1 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="modules.html">Modules</a> | <a class="qindex" href="namespaces.html">Namespace List</a> | <a class="qindex" href="hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="annotated.html">Class&nbsp;List</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="namespacemembers.html">Namespace&nbsp;Members</a> | <a class="qindex" href="functions.html">Class&nbsp;Members</a> | <a class="qindex" href="globals.html">File&nbsp;Members</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a></div>
<h1>tbb::internal Namespace Reference</h1>INTERNAL  
<a href="#_details">More...</a>
<p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Classes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><b>tbb::internal::atomic_traits&lt; Size, M &gt;</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><b>tbb::internal::atomic_word&lt; Size &gt;</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><b>tbb::internal::atomic_base&lt; I &gt;</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><b>tbb::internal::atomic_word&lt; 8 &gt;</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><b>tbb::internal::atomic_word&lt; 1 &gt;</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><b>tbb::internal::atomic_word&lt; 2 &gt;</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><b>tbb::internal::atomic_word&lt; 4 &gt;</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><b>tbb::internal::atomic_base&lt; uint64_t &gt;</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><b>tbb::internal::atomic_base&lt; int64_t &gt;</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><b>tbb::internal::atomic_impl</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00217.html">tbb::internal::hash_map_base</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">base class of <a class="el" href="a00196.html">concurrent_hash_map</a>  <a href="a00217.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><b>tbb::internal::hash_map_segment_base</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00218.html">tbb::internal::hash_map_iterator&lt; Container, Value &gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Meets requirements of a forward iterator for STL */.  <a href="a00218.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00219.html">tbb::internal::hash_map_range&lt; Iterator &gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Range class used with <a class="el" href="a00196.html">concurrent_hash_map</a>.  <a href="a00219.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00200.html">tbb::internal::concurrent_queue_base_v3</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">For internal use only.  <a href="a00200.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00201.html">tbb::internal::concurrent_queue_base_v3::page</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Prefix on a page.  <a href="a00201.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00203.html">tbb::internal::concurrent_queue_iterator_base_v3</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Type-independent portion of <a class="el" href="a00202.html">concurrent_queue_iterator</a>.  <a href="a00203.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00202.html">tbb::internal::concurrent_queue_iterator&lt; Container, Value &gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Meets requirements of a forward iterator for STL.  <a href="a00202.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00205.html">tbb::internal::concurrent_vector_base_v3</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Base class of concurrent vector implementation.  <a href="a00205.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><b>tbb::internal::concurrent_vector_base_v3::segment_t</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00206.html">tbb::internal::concurrent_vector_base_v3::internal_segments_table</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Internal structure for compact().  <a href="a00206.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00268.html">tbb::internal::vector_iterator&lt; Container, Value &gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Meets requirements of a forward iterator for STL and a Value for a <a class="el" href="a00190.html">blocked_range</a>.*/.  <a href="a00268.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><b>tbb::internal::allocator_base&lt; T, A &gt;</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00253.html">tbb::internal::strip&lt; T &gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Strips its template type argument from 'cv' and '&amp;' qualifiers.  <a href="a00253.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><b>tbb::internal::strip&lt; T &amp; &gt;</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><b>tbb::internal::strip&lt; const T &amp; &gt;</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><b>tbb::internal::strip&lt; volatile T &amp; &gt;</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><b>tbb::internal::strip&lt; const volatile T &amp; &gt;</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><b>tbb::internal::strip&lt; const T &gt;</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><b>tbb::internal::strip&lt; volatile T &gt;</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><b>tbb::internal::strip&lt; const volatile T &gt;</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00228.html">tbb::internal::parallel_do_operator_selector&lt; Body, Item &gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">For internal use only.  <a href="a00228.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00208.html">tbb::internal::do_iteration_task&lt; Body, Item &gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">For internal use only.  <a href="a00208.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><b>tbb::internal::do_iteration_task_iter&lt; Iterator, Body, Item &gt;</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00227.html">tbb::internal::parallel_do_feeder_impl&lt; Body, Item &gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">For internal use only.  <a href="a00227.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00207.html">tbb::internal::do_group_task_forward&lt; Iterator, Body, Item &gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">For internal use only.  <a href="a00207.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><b>tbb::internal::do_group_task_input&lt; Body, Item &gt;</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00209.html">tbb::internal::do_task_iter&lt; Iterator, Body, Item &gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">For internal use only.  <a href="a00209.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00249.html">tbb::internal::start_for&lt; Range, Body, Partitioner &gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Task type used in parallel_for.  <a href="a00249.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00214.html">tbb::internal::finish_reduce&lt; Body &gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Task type use to combine the partial results of parallel_reduce.  <a href="a00214.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00250.html">tbb::internal::start_reduce&lt; Range, Body, Partitioner &gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Task type used to split the work of parallel_reduce.  <a href="a00250.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00215.html">tbb::internal::finish_reduce_with_affinity&lt; Body &gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Task type use to combine the partial results of parallel_reduce with <a class="el" href="a00183.html">affinity_partitioner</a>.  <a href="a00215.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00251.html">tbb::internal::start_reduce_with_affinity&lt; Range, Body &gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Task type used to split the work of parallel_reduce with <a class="el" href="a00183.html">affinity_partitioner</a>.  <a href="a00251.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00220.html">tbb::internal::lambda_reduce_body&lt; Range, Value, RealBody, Reduction &gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Auxiliary class for parallel_reduce; for internal use only.  <a href="a00220.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00213.html">tbb::internal::final_sum&lt; Range, Body &gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Performs final scan for a leaf.  <a href="a00213.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00254.html">tbb::internal::sum_node&lt; Range, Body &gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Split work to be done in the scan.  <a href="a00254.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00216.html">tbb::internal::finish_scan&lt; Range, Body &gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Combine partial results.  <a href="a00216.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00252.html">tbb::internal::start_scan&lt; Range, Body, Partitioner &gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Initial task to split the work.  <a href="a00252.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00238.html">tbb::internal::quick_sort_range&lt; RandomAccessIterator, Compare &gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Range used in quicksort to split elements into subranges based on a value.  <a href="a00238.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00237.html">tbb::internal::quick_sort_body&lt; RandomAccessIterator, Compare &gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Body class used to sort elements in a range that is smaller than the grainsize.  <a href="a00237.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00271.html">tbb::internal::while_iteration_task&lt; Body &gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">For internal use only.  <a href="a00271.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00270.html">tbb::internal::while_group_task&lt; Body &gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">For internal use only.  <a href="a00270.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00272.html">tbb::internal::while_task&lt; Stream, Body &gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">For internal use only.  <a href="a00272.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00184.html">tbb::internal::affinity_partitioner_base_v3</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Defines entry points into tbb run-time library;.  <a href="a00184.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00230.html">tbb::internal::partition_type_base</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Provides default methods for partition objects without affinity.  <a href="a00230.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><b>tbb::internal::affinity_partition_type</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><b>tbb::internal::scheduler</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><b>tbb::internal::context_list_node_t</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><b>tbb::internal::allocate_root_with_context_proxy</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><b>tbb::internal::allocate_root_proxy</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><b>tbb::internal::allocate_continuation_proxy</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><b>tbb::internal::allocate_child_proxy</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><b>tbb::internal::allocate_additional_child_of_proxy</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00258.html">tbb::internal::task_prefix</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Memory prefix to a task object.  <a href="a00258.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><b>tbb::internal::task_scheduler_observer_v3</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00187.html">tbb::internal::AtomicBackoff</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Class that implements exponential backoff.  <a href="a00187.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><b>tbb::internal::__TBB_machine_type_with_strictest_alignment</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><b>tbb::internal::type_with_alignment&lt; N &gt;</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><b>tbb::internal::type_with_alignment&lt; 1 &gt;</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><b>tbb::internal::type_with_alignment&lt; 2 &gt;</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><b>tbb::internal::type_with_alignment&lt; 4 &gt;</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><b>tbb::internal::type_with_alignment&lt; 8 &gt;</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00273.html">tbb::internal::work_around_alignment_bug&lt; Size, T &gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Work around for bug in GNU 3.2 and MSVC compilers.  <a href="a00273.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00224.html">tbb::internal::no_assign</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Base class for types that should not be assigned.  <a href="a00224.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00225.html">tbb::internal::no_copy</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Base class for types that should not be copied or assigned.  <a href="a00225.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00269.html">tbb::internal::version_tag_v3</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><b>tbb::internal::thread_closure_base</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><b>tbb::internal::thread_closure_0&lt; F &gt;</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00265.html">tbb::internal::thread_closure_1&lt; F, X &gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Structure used to pass user function with 1 argument to thread.  <a href="a00265.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><b>tbb::internal::thread_closure_2&lt; F, X, Y &gt;</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00264.html">tbb::internal::tbb_thread_v3</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Versioned thread class.  <a href="a00264.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><b>tbb::internal::tbb_thread_v3::id</b></td></tr>

<tr><td colspan="2"><br><h2>Typedefs</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a2" doxytag="tbb::internal::hashcode_t"></a>
typedef size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00311.html#a2">hashcode_t</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Type of a hash code. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a4" doxytag="tbb::internal::concurrent_queue_base"></a>
typedef <a class="el" href="a00200.html">concurrent_queue_base_v3</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>concurrent_queue_base</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a5" doxytag="tbb::internal::concurrent_queue_iterator_base"></a>
typedef <a class="el" href="a00203.html">concurrent_queue_iterator_base_v3</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>concurrent_queue_iterator_base</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a6" doxytag="tbb::internal::concurrent_vector_base"></a>
typedef <a class="el" href="a00205.html">concurrent_vector_base_v3</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>concurrent_vector_base</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef char&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00311.html#a7">reduction_context</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">0 if root, 1 if a left child, 2 if a right child.  <a href="#a7"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a8" doxytag="tbb::internal::Token"></a>
typedef unsigned long&nbsp;</td><td class="memItemRight" valign="bottom"><b>Token</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a9" doxytag="tbb::internal::tokendiff_t"></a>
typedef long&nbsp;</td><td class="memItemRight" valign="bottom"><b>tokendiff_t</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef <a class="el" href="a00311.html#a22">intptr</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00311.html#a10">reference_count</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A reference count.  <a href="#a10"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a11" doxytag="tbb::internal::affinity_id"></a>
typedef unsigned short&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00311.html#a11">affinity_id</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">An id as used for specifying affinity. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a13" doxytag="tbb::internal::int8_t"></a>
typedef __int8&nbsp;</td><td class="memItemRight" valign="bottom"><b>int8_t</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a14" doxytag="tbb::internal::int16_t"></a>
typedef __int16&nbsp;</td><td class="memItemRight" valign="bottom"><b>int16_t</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a15" doxytag="tbb::internal::int32_t"></a>
typedef __int32&nbsp;</td><td class="memItemRight" valign="bottom"><b>int32_t</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a16" doxytag="tbb::internal::int64_t"></a>
typedef __int64&nbsp;</td><td class="memItemRight" valign="bottom"><b>int64_t</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a17" doxytag="tbb::internal::uint8_t"></a>
typedef unsigned __int8&nbsp;</td><td class="memItemRight" valign="bottom"><b>uint8_t</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a18" doxytag="tbb::internal::uint16_t"></a>
typedef unsigned __int16&nbsp;</td><td class="memItemRight" valign="bottom"><b>uint16_t</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a19" doxytag="tbb::internal::uint32_t"></a>
typedef unsigned __int32&nbsp;</td><td class="memItemRight" valign="bottom"><b>uint32_t</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a20" doxytag="tbb::internal::uint64_t"></a>
typedef unsigned __int64&nbsp;</td><td class="memItemRight" valign="bottom"><b>uint64_t</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00311.html#a21">uintptr</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">An unsigned integral type big enough to hold a pointer.  <a href="#a21"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef std::ptrdiff_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00311.html#a22">intptr</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A signed integral type big enough to hold a pointer.  <a href="#a22"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a23" doxytag="tbb::internal::version_tag"></a>
typedef <a class="el" href="a00269.html">version_tag_v3</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>version_tag</b></td></tr>

<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a24" doxytag="tbb::internal::__TBB_DECL_FENCED_ATOMIC_PRIMITIVES"></a>
&nbsp;</td><td class="memItemRight" valign="bottom"><b>__TBB_DECL_FENCED_ATOMIC_PRIMITIVES</b> (1, __TBB_full_fence) __TBB_DECL_FENCED_ATOMIC_PRIMITIVES(2</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a25" doxytag="tbb::internal::__TBB_DECL_FENCED_ATOMIC_PRIMITIVES"></a>
__TBB_full_fence&nbsp;</td><td class="memItemRight" valign="bottom"><b>__TBB_DECL_FENCED_ATOMIC_PRIMITIVES</b> (4, __TBB_full_fence) __TBB_DECL_FENCED_ATOMIC_PRIMITIVES(8</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a26" doxytag="tbb::internal::__TBB_DECL_FENCED_ATOMIC_PRIMITIVES"></a>
__TBB_full_fence __TBB_full_fence&nbsp;</td><td class="memItemRight" valign="bottom"><b>__TBB_DECL_FENCED_ATOMIC_PRIMITIVES</b> (1, acquire) __TBB_DECL_FENCED_ATOMIC_PRIMITIVES(2</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a27" doxytag="tbb::internal::__TBB_DECL_FENCED_ATOMIC_PRIMITIVES"></a>
__TBB_full_fence __TBB_full_fence <br>
acquire&nbsp;</td><td class="memItemRight" valign="bottom"><b>__TBB_DECL_FENCED_ATOMIC_PRIMITIVES</b> (4, acquire) __TBB_DECL_FENCED_ATOMIC_PRIMITIVES(8</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a28" doxytag="tbb::internal::__TBB_DECL_FENCED_ATOMIC_PRIMITIVES"></a>
__TBB_full_fence __TBB_full_fence <br>
acquire acquire&nbsp;</td><td class="memItemRight" valign="bottom"><b>__TBB_DECL_FENCED_ATOMIC_PRIMITIVES</b> (1, release) __TBB_DECL_FENCED_ATOMIC_PRIMITIVES(2</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a29" doxytag="tbb::internal::__TBB_DECL_FENCED_ATOMIC_PRIMITIVES"></a>
__TBB_full_fence __TBB_full_fence <br>
acquire acquire release&nbsp;</td><td class="memItemRight" valign="bottom"><b>__TBB_DECL_FENCED_ATOMIC_PRIMITIVES</b> (4, release) __TBB_DECL_FENCED_ATOMIC_PRIMITIVES(8</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">__TBB_full_fence __TBB_full_fence <br>
acquire acquire release release&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00311.html#a30">__TBB_DECL_ATOMIC_PRIMITIVES</a> (1) __TBB_DECL_ATOMIC_PRIMITIVES(2) __TBB_DECL_ATOMIC_PRIMITIVES(4) __TBB_DECL_ATOMIC_PRIMITIVES(8) template&lt; typename I</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Base class that provides basic functionality for atomic&lt;T&gt;.  <a href="#a30"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a31" doxytag="tbb::internal::NFS_GetLineSize"></a>
size_t __TBB_EXPORTED_FUNC&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00311.html#a31">NFS_GetLineSize</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Cache/sector line size. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a32" doxytag="tbb::internal::NFS_Allocate"></a>
void *__TBB_EXPORTED_FUNC&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00311.html#a32">NFS_Allocate</a> (size_t n_element, size_t element_size, void *hint)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Allocate memory on cache/sector line boundary. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void __TBB_EXPORTED_FUNC&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00311.html#a33">NFS_Free</a> (void *)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Free memory allocated by NFS_Allocate.  <a href="#a33"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="a34" doxytag="tbb::internal::operator=="></a>
template&lt;typename Container, typename T, typename U&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>operator==</b> (const <a class="el" href="a00218.html">hash_map_iterator</a>&lt; Container, T &gt; &amp;i, const <a class="el" href="a00218.html">hash_map_iterator</a>&lt; Container, U &gt; &amp;j)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="a35" doxytag="tbb::internal::operator!="></a>
template&lt;typename Container, typename T, typename U&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>operator!=</b> (const <a class="el" href="a00218.html">hash_map_iterator</a>&lt; Container, T &gt; &amp;i, const <a class="el" href="a00218.html">hash_map_iterator</a>&lt; Container, U &gt; &amp;j)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="a36" doxytag="tbb::internal::hasher"></a>
template&lt;typename T&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="a00311.html#a2">hashcode_t</a>&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00311.html#a36">hasher</a> (const T &amp;t)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Hasher functions. <br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="a37" doxytag="tbb::internal::hasher"></a>
template&lt;typename P&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="a00311.html#a2">hashcode_t</a>&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>hasher</b> (P *ptr)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="a38" doxytag="tbb::internal::hasher"></a>
template&lt;typename E, typename S, typename A&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="a00311.html#a2">hashcode_t</a>&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>hasher</b> (const std::basic_string&lt; E, S, A &gt; &amp;s)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="a39" doxytag="tbb::internal::hasher"></a>
template&lt;typename F, typename S&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="a00311.html#a2">hashcode_t</a>&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>hasher</b> (const std::pair&lt; F, S &gt; &amp;p)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="a40" doxytag="tbb::internal::operator=="></a>
template&lt;typename C, typename T, typename U&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>operator==</b> (const <a class="el" href="a00202.html">concurrent_queue_iterator</a>&lt; C, T &gt; &amp;i, const <a class="el" href="a00202.html">concurrent_queue_iterator</a>&lt; C, U &gt; &amp;j)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="a41" doxytag="tbb::internal::operator!="></a>
template&lt;typename C, typename T, typename U&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>operator!=</b> (const <a class="el" href="a00202.html">concurrent_queue_iterator</a>&lt; C, T &gt; &amp;i, const <a class="el" href="a00202.html">concurrent_queue_iterator</a>&lt; C, U &gt; &amp;j)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a42" doxytag="tbb::internal::itt_load_pointer_v3"></a>
void *__TBB_EXPORTED_FUNC&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00311.html#a42">itt_load_pointer_v3</a> (const void *src)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Routine that loads pointer from location pointed to by src without any fence, without causing ITT to report a race. <br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="a43" doxytag="tbb::internal::operator+"></a>
template&lt;typename Container, typename T&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="a00268.html">vector_iterator</a>&lt; Container,<br>
 T &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>operator+</b> (ptrdiff_t offset, const <a class="el" href="a00268.html">vector_iterator</a>&lt; Container, T &gt; &amp;v)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="a44" doxytag="tbb::internal::operator=="></a>
template&lt;typename Container, typename T, typename U&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>operator==</b> (const <a class="el" href="a00268.html">vector_iterator</a>&lt; Container, T &gt; &amp;i, const <a class="el" href="a00268.html">vector_iterator</a>&lt; Container, U &gt; &amp;j)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="a45" doxytag="tbb::internal::operator!="></a>
template&lt;typename Container, typename T, typename U&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>operator!=</b> (const <a class="el" href="a00268.html">vector_iterator</a>&lt; Container, T &gt; &amp;i, const <a class="el" href="a00268.html">vector_iterator</a>&lt; Container, U &gt; &amp;j)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="a46" doxytag="tbb::internal::operator<"></a>
template&lt;typename Container, typename T, typename U&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;</b> (const <a class="el" href="a00268.html">vector_iterator</a>&lt; Container, T &gt; &amp;i, const <a class="el" href="a00268.html">vector_iterator</a>&lt; Container, U &gt; &amp;j)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="a47" doxytag="tbb::internal::operator>"></a>
template&lt;typename Container, typename T, typename U&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;</b> (const <a class="el" href="a00268.html">vector_iterator</a>&lt; Container, T &gt; &amp;i, const <a class="el" href="a00268.html">vector_iterator</a>&lt; Container, U &gt; &amp;j)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="a48" doxytag="tbb::internal::operator>="></a>
template&lt;typename Container, typename T, typename U&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;=</b> (const <a class="el" href="a00268.html">vector_iterator</a>&lt; Container, T &gt; &amp;i, const <a class="el" href="a00268.html">vector_iterator</a>&lt; Container, U &gt; &amp;j)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="a49" doxytag="tbb::internal::operator<="></a>
template&lt;typename Container, typename T, typename U&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;=</b> (const <a class="el" href="a00268.html">vector_iterator</a>&lt; Container, T &gt; &amp;i, const <a class="el" href="a00268.html">vector_iterator</a>&lt; Container, U &gt; &amp;j)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="a50" doxytag="tbb::internal::operator-"></a>
template&lt;typename Container, typename T, typename U&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">ptrdiff_t&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>operator-</b> (const <a class="el" href="a00268.html">vector_iterator</a>&lt; Container, T &gt; &amp;i, const <a class="el" href="a00268.html">vector_iterator</a>&lt; Container, U &gt; &amp;j)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a51" doxytag="tbb::internal::handle_perror"></a>
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>handle_perror</b> (int error_code, const char *what)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename Iterator, typename Body, typename Item&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00313.html#ga0">run_parallel_do</a> (Iterator first, Iterator last, const Body &amp;body#if __TBB_EXCEPTIONS, <a class="el" href="a00256.html">task_group_context</a> &amp;context#endif)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">For internal use only.  <a href="a00313.html#ga0"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename Iterator, typename Body, typename Item&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00313.html#ga1">select_parallel_do</a> (Iterator first, Iterator last, const Body &amp;body, void(Body::*)(Item) const #if __TBB_EXCEPTIONS, <a class="el" href="a00256.html">task_group_context</a> &amp;context#endif)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">For internal use only.  <a href="a00313.html#ga1"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename Iterator, typename Body, typename Item, typename _Item&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00313.html#ga2">select_parallel_do</a> (Iterator first, Iterator last, const Body &amp;body, void(Body::*)(Item, <a class="el" href="a00226.html">parallel_do_feeder</a>&lt; _Item &gt; &amp;) const #if __TBB_EXCEPTIONS, <a class="el" href="a00256.html">task_group_context</a> &amp;context#endif)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">For internal use only.  <a href="a00313.html#ga2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a55" doxytag="tbb::internal::itt_store_pointer_with_release_v3"></a>
void __TBB_EXPORTED_FUNC&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00311.html#a55">itt_store_pointer_with_release_v3</a> (void *dst, void *src)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">ITT instrumented routine that stores src into location pointed to by dst. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a56" doxytag="tbb::internal::itt_load_pointer_with_acquire_v3"></a>
void *__TBB_EXPORTED_FUNC&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00311.html#a56">itt_load_pointer_with_acquire_v3</a> (const void *src)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">ITT instrumented routine that loads pointer from location pointed to by src. <br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="a57" doxytag="tbb::internal::parallel_reduce_store_body"></a>
template&lt;typename T&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>parallel_reduce_store_body</b> (T *&amp;dst, T *src)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="a58" doxytag="tbb::internal::parallel_reduce_load_body"></a>
template&lt;typename T&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">T *&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>parallel_reduce_load_body</b> (T *&amp;src)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="ga25" doxytag="tbb::internal::parallel_quick_sort"></a>
template&lt;typename RandomAccessIterator, typename Compare&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00313.html#ga25">parallel_quick_sort</a> (RandomAccessIterator begin, RandomAccessIterator end, const Compare &amp;comp)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Wrapper method to initiate the sort by calling parallel_for. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a60" doxytag="tbb::internal::get_initial_auto_partitioner_divisor"></a>
size_t __TBB_EXPORTED_FUNC&nbsp;</td><td class="memItemRight" valign="bottom"><b>get_initial_auto_partitioner_divisor</b> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void __TBB_EXPORTED_FUNC&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00311.html#a61">deallocate_via_handler_v3</a> (void *p)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Deallocates memory using FreeHandler.  <a href="#a61"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void *__TBB_EXPORTED_FUNC&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00311.html#a62">allocate_via_handler_v3</a> (size_t n)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Allocates memory using MallocHandler.  <a href="#a62"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a63" doxytag="tbb::internal::is_malloc_used_v3"></a>
bool __TBB_EXPORTED_FUNC&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00311.html#a63">is_malloc_used_v3</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns true if standard malloc/free are used to work with memory. <br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="a64" doxytag="tbb::internal::__TBB_MaskedCompareAndSwap"></a>
template&lt;size_t S, typename T&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">T&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>__TBB_MaskedCompareAndSwap</b> (volatile T *ptr, T value, T comparand)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="a65" doxytag="tbb::internal::__TBB_CompareAndSwapGeneric"></a>
template&lt;size_t S, typename T&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">T&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>__TBB_CompareAndSwapGeneric</b> (volatile void *ptr, T value, T comparand)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="a66" doxytag="tbb::internal::__TBB_CompareAndSwapGeneric< 1, uint8_t >"></a>
template&lt;&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">uint8_t&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>__TBB_CompareAndSwapGeneric&lt; 1, uint8_t &gt;</b> (volatile void *ptr, uint8_t value, uint8_t comparand)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="a67" doxytag="tbb::internal::__TBB_CompareAndSwapGeneric< 2, uint16_t >"></a>
template&lt;&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">uint16_t&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>__TBB_CompareAndSwapGeneric&lt; 2, uint16_t &gt;</b> (volatile void *ptr, uint16_t value, uint16_t comparand)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="a68" doxytag="tbb::internal::__TBB_CompareAndSwapGeneric< 4, uint32_t >"></a>
template&lt;&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">uint32_t&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>__TBB_CompareAndSwapGeneric&lt; 4, uint32_t &gt;</b> (volatile void *ptr, uint32_t value, uint32_t comparand)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="a69" doxytag="tbb::internal::__TBB_CompareAndSwapGeneric< 8, uint64_t >"></a>
template&lt;&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">uint64_t&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>__TBB_CompareAndSwapGeneric&lt; 8, uint64_t &gt;</b> (volatile void *ptr, uint64_t value, uint64_t comparand)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="a70" doxytag="tbb::internal::__TBB_FetchAndAddGeneric"></a>
template&lt;size_t S, typename T&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">T&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>__TBB_FetchAndAddGeneric</b> (volatile void *ptr, T addend)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="a71" doxytag="tbb::internal::__TBB_FetchAndStoreGeneric"></a>
template&lt;size_t S, typename T&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">T&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>__TBB_FetchAndStoreGeneric</b> (volatile void *ptr, T value)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a72" doxytag="tbb::internal::__declspec"></a>
&nbsp;</td><td class="memItemRight" valign="bottom"><b>__declspec</b> (align(16)) struct __TBB_machine_type_with_strictest_alignment</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a73" doxytag="tbb::internal::itt_set_sync_name_v3"></a>
void __TBB_EXPORTED_FUNC&nbsp;</td><td class="memItemRight" valign="bottom"><b>itt_set_sync_name_v3</b> (void *obj, const wchar_t *name)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a74" doxytag="tbb::internal::itt_set_sync_name_v3"></a>
void __TBB_EXPORTED_FUNC&nbsp;</td><td class="memItemRight" valign="bottom"><b>itt_set_sync_name_v3</b> (void *obj, const char *name)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a75" doxytag="tbb::internal::runtime_warning"></a>
void __TBB_EXPORTED_FUNC&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00311.html#a75">runtime_warning</a> (const char *format,...)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Report a runtime warning. <br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="a76" doxytag="tbb::internal::poison_pointer"></a>
template&lt;typename T&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00311.html#a76">poison_pointer</a> (T *&amp;p)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set p to invalid pointer value. <br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="a77" doxytag="tbb::internal::poison_pointer"></a>
template&lt;typename T&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>poison_pointer</b> (T *)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a78" doxytag="tbb::internal::allocate_closure_v3"></a>
void *__TBB_EXPORTED_FUNC&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00311.html#a78">allocate_closure_v3</a> (size_t size)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Allocate a closure. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a79" doxytag="tbb::internal::free_closure_v3"></a>
void __TBB_EXPORTED_FUNC&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00311.html#a79">free_closure_v3</a> (void *)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Free a closure allocated by allocate_closure_v3. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a80" doxytag="tbb::internal::move_v3"></a>
void __TBB_EXPORTED_FUNC&nbsp;</td><td class="memItemRight" valign="bottom"><b>move_v3</b> (<a class="el" href="a00264.html">tbb_thread_v3</a> &amp;t1, <a class="el" href="a00264.html">tbb_thread_v3</a> &amp;t2)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a81" doxytag="tbb::internal::thread_get_id_v3"></a>
tbb_thread_v3::id __TBB_EXPORTED_FUNC&nbsp;</td><td class="memItemRight" valign="bottom"><b>thread_get_id_v3</b> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a82" doxytag="tbb::internal::thread_yield_v3"></a>
void __TBB_EXPORTED_FUNC&nbsp;</td><td class="memItemRight" valign="bottom"><b>thread_yield_v3</b> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a83" doxytag="tbb::internal::thread_sleep_v3"></a>
void __TBB_EXPORTED_FUNC&nbsp;</td><td class="memItemRight" valign="bottom"><b>thread_sleep_v3</b> (const <a class="el" href="a00267.html">tick_count::interval_t</a> &amp;i)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a84" doxytag="tbb::internal::operator=="></a>
bool&nbsp;</td><td class="memItemRight" valign="bottom"><b>operator==</b> (tbb_thread_v3::id x, tbb_thread_v3::id y)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a85" doxytag="tbb::internal::operator!="></a>
bool&nbsp;</td><td class="memItemRight" valign="bottom"><b>operator!=</b> (tbb_thread_v3::id x, tbb_thread_v3::id y)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a86" doxytag="tbb::internal::operator<"></a>
bool&nbsp;</td><td class="memItemRight" valign="bottom"><b>operator&lt;</b> (tbb_thread_v3::id x, tbb_thread_v3::id y)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a87" doxytag="tbb::internal::operator<="></a>
bool&nbsp;</td><td class="memItemRight" valign="bottom"><b>operator&lt;=</b> (tbb_thread_v3::id x, tbb_thread_v3::id y)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a88" doxytag="tbb::internal::operator>"></a>
bool&nbsp;</td><td class="memItemRight" valign="bottom"><b>operator&gt;</b> (tbb_thread_v3::id x, tbb_thread_v3::id y)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a89" doxytag="tbb::internal::operator>="></a>
bool&nbsp;</td><td class="memItemRight" valign="bottom"><b>operator&gt;=</b> (tbb_thread_v3::id x, tbb_thread_v3::id y)</td></tr>

<tr><td colspan="2"><br><h2>Variables</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a0" doxytag="tbb::internal::D"></a>
__TBB_full_fence __TBB_full_fence <br>
acquire acquire release release&nbsp;</td><td class="memItemRight" valign="bottom"><b>D</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">const size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00311.html#a1">NFS_MaxLineSize</a> = 128</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compile-time constant that is upper bound on cache line/sector size.  <a href="#a1"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a3" doxytag="tbb::internal::hash_multiplier"></a>
const <a class="el" href="a00311.html#a2">hashcode_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00311.html#a3">hash_multiplier</a> = sizeof(<a class="el" href="a00311.html#a2">hashcode_t</a>)==4? 2654435769U : 11400714819323198485ULL</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Hash multiplier. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a12" doxytag="tbb::internal::aligned"></a>
tbb::internal::__TBB_machine_type_with_strictest_alignment&nbsp;</td><td class="memItemRight" valign="bottom"><b>aligned</b></td></tr>

</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
INTERNAL 
<p>
INTERNAL 
<p>
<hr><h2>Typedef Documentation</h2>
<a class="anchor" name="a22" doxytag="tbb::internal::intptr"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">typedef std::ptrdiff_t <a class="el" href="a00311.html#a22">tbb::internal::intptr</a>          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
A signed integral type big enough to hold a pointer. 
<p>
There's no guarantee by the C++ standard that a ptrdiff_t is really big enough, but it happens to be for all platforms of interest.     </td>
  </tr>
</table>
<a class="anchor" name="a7" doxytag="tbb::internal::reduction_context"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">typedef char <a class="el" href="a00311.html#a7">tbb::internal::reduction_context</a>          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
0 if root, 1 if a left child, 2 if a right child. 
<p>
Represented as a char, not enum, for compactness.     </td>
  </tr>
</table>
<a class="anchor" name="a10" doxytag="tbb::internal::reference_count"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">typedef <a class="el" href="a00311.html#a22">intptr</a> <a class="el" href="a00311.html#a10">tbb::internal::reference_count</a>          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
A reference count. 
<p>
Should always be non-negative. A signed type is used so that underflow can be detected.     </td>
  </tr>
</table>
<a class="anchor" name="a21" doxytag="tbb::internal::uintptr"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">typedef size_t <a class="el" href="a00311.html#a21">tbb::internal::uintptr</a>          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
An unsigned integral type big enough to hold a pointer. 
<p>
There's no guarantee by the C++ standard that a size_t is really big enough, but it happens to be for all platforms of interest.     </td>
  </tr>
</table>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="a30" doxytag="tbb::internal::__TBB_DECL_ATOMIC_PRIMITIVES"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">__TBB_full_fence __TBB_full_fence acquire acquire release release __TBB_DECL_ATOMIC_PRIMITIVES           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">1&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Base class that provides basic functionality for atomic&lt;T&gt;. 
<p>
I is the underlying type. D is the difference type. StepType should be char if I is an integral type, and T if I is a T*.     </td>
  </tr>
</table>
<a class="anchor" name="a62" doxytag="tbb::internal::allocate_via_handler_v3"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void* __TBB_EXPORTED_FUNC allocate_via_handler_v3           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">size_t&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>n</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Allocates memory using MallocHandler. 
<p>
The function uses scalable_malloc if scalable allocator is available and malloc if not     </td>
  </tr>
</table>
<a class="anchor" name="a61" doxytag="tbb::internal::deallocate_via_handler_v3"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void __TBB_EXPORTED_FUNC deallocate_via_handler_v3           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>p</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Deallocates memory using FreeHandler. 
<p>
The function uses scalable_free if scalable allocator is available and free if not     </td>
  </tr>
</table>
<a class="anchor" name="a33" doxytag="tbb::internal::NFS_Free"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void __TBB_EXPORTED_FUNC NFS_Free           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Free memory allocated by NFS_Allocate. 
<p>
Freeing a NULL pointer is allowed, but has no effect.     </td>
  </tr>
</table>
<hr><h2>Variable Documentation</h2>
<a class="anchor" name="a1" doxytag="tbb::internal::NFS_MaxLineSize"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">const size_t <a class="el" href="a00311.html#a1">tbb::internal::NFS_MaxLineSize</a> = 128          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Compile-time constant that is upper bound on cache line/sector size. 
<p>
It should be used only in situations where having a compile-time upper bound is more useful than a run-time exact answer.     </td>
  </tr>
</table>
<hr>
<p></p>
Copyright &copy; 2005-2008 Intel Corporation.  All Rights Reserved.
<p></p>
Intel, Pentium, Intel Xeon, Itanium, Intel XScale and VTune are
registered trademarks or trademarks of Intel Corporation or its
subsidiaries in the United States and other countries.
<p></p>
* Other names and brands may be claimed as the property of others.
