<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>Hierarchical Index</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.9.1 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="modules.html">Modules</a> | <a class="qindex" href="namespaces.html">Namespace List</a> | <a class="qindexHL" href="hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="annotated.html">Class&nbsp;List</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="namespacemembers.html">Namespace&nbsp;Members</a> | <a class="qindex" href="functions.html">Class&nbsp;Members</a> | <a class="qindex" href="globals.html">File&nbsp;Members</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a></div>
<h1>Class Hierarchy</h1>This inheritance list is sorted roughly, but not completely, alphabetically:<ul>
<li><b>tbb::internal::__TBB_machine_type_with_strictest_alignment</b><li><a class="el" href="a00185.html">tbb::aligned_space&lt; T, N &gt;</a>
<li><b>tbb::internal::allocator_base&lt; T, A &gt;</b><li><a class="el" href="a00186.html">tbb::atomic&lt; T &gt;</a>
<li><b>tbb::atomic&lt; bool &gt;</b><li><b>tbb::atomic&lt; void * &gt;</b><li><b>tbb::internal::atomic_base&lt; I &gt;</b><li><b>tbb::internal::atomic_base&lt; int64_t &gt;</b><li><b>tbb::internal::atomic_base&lt; uint64_t &gt;</b><li><b>tbb::internal::atomic_impl</b><li><b>tbb::internal::atomic_traits&lt; Size, M &gt;</b><li><b>tbb::internal::atomic_word&lt; Size &gt;</b><li><b>tbb::internal::atomic_word&lt; 1 &gt;</b><li><b>tbb::internal::atomic_word&lt; 2 &gt;</b><li><b>tbb::internal::atomic_word&lt; 4 &gt;</b><li><b>tbb::internal::atomic_word&lt; 8 &gt;</b><li><a class="el" href="a00187.html">tbb::internal::AtomicBackoff</a>
<li><a class="el" href="a00188.html">tbb::auto_partitioner</a>
<li><a class="el" href="a00189.html">tbb::bad_last_alloc</a>
<li><a class="el" href="a00190.html">tbb::blocked_range&lt; Value &gt;</a>
<li><a class="el" href="a00191.html">tbb::blocked_range2d&lt; RowValue, ColValue &gt;</a>
<li><a class="el" href="a00192.html">tbb::blocked_range3d&lt; PageValue, RowValue, ColValue &gt;</a>
<li><a class="el" href="a00190.html">tbb::blocked_range&lt; I &gt;</a>
<li><a class="el" href="a00193.html">tbb::cache_aligned_allocator&lt; T &gt;</a>
<li><b>tbb::cache_aligned_allocator&lt; T &gt;::rebind&lt; U &gt;</b><li><a class="el" href="a00194.html">tbb::cache_aligned_allocator&lt; void &gt;</a>
<li><b>tbb::cache_aligned_allocator&lt; void &gt;::rebind&lt; U &gt;</b><li><a class="el" href="a00198.html">tbb::concurrent_hash_map&lt; Key, T, HashCompare, A &gt;::const_accessor</a>
<ul>
<li><a class="el" href="a00197.html">tbb::concurrent_hash_map&lt; Key, T, HashCompare, A &gt;::accessor</a>
</ul>
<li><a class="el" href="a00201.html">tbb::internal::concurrent_queue_base_v3::page</a>
<li><a class="el" href="a00203.html">tbb::internal::concurrent_queue_iterator_base_v3</a>
<ul>
<li><a class="el" href="a00202.html">tbb::internal::concurrent_queue_iterator&lt; Container, Value &gt;</a>
</ul>
<li><a class="el" href="a00205.html">tbb::internal::concurrent_vector_base_v3</a>
<ul>
<li><a class="el" href="a00204.html">tbb::concurrent_vector&lt; T, A &gt;</a>
</ul>
<li><a class="el" href="a00206.html">tbb::internal::concurrent_vector_base_v3::internal_segments_table</a>
<li><b>tbb::internal::concurrent_vector_base_v3::segment_t</b><li><b>tbb::internal::context_list_node_t</b><li><a class="el" href="a00212.html">tbb::final_scan_tag</a>
<li><a class="el" href="a00217.html">tbb::internal::hash_map_base</a>
<ul>
<li><a class="el" href="a00196.html">tbb::concurrent_hash_map&lt; Key, T, HashCompare, A &gt;</a>
</ul>
<li><a class="el" href="a00218.html">tbb::internal::hash_map_iterator&lt; Container, Value &gt;</a>
<li><a class="el" href="a00219.html">tbb::internal::hash_map_range&lt; Iterator &gt;</a>
<li><b>tbb::internal::hash_map_segment_base</b><li><a class="el" href="a00220.html">tbb::internal::lambda_reduce_body&lt; Range, Value, RealBody, Reduction &gt;</a>
<li><a class="el" href="a00222.html">tbb::mutex</a>
<li><a class="el" href="a00224.html">tbb::internal::no_assign</a>
<ul>
<li><b>tbb::internal::allocate_additional_child_of_proxy</b><li><b>tbb::internal::allocate_child_proxy</b><li><b>tbb::internal::allocate_continuation_proxy</b><li><b>tbb::internal::allocate_root_proxy</b><li><b>tbb::internal::allocate_root_with_context_proxy</b><li><a class="el" href="a00225.html">tbb::internal::no_copy</a>
<ul>
<li><a class="el" href="a00211.html">tbb::filter</a>
<li><b>tbb::internal::affinity_partition_type</b><li><a class="el" href="a00184.html">tbb::internal::affinity_partitioner_base_v3</a>
<ul>
<li><a class="el" href="a00183.html">tbb::affinity_partitioner</a>
</ul>
<li><a class="el" href="a00200.html">tbb::internal::concurrent_queue_base_v3</a>
<ul>
<li><a class="el" href="a00199.html">tbb::concurrent_queue&lt; T, A &gt;</a>
</ul>
<li><b>tbb::internal::scheduler</b><li><a class="el" href="a00223.html">tbb::mutex::scoped_lock</a>
<li><a class="el" href="a00226.html">tbb::parallel_do_feeder&lt; Item &gt;</a>
<ul>
<li><a class="el" href="a00227.html">tbb::internal::parallel_do_feeder_impl&lt; Body, Item &gt;</a>
</ul>
<li><a class="el" href="a00229.html">tbb::parallel_while&lt; Body &gt;</a>
<li><a class="el" href="a00234.html">tbb::queuing_mutex::scoped_lock</a>
<li><a class="el" href="a00236.html">tbb::queuing_rw_mutex::scoped_lock</a>
<li><a class="el" href="a00240.html">tbb::recursive_mutex::scoped_lock</a>
<li><a class="el" href="a00245.html">tbb::spin_mutex::scoped_lock</a>
<li><a class="el" href="a00247.html">tbb::spin_rw_mutex_v3::scoped_lock</a>
<li><a class="el" href="a00255.html">tbb::task</a>
<ul>
<li><a class="el" href="a00210.html">tbb::empty_task</a>
<li><a class="el" href="a00207.html">tbb::internal::do_group_task_forward&lt; Iterator, Body, Item &gt;</a>
<li><b>tbb::internal::do_group_task_input</b><li><a class="el" href="a00208.html">tbb::internal::do_iteration_task&lt; Body, Item &gt;</a>
<li><b>tbb::internal::do_iteration_task_iter</b><li><a class="el" href="a00209.html">tbb::internal::do_task_iter&lt; Iterator, Body, Item &gt;</a>
<li><a class="el" href="a00213.html">tbb::internal::final_sum&lt; Range, Body &gt;</a>
<li><a class="el" href="a00214.html">tbb::internal::finish_reduce&lt; Body &gt;</a>
<li><a class="el" href="a00215.html">tbb::internal::finish_reduce_with_affinity&lt; Body &gt;</a>
<li><a class="el" href="a00216.html">tbb::internal::finish_scan&lt; Range, Body &gt;</a>
<li><a class="el" href="a00249.html">tbb::internal::start_for&lt; Range, Body, Partitioner &gt;</a>
<li><a class="el" href="a00250.html">tbb::internal::start_reduce&lt; Range, Body, Partitioner &gt;</a>
<li><a class="el" href="a00251.html">tbb::internal::start_reduce_with_affinity&lt; Range, Body &gt;</a>
<li><a class="el" href="a00252.html">tbb::internal::start_scan&lt; Range, Body, Partitioner &gt;</a>
<li><a class="el" href="a00254.html">tbb::internal::sum_node&lt; Range, Body &gt;</a>
<li><a class="el" href="a00270.html">tbb::internal::while_group_task&lt; Body &gt;</a>
<li><a class="el" href="a00271.html">tbb::internal::while_iteration_task&lt; Body &gt;</a>
<li><a class="el" href="a00272.html">tbb::internal::while_task&lt; Stream, Body &gt;</a>
</ul>
<li><a class="el" href="a00256.html">tbb::task_group_context</a>
<li><a class="el" href="a00257.html">tbb::task_list</a>
<li><a class="el" href="a00259.html">tbb::task_scheduler_init</a>
</ul>
<li><a class="el" href="a00238.html">tbb::internal::quick_sort_range&lt; RandomAccessIterator, Compare &gt;</a>
</ul>
<li><a class="el" href="a00228.html">tbb::internal::parallel_do_operator_selector&lt; Body, Item &gt;</a>
<li><a class="el" href="a00230.html">tbb::internal::partition_type_base</a>
<li><a class="el" href="a00231.html">tbb::pipeline</a>
<li><a class="el" href="a00232.html">tbb::pre_scan_tag</a>
<li><a class="el" href="a00233.html">tbb::queuing_mutex</a>
<li><a class="el" href="a00235.html">tbb::queuing_rw_mutex</a>
<li><a class="el" href="a00237.html">tbb::internal::quick_sort_body&lt; RandomAccessIterator, Compare &gt;</a>
<li><a class="el" href="a00239.html">tbb::recursive_mutex</a>
<li><a class="el" href="a00241.html">tbb::scalable_allocator&lt; T &gt;</a>
<li><b>tbb::scalable_allocator&lt; T &gt;::rebind&lt; U &gt;</b><li><a class="el" href="a00242.html">tbb::scalable_allocator&lt; void &gt;</a>
<li><b>tbb::scalable_allocator&lt; void &gt;::rebind&lt; U &gt;</b><li><a class="el" href="a00243.html">tbb::simple_partitioner</a>
<li><a class="el" href="a00244.html">tbb::spin_mutex</a>
<li><a class="el" href="a00246.html">tbb::spin_rw_mutex_v3</a>
<li><a class="el" href="a00248.html">tbb::split</a>
<li><a class="el" href="a00253.html">tbb::internal::strip&lt; T &gt;</a>
<li><b>tbb::internal::strip&lt; const T &amp; &gt;</b><li><b>tbb::internal::strip&lt; const T &gt;</b><li><b>tbb::internal::strip&lt; const volatile T &amp; &gt;</b><li><b>tbb::internal::strip&lt; const volatile T &gt;</b><li><b>tbb::internal::strip&lt; T &amp; &gt;</b><li><b>tbb::internal::strip&lt; volatile T &amp; &gt;</b><li><b>tbb::internal::strip&lt; volatile T &gt;</b><li><a class="el" href="a00258.html">tbb::internal::task_prefix</a>
<li><b>tbb::internal::task_scheduler_observer_v3</b><li><a class="el" href="a00260.html">tbb::tbb_allocator&lt; T &gt;</a>
<li><b>tbb::tbb_allocator&lt; T &gt;::rebind&lt; U &gt;</b><li><a class="el" href="a00261.html">tbb::tbb_allocator&lt; void &gt;</a>
<li><b>tbb::tbb_allocator&lt; void &gt;::rebind&lt; U &gt;</b><li><a class="el" href="a00262.html">tbb::tbb_exception</a>
<ul>
<li><a class="el" href="a00195.html">tbb::captured_exception</a>
<li><a class="el" href="a00221.html">tbb::movable_exception&lt; ExceptionData &gt;</a>
</ul>
<li><a class="el" href="a00263.html">tbb::tbb_hash_compare&lt; T &gt;</a>
<li><a class="el" href="a00264.html">tbb::internal::tbb_thread_v3</a>
<li><b>tbb::internal::tbb_thread_v3::id</b><li><b>tbb::internal::thread_closure_0&lt; F &gt;</b><li><a class="el" href="a00265.html">tbb::internal::thread_closure_1&lt; F, X &gt;</a>
<li><b>tbb::internal::thread_closure_2&lt; F, X, Y &gt;</b><li><b>tbb::internal::thread_closure_base</b><li><a class="el" href="a00266.html">tbb::tick_count</a>
<li><a class="el" href="a00267.html">tbb::tick_count::interval_t</a>
<li><b>tbb::internal::type_with_alignment&lt; N &gt;</b><li><b>tbb::internal::type_with_alignment&lt; 1 &gt;</b><li><b>tbb::internal::type_with_alignment&lt; 2 &gt;</b><li><b>tbb::internal::type_with_alignment&lt; 4 &gt;</b><li><b>tbb::internal::type_with_alignment&lt; 8 &gt;</b><li><a class="el" href="a00268.html">tbb::internal::vector_iterator&lt; Container, Value &gt;</a>
<li><a class="el" href="a00269.html">tbb::internal::version_tag_v3</a>
<li><a class="el" href="a00273.html">tbb::internal::work_around_alignment_bug&lt; Size, T &gt;</a>
</ul>
<hr>
<p></p>
Copyright &copy; 2005-2008 Intel Corporation.  All Rights Reserved.
<p></p>
Intel, Pentium, Intel Xeon, Itanium, Intel XScale and VTune are
registered trademarks or trademarks of Intel Corporation or its
subsidiaries in the United States and other countries.
<p></p>
* Other names and brands may be claimed as the property of others.
