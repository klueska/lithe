<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>parallel_scan.h Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.9.1 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="modules.html">Modules</a> | <a class="qindex" href="namespaces.html">Namespace List</a> | <a class="qindex" href="hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="annotated.html">Class&nbsp;List</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="namespacemembers.html">Namespace&nbsp;Members</a> | <a class="qindex" href="functions.html">Class&nbsp;Members</a> | <a class="qindex" href="globals.html">File&nbsp;Members</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a></div>
<h1>parallel_scan.h</h1><div class="fragment"><pre class="fragment">00001 <span class="comment">/*</span>
00002 <span class="comment">    Copyright 2005-2008 Intel Corporation.  All Rights Reserved.</span>
00003 <span class="comment"></span>
00004 <span class="comment">    The source code contained or described herein and all documents related</span>
00005 <span class="comment">    to the source code ("Material") are owned by Intel Corporation or its</span>
00006 <span class="comment">    suppliers or licensors.  Title to the Material remains with Intel</span>
00007 <span class="comment">    Corporation or its suppliers and licensors.  The Material is protected</span>
00008 <span class="comment">    by worldwide copyright laws and treaty provisions.  No part of the</span>
00009 <span class="comment">    Material may be used, copied, reproduced, modified, published, uploaded,</span>
00010 <span class="comment">    posted, transmitted, distributed, or disclosed in any way without</span>
00011 <span class="comment">    Intel's prior express written permission.</span>
00012 <span class="comment"></span>
00013 <span class="comment">    No license under any patent, copyright, trade secret or other</span>
00014 <span class="comment">    intellectual property right is granted to or conferred upon you by</span>
00015 <span class="comment">    disclosure or delivery of the Materials, either expressly, by</span>
00016 <span class="comment">    implication, inducement, estoppel or otherwise.  Any license under such</span>
00017 <span class="comment">    intellectual property rights must be express and approved by Intel in</span>
00018 <span class="comment">    writing.</span>
00019 <span class="comment">*/</span>
00020 
00021 <span class="preprocessor">#ifndef __TBB_parallel_scan_H</span>
00022 <span class="preprocessor"></span><span class="preprocessor">#define __TBB_parallel_scan_H</span>
00023 <span class="preprocessor"></span>
00024 <span class="preprocessor">#include "task.h"</span>
00025 <span class="preprocessor">#include "aligned_space.h"</span>
00026 <span class="preprocessor">#include &lt;new&gt;</span>
00027 <span class="preprocessor">#include "partitioner.h"</span>
00028 
00029 <span class="keyword">namespace </span>tbb {
00030 
00032 
<a name="l00033"></a><a class="code" href="a00232.html">00033</a> <span class="keyword">struct </span><a class="code" href="a00232.html">pre_scan_tag</a> {
00034     <span class="keyword">static</span> <span class="keywordtype">bool</span> is_final_scan() {<span class="keywordflow">return</span> <span class="keyword">false</span>;}
00035 };
00036 
00038 
<a name="l00039"></a><a class="code" href="a00212.html">00039</a> <span class="keyword">struct </span><a class="code" href="a00212.html">final_scan_tag</a> {
00040     <span class="keyword">static</span> <span class="keywordtype">bool</span> is_final_scan() {<span class="keywordflow">return</span> <span class="keyword">true</span>;}
00041 };
00042 
00044 <span class="keyword">namespace </span>internal {
00045 
00047 
00048     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Range, <span class="keyword">typename</span> Body&gt;
<a name="l00049"></a><a class="code" href="a00213.html">00049</a>     <span class="keyword">class </span><a class="code" href="a00213.html">final_sum</a>: <span class="keyword">public</span> <a class="code" href="a00255.html">task</a> {
00050     <span class="keyword">public</span>:
00051         Body body;
00052     <span class="keyword">private</span>:
00053         <a class="code" href="a00185.html">aligned_space&lt;Range,1&gt;</a> range;
00055         Body* stuff_last;
00056     <span class="keyword">public</span>:
00057         <a class="code" href="a00213.html">final_sum</a>( Body&amp; body_ ) :
00058             body(body_,<a class="code" href="a00248.html">split</a>())
00059         {
00060             <a class="code" href="a00311.html#a76">poison_pointer</a>(stuff_last);
00061         }
00062         ~<a class="code" href="a00213.html">final_sum</a>() {
00063             range.begin()-&gt;~Range();
00064         }     
00065         <span class="keywordtype">void</span> finish_construction( <span class="keyword">const</span> Range&amp; range_, Body* stuff_last_ ) {
00066             <span class="keyword">new</span>( range.begin() ) Range(range_);
00067             stuff_last = stuff_last_;
00068         }
00069     <span class="keyword">private</span>:
00070         <span class="comment">/*override*/</span> <a class="code" href="a00255.html">task</a>* execute() {
00071             body( *range.begin(), <a class="code" href="a00212.html">final_scan_tag</a>() );
00072             <span class="keywordflow">if</span>( stuff_last )
00073                 stuff_last-&gt;assign(body);
00074             <span class="keywordflow">return</span> NULL;
00075         }
00076     };       
00077 
00079 
00080     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Range, <span class="keyword">typename</span> Body&gt;
<a name="l00081"></a><a class="code" href="a00254.html">00081</a>     <span class="keyword">class </span><a class="code" href="a00254.html">sum_node</a>: <span class="keyword">public</span> <a class="code" href="a00255.html">task</a> {
00082         <span class="keyword">typedef</span> <a class="code" href="a00213.html">final_sum&lt;Range,Body&gt;</a> <a class="code" href="a00213.html">final_sum_type</a>;
00083     <span class="keyword">public</span>:
00084         <a class="code" href="a00213.html">final_sum_type</a> *incoming; 
00085         <a class="code" href="a00213.html">final_sum_type</a> *body;
00086         Body *stuff_last;
00087     <span class="keyword">private</span>:
00088         <a class="code" href="a00213.html">final_sum_type</a> *left_sum;
00089         <a class="code" href="a00254.html">sum_node</a> *left;
00090         <a class="code" href="a00254.html">sum_node</a> *right;     
00091         <span class="keywordtype">bool</span> left_is_final;
00092         Range range;
00093         <a class="code" href="a00254.html">sum_node</a>( <span class="keyword">const</span> Range range_, <span class="keywordtype">bool</span> left_is_final_ ) : 
00094             left_sum(NULL), 
00095             left(NULL), 
00096             right(NULL), 
00097             left_is_final(left_is_final_), 
00098             range(range_)
00099         {
00100             <span class="comment">// Poison fields that will be set by second pass.</span>
00101             <a class="code" href="a00311.html#a76">poison_pointer</a>(body);
00102             <a class="code" href="a00311.html#a76">poison_pointer</a>(incoming);
00103         }
00104         <a class="code" href="a00255.html">task</a>* create_child( <span class="keyword">const</span> Range&amp; range, <a class="code" href="a00213.html">final_sum_type</a>&amp; f, <a class="code" href="a00254.html">sum_node</a>* n, <a class="code" href="a00213.html">final_sum_type</a>* incoming, Body* stuff_last ) {
00105             <span class="keywordflow">if</span>( !n ) {
00106                 f.<a class="code" href="a00255.html#a8">recycle_as_child_of</a>( *<span class="keyword">this</span> );
00107                 f.<a class="code" href="a00213.html#a2">finish_construction</a>( range, stuff_last );
00108                 <span class="keywordflow">return</span> &amp;f;
00109             } <span class="keywordflow">else</span> {
00110                 n-&gt;<a class="code" href="a00254.html#o1">body</a> = &amp;f;
00111                 n-&gt;<a class="code" href="a00254.html#o0">incoming</a> = incoming;
00112                 n-&gt;<a class="code" href="a00254.html#o2">stuff_last</a> = stuff_last;
00113                 <span class="keywordflow">return</span> n;
00114             }
00115         }
00116         <span class="comment">/*override*/</span> <a class="code" href="a00255.html">task</a>* execute() {
00117             <span class="keywordflow">if</span>( body ) {
00118                 <span class="keywordflow">if</span>( incoming )
00119                     left_sum-&gt;<a class="code" href="a00254.html#o1">body</a>.reverse_join( incoming-&gt;<a class="code" href="a00213.html#o0">body</a> );
00120                 recycle_as_continuation();
00121                 <a class="code" href="a00254.html">sum_node</a>&amp; c = *<span class="keyword">this</span>;
00122                 <a class="code" href="a00255.html">task</a>* b = c.<a class="code" href="a00254.html#d1">create_child</a>(Range(range,<a class="code" href="a00248.html">split</a>()),*left_sum,right,left_sum,stuff_last);
00123                 <a class="code" href="a00255.html">task</a>* a = left_is_final ? NULL : c.<a class="code" href="a00254.html#d1">create_child</a>(range,*body,left,incoming,NULL);
00124                 set_ref_count( (a!=NULL)+(b!=NULL) );
00125                 body = NULL; 
00126                 <span class="keywordflow">if</span>( a ) spawn(*b);
00127                 <span class="keywordflow">else</span> a = b;
00128                 <span class="keywordflow">return</span> a;
00129             } <span class="keywordflow">else</span> {
00130                 <span class="keywordflow">return</span> NULL;
00131             }
00132         }
00133         <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Range_,<span class="keyword">typename</span> Body_,<span class="keyword">typename</span> Partitioner_&gt;
00134         <span class="keyword">friend</span> <span class="keyword">class </span><a class="code" href="a00252.html">start_scan</a>;
00135 
00136         <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Range_,<span class="keyword">typename</span> Body_&gt;
00137         <span class="keyword">friend</span> <span class="keyword">class </span><a class="code" href="a00216.html">finish_scan</a>;
00138     };
00139 
00141 
00142     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Range, <span class="keyword">typename</span> Body&gt;
<a name="l00143"></a><a class="code" href="a00216.html">00143</a>     <span class="keyword">class </span><a class="code" href="a00216.html">finish_scan</a>: <span class="keyword">public</span> <a class="code" href="a00255.html">task</a> {
00144         <span class="keyword">typedef</span> <a class="code" href="a00254.html">sum_node&lt;Range,Body&gt;</a> <a class="code" href="a00254.html">sum_node_type</a>;
00145         <span class="keyword">typedef</span> <a class="code" href="a00213.html">final_sum&lt;Range,Body&gt;</a> <a class="code" href="a00213.html">final_sum_type</a>;
00146         <a class="code" href="a00213.html">final_sum_type</a>** <span class="keyword">const</span> sum;
00147         <a class="code" href="a00254.html">sum_node_type</a>*&amp; return_slot;
00148     <span class="keyword">public</span>:
00149         <a class="code" href="a00213.html">final_sum_type</a>* right_zombie;
00150         <a class="code" href="a00254.html">sum_node_type</a>&amp; result;
00151 
<a name="l00152"></a><a class="code" href="a00216.html#a0">00152</a>         <span class="comment">/*override*/</span> <a class="code" href="a00255.html">task</a>* execute() {
00153             __TBB_ASSERT( result.ref_count()==(result.left!=NULL)+(result.right!=NULL), NULL );
00154             <span class="keywordflow">if</span>( result.left )
00155                 result.left_is_final = <span class="keyword">false</span>;
00156             <span class="keywordflow">if</span>( right_zombie &amp;&amp; sum ) 
00157                 ((*sum)-&gt;body).reverse_join(result.left_sum-&gt;body);
00158             __TBB_ASSERT( !return_slot, NULL );
00159             <span class="keywordflow">if</span>( right_zombie || result.right ) {
00160                 return_slot = &amp;result;
00161             } <span class="keywordflow">else</span> {
00162                 destroy( result );
00163             }
00164             <span class="keywordflow">if</span>( right_zombie &amp;&amp; !sum &amp;&amp; !result.right ) destroy(*right_zombie);
00165             <span class="keywordflow">return</span> NULL;
00166         }
00167 
00168         <a class="code" href="a00216.html">finish_scan</a>( sum_node_type*&amp; return_slot_, final_sum_type** sum_, sum_node_type&amp; result_ ) : 
00169             sum(sum_),
00170             return_slot(return_slot_), 
00171             right_zombie(NULL),
00172             result(result_)
00173         {
00174             __TBB_ASSERT( !return_slot, NULL );
00175         }
00176     };
00177 
00179 
00180     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Range, <span class="keyword">typename</span> Body, <span class="keyword">typename</span> Partitioner=simple_partitioner&gt;
<a name="l00181"></a><a class="code" href="a00252.html">00181</a>     <span class="keyword">class </span><a class="code" href="a00252.html">start_scan</a>: <span class="keyword">public</span> <a class="code" href="a00255.html">task</a> {
00182         <span class="keyword">typedef</span> <a class="code" href="a00254.html">sum_node&lt;Range,Body&gt;</a> <a class="code" href="a00254.html">sum_node_type</a>;
00183         <span class="keyword">typedef</span> <a class="code" href="a00213.html">final_sum&lt;Range,Body&gt;</a> <a class="code" href="a00213.html">final_sum_type</a>;
00184         <a class="code" href="a00213.html">final_sum_type</a>* body;
00186         <a class="code" href="a00213.html">final_sum_type</a>** sum; 
00187         <a class="code" href="a00254.html">sum_node_type</a>** return_slot;
00189         <a class="code" href="a00254.html">sum_node_type</a>* parent_sum;
00190         <span class="keywordtype">bool</span> is_final;
00191         <span class="keywordtype">bool</span> is_right_child;
00192         Range range;
00193         <span class="keyword">typename</span> Partitioner::partition_type partition;
00194         <span class="comment">/*override*/</span> <a class="code" href="a00255.html">task</a>* execute();
00195     <span class="keyword">public</span>:
00196         <a class="code" href="a00252.html">start_scan</a>( <a class="code" href="a00254.html">sum_node_type</a>*&amp; return_slot_, <a class="code" href="a00252.html">start_scan</a>&amp; parent, <a class="code" href="a00254.html">sum_node_type</a>* parent_sum_ ) :
00197             body(parent.<a class="code" href="a00252.html#r0">body</a>),
00198             sum(parent.<a class="code" href="a00252.html#r1">sum</a>),
00199             return_slot(&amp;return_slot_),
00200             parent_sum(parent_sum_),
00201             is_final(parent.<a class="code" href="a00252.html#r4">is_final</a>),
00202             is_right_child(<span class="keyword">false</span>),
00203             range(parent.<a class="code" href="a00252.html#r6">range</a>,<a class="code" href="a00248.html">split</a>()),
00204             partition(parent.<a class="code" href="a00252.html#r7">partition</a>,<a class="code" href="a00248.html">split</a>())
00205         {
00206             __TBB_ASSERT( !*return_slot, NULL );
00207         }
00208 
00209         <a class="code" href="a00252.html">start_scan</a>( <a class="code" href="a00254.html">sum_node_type</a>*&amp; return_slot_, <span class="keyword">const</span> Range&amp; range_, <a class="code" href="a00213.html">final_sum_type</a>&amp; body_, <span class="keyword">const</span> Partitioner&amp; partitioner_) :
00210             body(&amp;body_),
00211             sum(NULL),
00212             return_slot(&amp;return_slot_),
00213             parent_sum(NULL),
00214             is_final(<span class="keyword">true</span>),
00215             is_right_child(<span class="keyword">false</span>),
00216             range(range_),
00217             partition(partitioner_)
00218         {
00219             __TBB_ASSERT( !*return_slot, NULL );
00220         }
00221 
00222         <span class="keyword">static</span> <span class="keywordtype">void</span> run(  <span class="keyword">const</span> Range&amp; range, Body&amp; body, <span class="keyword">const</span> Partitioner&amp; partitioner ) {
00223             <span class="keywordflow">if</span>( !range.empty() ) {
00224                 <span class="keyword">typedef</span> <a class="code" href="a00252.html">internal::start_scan&lt;Range,Body,Partitioner&gt;</a> start_pass1_type;
00225                 <a class="code" href="a00254.html">internal::sum_node&lt;Range,Body&gt;</a>* root = NULL;
00226                 <span class="keyword">typedef</span> <a class="code" href="a00213.html">internal::final_sum&lt;Range,Body&gt;</a> <a class="code" href="a00213.html">final_sum_type</a>;
00227                 final_sum_type* temp_body = <span class="keyword">new</span>(task::allocate_root()) final_sum_type( body );
00228                 start_pass1_type&amp; pass1 = *<span class="keyword">new</span>(task::allocate_root()) start_pass1_type(
00229                     <span class="comment">/*return_slot=*/</span>root,
00230                     range,
00231                     *temp_body,
00232                     partitioner );
00233                 task::spawn_root_and_wait( pass1 );
00234                 <span class="keywordflow">if</span>( root ) {
00235                     root-&gt;<a class="code" href="a00254.html#o1">body</a> = temp_body;
00236                     root-&gt;<a class="code" href="a00254.html#o0">incoming</a> = NULL;
00237                     root-&gt;<a class="code" href="a00254.html#o2">stuff_last</a> = &amp;body;
00238                     task::spawn_root_and_wait( *root );
00239                 } <span class="keywordflow">else</span> {
00240                     body.assign(temp_body-&gt;<a class="code" href="a00213.html#o0">body</a>);
00241                     temp_body-&gt;<a class="code" href="a00213.html#a2">finish_construction</a>( range, NULL );
00242                     temp_body-&gt;<a class="code" href="a00255.html#a5">destroy</a>(*temp_body);
00243                 }
00244             }
00245         }
00246     };
00247 
00248     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Range, <span class="keyword">typename</span> Body, <span class="keyword">typename</span> Partitioner&gt;
00249     <a class="code" href="a00255.html">task</a>* <a class="code" href="a00252.html">start_scan&lt;Range,Body,Partitioner&gt;::execute</a>() {
00250         <span class="keyword">typedef</span> <a class="code" href="a00216.html">internal::finish_scan&lt;Range,Body&gt;</a> finish_pass1_type;
00251         finish_pass1_type* p = parent_sum ? static_cast&lt;finish_pass1_type*&gt;( <a class="code" href="a00255.html#a19">parent</a>() ) : NULL;
00252         <span class="comment">// Inspecting p-&gt;result.left_sum would ordinarily be a race condition.</span>
00253         <span class="comment">// But we inspect it only if we are not a stolen task, in which case we</span>
00254         <span class="comment">// know that task assigning to p-&gt;result.left_sum has completed.</span>
00255         <span class="keywordtype">bool</span> treat_as_stolen = is_right_child &amp;&amp; (<a class="code" href="a00255.html#a20">is_stolen_task</a>() || body!=p-&gt;result.left_sum);
00256         <span class="keywordflow">if</span>( treat_as_stolen ) {
00257             <span class="comment">// Invocation is for right child that has been really stolen or needs to be virtually stolen</span>
00258             p-&gt;right_zombie = body = <span class="keyword">new</span>( <a class="code" href="a00255.html#e0">allocate_root</a>() ) final_sum_type(body-&gt;<a class="code" href="a00213.html#o0">body</a>);
00259             is_final = <span class="keyword">false</span>;
00260         }
00261         <a class="code" href="a00255.html">task</a>* next_task = NULL;
00262         <span class="keywordflow">if</span>( (is_right_child &amp;&amp; !treat_as_stolen) || !range.is_divisible() || partition.should_execute_range(*<span class="keyword">this</span>) ) {
00263             <span class="keywordflow">if</span>( is_final )
00264                 (body-&gt;<a class="code" href="a00213.html#o0">body</a>)( range, <a class="code" href="a00212.html">final_scan_tag</a>() );
00265             <span class="keywordflow">else</span> <span class="keywordflow">if</span>( sum )
00266                 (body-&gt;<a class="code" href="a00213.html#o0">body</a>)( range, <a class="code" href="a00232.html">pre_scan_tag</a>() );
00267             <span class="keywordflow">if</span>( sum ) 
00268                 *sum = body;
00269             __TBB_ASSERT( !*return_slot, NULL );
00270         } <span class="keywordflow">else</span> {
00271             sum_node_type* result;
00272             <span class="keywordflow">if</span>( parent_sum ) 
00273                 result = <span class="keyword">new</span>(<a class="code" href="a00255.html#a4">allocate_additional_child_of</a>(*parent_sum)) sum_node_type(range,<span class="comment">/*left_is_final=*/</span>is_final);
00274             <span class="keywordflow">else</span>
00275                 result = <span class="keyword">new</span>(task::allocate_root()) sum_node_type(range,<span class="comment">/*left_is_final=*/</span>is_final);
00276             finish_pass1_type&amp; c = *<span class="keyword">new</span>( <a class="code" href="a00255.html#a2">allocate_continuation</a>()) finish_pass1_type(*return_slot,sum,*result);
00277             <span class="comment">// Split off right child</span>
00278             start_scan&amp; b = *<span class="keyword">new</span>( c.allocate_child() ) start_scan( <span class="comment">/*return_slot=*/</span>result-&gt;right, *<span class="keyword">this</span>, result );
00279             b.is_right_child = <span class="keyword">true</span>;    
00280             <span class="comment">// Left child is recycling of *this.  Must recycle this before spawning b, </span>
00281             <span class="comment">// otherwise b might complete and decrement c.ref_count() to zero, which</span>
00282             <span class="comment">// would cause c.execute() to run prematurely.</span>
00283             <a class="code" href="a00255.html#a8">recycle_as_child_of</a>(c);
00284             c.<a class="code" href="a00255.html#a13">set_ref_count</a>(2);
00285             c.<a class="code" href="a00255.html#a14">spawn</a>(b);
00286             sum = &amp;result-&gt;left_sum;
00287             return_slot = &amp;result-&gt;<a class="code" href="a00254.html#r1">left</a>;
00288             is_right_child = <span class="keyword">false</span>;
00289             next_task = <span class="keyword">this</span>;
00290             parent_sum = result; 
00291             __TBB_ASSERT( !*return_slot, NULL );
00292         }
00293         <span class="keywordflow">return</span> next_task;
00294     } 
00295 } <span class="comment">// namespace internal</span>
00297 <span class="comment"></span>
00298 <span class="comment">// Requirements on Range concept are documented in blocked_range.h</span>
00299 
00317 
00319 
00320 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Range, <span class="keyword">typename</span> Body&gt;
<a name="l00321"></a><a class="code" href="a00313.html#ga23">00321</a> <span class="keywordtype">void</span> <a class="code" href="a00313.html#ga23">parallel_scan</a>( <span class="keyword">const</span> Range&amp; range, Body&amp; body, <span class="keyword">const</span> simple_partitioner&amp; partitioner=simple_partitioner() ) {
00322     internal::start_scan&lt;Range,Body,simple_partitioner&gt;::run(range,body,partitioner);
00323 }
00324 
00326 
00327 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Range, <span class="keyword">typename</span> Body&gt;
<a name="l00328"></a><a class="code" href="a00313.html#ga24">00328</a> <span class="keywordtype">void</span> <a class="code" href="a00313.html#ga23">parallel_scan</a>( <span class="keyword">const</span> Range&amp; range, Body&amp; body, <span class="keyword">const</span> auto_partitioner&amp; partitioner ) {
00329     internal::start_scan&lt;Range,Body,auto_partitioner&gt;::run(range,body,partitioner);
00330 }
00332 
00333 } <span class="comment">// namespace tbb</span>
00334 
00335 <span class="preprocessor">#endif </span><span class="comment">/* __TBB_parallel_scan_H */</span>
00336 
</pre></div><hr>
<p></p>
Copyright &copy; 2005-2008 Intel Corporation.  All Rights Reserved.
<p></p>
Intel, Pentium, Intel Xeon, Itanium, Intel XScale and VTune are
registered trademarks or trademarks of Intel Corporation or its
subsidiaries in the United States and other countries.
<p></p>
* Other names and brands may be claimed as the property of others.
