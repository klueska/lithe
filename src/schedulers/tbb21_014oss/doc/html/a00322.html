<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>concurrent_queue.h Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.9.1 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="modules.html">Modules</a> | <a class="qindex" href="namespaces.html">Namespace List</a> | <a class="qindex" href="hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="annotated.html">Class&nbsp;List</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="namespacemembers.html">Namespace&nbsp;Members</a> | <a class="qindex" href="functions.html">Class&nbsp;Members</a> | <a class="qindex" href="globals.html">File&nbsp;Members</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a></div>
<h1>concurrent_queue.h</h1><div class="fragment"><pre class="fragment">00001 <span class="comment">/*</span>
00002 <span class="comment">    Copyright 2005-2008 Intel Corporation.  All Rights Reserved.</span>
00003 <span class="comment"></span>
00004 <span class="comment">    The source code contained or described herein and all documents related</span>
00005 <span class="comment">    to the source code ("Material") are owned by Intel Corporation or its</span>
00006 <span class="comment">    suppliers or licensors.  Title to the Material remains with Intel</span>
00007 <span class="comment">    Corporation or its suppliers and licensors.  The Material is protected</span>
00008 <span class="comment">    by worldwide copyright laws and treaty provisions.  No part of the</span>
00009 <span class="comment">    Material may be used, copied, reproduced, modified, published, uploaded,</span>
00010 <span class="comment">    posted, transmitted, distributed, or disclosed in any way without</span>
00011 <span class="comment">    Intel's prior express written permission.</span>
00012 <span class="comment"></span>
00013 <span class="comment">    No license under any patent, copyright, trade secret or other</span>
00014 <span class="comment">    intellectual property right is granted to or conferred upon you by</span>
00015 <span class="comment">    disclosure or delivery of the Materials, either expressly, by</span>
00016 <span class="comment">    implication, inducement, estoppel or otherwise.  Any license under such</span>
00017 <span class="comment">    intellectual property rights must be express and approved by Intel in</span>
00018 <span class="comment">    writing.</span>
00019 <span class="comment">*/</span>
00020 
00021 <span class="preprocessor">#ifndef __TBB_concurrent_queue_H</span>
00022 <span class="preprocessor"></span><span class="preprocessor">#define __TBB_concurrent_queue_H</span>
00023 <span class="preprocessor"></span>
00024 <span class="preprocessor">#include "tbb_stddef.h"</span>
00025 <span class="preprocessor">#include "cache_aligned_allocator.h"</span>
00026 <span class="preprocessor">#include &lt;iterator&gt;</span>
00027 <span class="preprocessor">#include &lt;new&gt;</span>
00028 
00029 <span class="keyword">namespace </span>tbb {
00030 
00031 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">class</span> A = cache_aligned_allocator&lt;T&gt; &gt; 
00032 <span class="keyword">class </span>concurrent_queue;
00033 
00035 <span class="keyword">namespace </span>internal {
00036 
00037 <span class="keyword">class </span>concurrent_queue_rep;
00038 <span class="keyword">class </span>concurrent_queue_iterator_rep;
00039 <span class="keyword">class </span>concurrent_queue_iterator_base_v3;
00040 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Container, <span class="keyword">typename</span> Value&gt; <span class="keyword">class </span>concurrent_queue_iterator;
00041 
00043 
<a name="l00045"></a><a class="code" href="a00200.html">00045</a> <span class="keyword">class </span><a class="code" href="a00200.html">concurrent_queue_base_v3</a>: <a class="code" href="a00225.html">no_copy</a> {
00047     concurrent_queue_rep* my_rep;
00048 
00049     <span class="keyword">friend</span> <span class="keyword">class </span>concurrent_queue_rep;
00050     <span class="keyword">friend</span> <span class="keyword">struct </span>micro_queue;
00051     <span class="keyword">friend</span> <span class="keyword">class </span>micro_queue_pop_finalizer;
00052     <span class="keyword">friend</span> <span class="keyword">class </span>concurrent_queue_iterator_rep;
00053     <span class="keyword">friend</span> <span class="keyword">class </span><a class="code" href="a00203.html">concurrent_queue_iterator_base_v3</a>;
00054 <span class="keyword">protected</span>:
<a name="l00056"></a><a class="code" href="a00201.html">00056</a>     <span class="keyword">struct </span><a class="code" href="a00201.html">page</a> {
00057         <a class="code" href="a00201.html">page</a>* next;
00058         <a class="code" href="a00311.html#a21">uintptr</a> mask; 
00059     };
00060 
<a name="l00062"></a><a class="code" href="a00200.html#p0">00062</a>     ptrdiff_t my_capacity;
00063    
<a name="l00065"></a><a class="code" href="a00200.html#p1">00065</a>     size_t items_per_page;
00066 
<a name="l00068"></a><a class="code" href="a00200.html#p2">00068</a>     size_t item_size;
00069 
00070 <span class="keyword">private</span>:
00071     <span class="keyword">virtual</span> <span class="keywordtype">void</span> copy_item( <a class="code" href="a00201.html">page</a>&amp; dst, size_t index, <span class="keyword">const</span> <span class="keywordtype">void</span>* src ) = 0;
00072     <span class="keyword">virtual</span> <span class="keywordtype">void</span> assign_and_destroy_item( <span class="keywordtype">void</span>* dst, <a class="code" href="a00201.html">page</a>&amp; src, size_t index ) = 0;
00073 <span class="keyword">protected</span>:
00074     __TBB_EXPORTED_METHOD <a class="code" href="a00200.html">concurrent_queue_base_v3</a>( size_t item_size );
00075     <span class="keyword">virtual</span> __TBB_EXPORTED_METHOD ~<a class="code" href="a00200.html">concurrent_queue_base_v3</a>();
00076 
00078     <span class="keywordtype">void</span> __TBB_EXPORTED_METHOD internal_push( <span class="keyword">const</span> <span class="keywordtype">void</span>* src );
00079 
00081     <span class="keywordtype">void</span> __TBB_EXPORTED_METHOD internal_pop( <span class="keywordtype">void</span>* dst );
00082 
00084     <span class="keywordtype">bool</span> __TBB_EXPORTED_METHOD internal_push_if_not_full( <span class="keyword">const</span> <span class="keywordtype">void</span>* src );
00085 
00087 
00088     <span class="keywordtype">bool</span> __TBB_EXPORTED_METHOD internal_pop_if_present( <span class="keywordtype">void</span>* dst );
00089 
00091     ptrdiff_t __TBB_EXPORTED_METHOD internal_size() <span class="keyword">const</span>;
00092 
00094     <span class="keywordtype">void</span> __TBB_EXPORTED_METHOD internal_set_capacity( ptrdiff_t capacity, size_t element_size );
00095 
00097     <span class="keyword">virtual</span> <a class="code" href="a00201.html">page</a> *allocate_page() = 0;
00098 
00100     <span class="keyword">virtual</span> <span class="keywordtype">void</span> deallocate_page( <a class="code" href="a00201.html">page</a> *p ) = 0;
00101 
00103     <span class="comment">/* note that the name may be misleading, but it remains so due to a historical accident. */</span>
00104     <span class="keywordtype">void</span> __TBB_EXPORTED_METHOD internal_finish_clear() ;
00105 
00107     <span class="keywordtype">void</span> __TBB_EXPORTED_METHOD internal_throw_exception() <span class="keyword">const</span>;
00108 
00110     <span class="keywordtype">void</span> __TBB_EXPORTED_METHOD assign( <span class="keyword">const</span> <a class="code" href="a00200.html">concurrent_queue_base_v3</a>&amp; src ) ;
00111 
00112 <span class="keyword">private</span>:
00113     <span class="keyword">virtual</span> <span class="keywordtype">void</span> copy_item( <a class="code" href="a00201.html">page</a>&amp; dst, size_t dindex, <span class="keyword">const</span> <a class="code" href="a00201.html">page</a>&amp; src, size_t sindex ) = 0;
00114 };
00115 
00116 <span class="keyword">typedef</span> <a class="code" href="a00200.html">concurrent_queue_base_v3</a> <a class="code" href="a00200.html">concurrent_queue_base</a> ;
00117 
00119 
<a name="l00120"></a><a class="code" href="a00203.html">00120</a> <span class="keyword">class </span><a class="code" href="a00203.html">concurrent_queue_iterator_base_v3</a> {
00122 
00123     concurrent_queue_iterator_rep* my_rep;
00124 
00125     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> C, <span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;
00126     <span class="keyword">friend</span> <span class="keywordtype">bool</span> operator==( <span class="keyword">const</span> <a class="code" href="a00202.html">concurrent_queue_iterator&lt;C,T&gt;</a>&amp; i, <span class="keyword">const</span> <a class="code" href="a00202.html">concurrent_queue_iterator&lt;C,U&gt;</a>&amp; j );
00127 
00128     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> C, <span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;
00129     <span class="keyword">friend</span> <span class="keywordtype">bool</span> operator!=( <span class="keyword">const</span> <a class="code" href="a00202.html">concurrent_queue_iterator&lt;C,T&gt;</a>&amp; i, <span class="keyword">const</span> <a class="code" href="a00202.html">concurrent_queue_iterator&lt;C,U&gt;</a>&amp; j );
00130 <span class="keyword">protected</span>:
<a name="l00132"></a><a class="code" href="a00203.html#p0">00132</a>     <span class="keyword">mutable</span> <span class="keywordtype">void</span>* my_item;
00133 
<a name="l00135"></a><a class="code" href="a00203.html#b0">00135</a>     <a class="code" href="a00203.html">concurrent_queue_iterator_base_v3</a>() : my_rep(NULL), my_item(NULL) {}
00136 
<a name="l00138"></a><a class="code" href="a00203.html#b1">00138</a>     <a class="code" href="a00203.html">concurrent_queue_iterator_base_v3</a>( <span class="keyword">const</span> <a class="code" href="a00203.html">concurrent_queue_iterator_base_v3</a>&amp; i ) : my_rep(NULL), my_item(NULL) {
00139         assign(i);
00140     }
00141 
00143     __TBB_EXPORTED_METHOD <a class="code" href="a00203.html">concurrent_queue_iterator_base_v3</a>( <span class="keyword">const</span> concurrent_queue_base&amp; queue );
00144 
00146     <span class="keywordtype">void</span> __TBB_EXPORTED_METHOD assign( <span class="keyword">const</span> <a class="code" href="a00203.html">concurrent_queue_iterator_base_v3</a>&amp; i );
00147 
00149     <span class="keywordtype">void</span> __TBB_EXPORTED_METHOD advance();
00150 
00152     __TBB_EXPORTED_METHOD ~<a class="code" href="a00203.html">concurrent_queue_iterator_base_v3</a>();
00153 };
00154 
00155 <span class="keyword">typedef</span> concurrent_queue_iterator_base_v3 concurrent_queue_iterator_base;
00156 
00158 
00160 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Container, <span class="keyword">typename</span> Value&gt;
<a name="l00161"></a><a class="code" href="a00202.html">00161</a> <span class="keyword">class </span><a class="code" href="a00202.html">concurrent_queue_iterator</a>: <span class="keyword">public</span> concurrent_queue_iterator_base,
00162         <span class="keyword">public</span> std::iterator&lt;std::forward_iterator_tag,Value&gt; {
00163 <span class="preprocessor">#if !defined(_MSC_VER) || defined(__INTEL_COMPILER)</span>
00164 <span class="preprocessor"></span>    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">class</span> A&gt;
00165     <span class="keyword">friend</span> class ::tbb::concurrent_queue;
00166 <span class="preprocessor">#else</span>
00167 <span class="preprocessor"></span><span class="keyword">public</span>: <span class="comment">// workaround for MSVC</span>
00168 <span class="preprocessor">#endif </span>
00169 <span class="preprocessor"></span>
<a name="l00170"></a><a class="code" href="a00202.html#a0">00170</a>     <a class="code" href="a00202.html">concurrent_queue_iterator</a>( <span class="keyword">const</span> concurrent_queue_base&amp; queue ) :
00171         <a class="code" href="a00203.html">concurrent_queue_iterator_base_v3</a>(queue)
00172     {
00173     }
00174 <span class="keyword">public</span>:
00175     <a class="code" href="a00202.html">concurrent_queue_iterator</a>() {}
00176 
<a name="l00179"></a><a class="code" href="a00202.html#a2">00179</a>     <a class="code" href="a00202.html">concurrent_queue_iterator</a>( <span class="keyword">const</span> <a class="code" href="a00202.html">concurrent_queue_iterator&lt;Container,typename Container::value_type&gt;</a>&amp; other ) :
00180         <a class="code" href="a00203.html">concurrent_queue_iterator_base_v3</a>(other)
00181     {}
00182 
<a name="l00184"></a><a class="code" href="a00202.html#a3">00184</a>     <a class="code" href="a00202.html">concurrent_queue_iterator</a>&amp; operator=( <span class="keyword">const</span> <a class="code" href="a00202.html">concurrent_queue_iterator</a>&amp; other ) {
00185         assign(other);
00186         <span class="keywordflow">return</span> *<span class="keyword">this</span>;
00187     }
00188 
<a name="l00190"></a><a class="code" href="a00202.html#a4">00190</a>     Value&amp; operator*()<span class="keyword"> const </span>{
00191         <span class="keywordflow">return</span> *static_cast&lt;Value*&gt;(my_item);
00192     }
00193 
00194     Value* operator-&gt;()<span class="keyword"> const </span>{<span class="keywordflow">return</span> &amp;operator*();}
00195 
<a name="l00197"></a><a class="code" href="a00202.html#a6">00197</a>     <a class="code" href="a00202.html">concurrent_queue_iterator</a>&amp; operator++() {
00198         advance();
00199         <span class="keywordflow">return</span> *<span class="keyword">this</span>;
00200     }
00201 
<a name="l00203"></a><a class="code" href="a00202.html#a7">00203</a>     Value* operator++(<span class="keywordtype">int</span>) {
00204         Value* result = &amp;operator*();
00205         operator++();
00206         <span class="keywordflow">return</span> result;
00207     }
00208 }; <span class="comment">// concurrent_queue_iterator</span>
00209 
00210 
00211 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> C, <span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;
00212 <span class="keywordtype">bool</span> operator==( <span class="keyword">const</span> concurrent_queue_iterator&lt;C,T&gt;&amp; i, <span class="keyword">const</span> concurrent_queue_iterator&lt;C,U&gt;&amp; j ) {
00213     <span class="keywordflow">return</span> i.<a class="code" href="a00203.html#p0">my_item</a>==j.<a class="code" href="a00203.html#p0">my_item</a>;
00214 }
00215 
00216 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> C, <span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;
00217 <span class="keywordtype">bool</span> operator!=( <span class="keyword">const</span> concurrent_queue_iterator&lt;C,T&gt;&amp; i, <span class="keyword">const</span> concurrent_queue_iterator&lt;C,U&gt;&amp; j ) {
00218     <span class="keywordflow">return</span> i.<a class="code" href="a00203.html#p0">my_item</a>!=j.<a class="code" href="a00203.html#p0">my_item</a>;
00219 }
00220 
00221 } <span class="comment">// namespace internal;</span>
00222 
00224 
00226 
00229 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">class</span> A&gt;
<a name="l00230"></a><a class="code" href="a00199.html">00230</a> <span class="keyword">class </span><a class="code" href="a00199.html">concurrent_queue</a>: <span class="keyword">public</span> internal::concurrent_queue_base_v3 {
00231     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Container, <span class="keyword">typename</span> Value&gt; <span class="keyword">friend</span> <span class="keyword">class </span><a class="code" href="a00202.html">internal::concurrent_queue_iterator</a>;
00232 
00234     <span class="keyword">typedef</span> <span class="keyword">typename</span> A::template rebind&lt;char&gt;::other page_allocator_type;
00235     page_allocator_type my_allocator;
00236 
00238     <span class="keyword">class </span>destroyer: internal::no_copy {
00239         T&amp; my_value;
00240     <span class="keyword">public</span>:
00241         destroyer( T&amp; value ) : my_value(value) {}
00242         ~destroyer() {my_value.~T();}          
00243     };
00244 
00245     T&amp; get_ref( page&amp; page, size_t index ) {
00246         __TBB_ASSERT( index&lt;items_per_page, NULL );
00247         <span class="keywordflow">return</span> static_cast&lt;T*&gt;(static_cast&lt;void*&gt;(&amp;page+1))[index];
00248     }
00249 
00250     <span class="comment">/*override*/</span> <span class="keyword">virtual</span> <span class="keywordtype">void</span> copy_item( page&amp; dst, size_t index, <span class="keyword">const</span> <span class="keywordtype">void</span>* src ) {
00251         <span class="keyword">new</span>( &amp;get_ref(dst,index) ) T(*static_cast&lt;const T*&gt;(src)); 
00252     }
00253 
00254     <span class="comment">/*override*/</span> <span class="keyword">virtual</span> <span class="keywordtype">void</span> copy_item( page&amp; dst, size_t dindex, <span class="keyword">const</span> page&amp; src, size_t sindex ) {
00255         <span class="keyword">new</span>( &amp;get_ref(dst,dindex) ) T( static_cast&lt;const T*&gt;(static_cast&lt;const void*&gt;(&amp;src+1))[sindex] );
00256     }
00257 
00258     <span class="comment">/*override*/</span> <span class="keyword">virtual</span> <span class="keywordtype">void</span> assign_and_destroy_item( <span class="keywordtype">void</span>* dst, page&amp; src, size_t index ) {
00259         T&amp; from = get_ref(src,index);
00260         destroyer d(from);
00261         *static_cast&lt;T*&gt;(dst) = from;
00262     }
00263 
00264     <span class="comment">/*overide*/</span> <span class="keyword">virtual</span> page *allocate_page() {
00265         size_t n = <span class="keyword">sizeof</span>(page) + items_per_page*item_size;
00266         page *p = reinterpret_cast&lt;page*&gt;(my_allocator.allocate( n ));
00267         <span class="keywordflow">if</span>( !p ) internal_throw_exception(); 
00268         <span class="keywordflow">return</span> p;
00269     }
00270 
00271     <span class="comment">/*override*/</span> <span class="keyword">virtual</span> <span class="keywordtype">void</span> deallocate_page( page *p ) {
00272         size_t n = <span class="keyword">sizeof</span>(page) + items_per_page*item_size;
00273         my_allocator.deallocate( reinterpret_cast&lt;char*&gt;(p), n );
00274     }
00275 
00276 <span class="keyword">public</span>:
<a name="l00278"></a><a class="code" href="a00199.html#w0">00278</a>     <span class="keyword">typedef</span> T value_type;
00279 
<a name="l00281"></a><a class="code" href="a00199.html#w1">00281</a>     <span class="keyword">typedef</span> A allocator_type;
00282 
<a name="l00284"></a><a class="code" href="a00199.html#w2">00284</a>     <span class="keyword">typedef</span> T&amp; reference;
00285 
<a name="l00287"></a><a class="code" href="a00199.html#w3">00287</a>     <span class="keyword">typedef</span> <span class="keyword">const</span> T&amp; const_reference;
00288 
00290 
<a name="l00292"></a><a class="code" href="a00199.html#w4">00292</a>     <span class="keyword">typedef</span> std::ptrdiff_t size_type;
00293 
<a name="l00295"></a><a class="code" href="a00199.html#w5">00295</a>     <span class="keyword">typedef</span> std::ptrdiff_t difference_type;
00296 
<a name="l00298"></a><a class="code" href="a00199.html#a0">00298</a>     <span class="keyword">explicit</span> <a class="code" href="a00199.html">concurrent_queue</a>(<span class="keyword">const</span> allocator_type  &amp;a = allocator_type()) : 
00299         concurrent_queue_base_v3( sizeof(T) ), my_allocator( a )
00300     {
00301     }
00302 
00304     ~<a class="code" href="a00199.html">concurrent_queue</a>();
00305 
<a name="l00307"></a><a class="code" href="a00199.html#a2">00307</a>     <span class="keywordtype">void</span> push( <span class="keyword">const</span> T&amp; source ) {
00308         internal_push( &amp;source );
00309     }
00310 
00312 
<a name="l00313"></a><a class="code" href="a00199.html#a3">00313</a>     <span class="keywordtype">void</span> pop( T&amp; destination ) {
00314         internal_pop( &amp;destination );
00315     }
00316 
00318 
<a name="l00320"></a><a class="code" href="a00199.html#a4">00320</a>     <span class="keywordtype">bool</span> push_if_not_full( <span class="keyword">const</span> T&amp; source ) {
00321         <span class="keywordflow">return</span> internal_push_if_not_full( &amp;source );
00322     }
00323 
00325 
<a name="l00327"></a><a class="code" href="a00199.html#a5">00327</a>     <span class="keywordtype">bool</span> pop_if_present( T&amp; destination ) {
00328         <span class="keywordflow">return</span> internal_pop_if_present( &amp;destination );
00329     }
00330 
00332 
<a name="l00335"></a><a class="code" href="a00199.html#a6">00335</a>     size_type size()<span class="keyword"> const </span>{<span class="keywordflow">return</span> internal_size();}
00336 
<a name="l00338"></a><a class="code" href="a00199.html#a7">00338</a>     <span class="keywordtype">bool</span> empty()<span class="keyword"> const </span>{<span class="keywordflow">return</span> size()&lt;=0;}
00339 
<a name="l00341"></a><a class="code" href="a00199.html#a8">00341</a>     size_type capacity()<span class="keyword"> const </span>{
00342         <span class="keywordflow">return</span> my_capacity;
00343     }
00344 
00346 
<a name="l00348"></a><a class="code" href="a00199.html#a9">00348</a>     <span class="keywordtype">void</span> set_capacity( size_type capacity ) {
00349         internal_set_capacity( capacity, <span class="keyword">sizeof</span>(T) );
00350     }
00351 
<a name="l00353"></a><a class="code" href="a00199.html#a10">00353</a>     allocator_type get_allocator()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> this-&gt;my_allocator; }
00354 
00356     <span class="keywordtype">void</span> clear() ;
00357 
00358     <span class="keyword">typedef</span> <a class="code" href="a00202.html">internal::concurrent_queue_iterator&lt;concurrent_queue,T&gt;</a> iterator;
00359     <span class="keyword">typedef</span> <a class="code" href="a00202.html">internal::concurrent_queue_iterator&lt;concurrent_queue,const T&gt;</a> const_iterator;
00360 
00361     <span class="comment">//------------------------------------------------------------------------</span>
00362     <span class="comment">// The iterators are intended only for debugging.  They are slow and not thread safe.</span>
00363     <span class="comment">//------------------------------------------------------------------------</span>
00364     iterator begin() {<span class="keywordflow">return</span> iterator(*<span class="keyword">this</span>);}
00365     iterator end() {<span class="keywordflow">return</span> iterator();}
00366     const_iterator begin()<span class="keyword"> const </span>{<span class="keywordflow">return</span> const_iterator(*<span class="keyword">this</span>);}
00367     const_iterator end()<span class="keyword"> const </span>{<span class="keywordflow">return</span> const_iterator();}
00368     
<a name="l00370"></a><a class="code" href="a00199.html#a16">00370</a>     <a class="code" href="a00199.html">concurrent_queue</a>( <span class="keyword">const</span> <a class="code" href="a00199.html">concurrent_queue</a>&amp; src, <span class="keyword">const</span> allocator_type &amp;a = allocator_type()) : 
00371         concurrent_queue_base_v3( sizeof(T) ), my_allocator( a )
00372     {
00373         assign( src );
00374     }
00375 
00377     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> InputIterator&gt;
<a name="l00378"></a><a class="code" href="a00199.html#a17">00378</a>     <a class="code" href="a00199.html">concurrent_queue</a>( InputIterator begin, InputIterator end, <span class="keyword">const</span> allocator_type &amp;a = allocator_type()) :
00379         concurrent_queue_base_v3( sizeof(T) ), my_allocator( a )
00380     {
00381         <span class="keywordflow">for</span>( ; begin != end; ++begin )
00382             internal_push_if_not_full(&amp;*begin);
00383     }
00384 }; 
00385 
00386 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">class</span> A&gt;
<a name="l00387"></a><a class="code" href="a00199.html#a1">00387</a> <a class="code" href="a00199.html">concurrent_queue&lt;T,A&gt;::~concurrent_queue</a>() {
00388     <a class="code" href="a00199.html#a11">clear</a>();
00389     <a class="code" href="a00200.html#b10">internal_finish_clear</a>();
00390 }
00391 
00392 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">class</span> A&gt;
<a name="l00393"></a><a class="code" href="a00199.html#a11">00393</a> <span class="keywordtype">void</span> <a class="code" href="a00199.html">concurrent_queue&lt;T,A&gt;::clear</a>() {
00394     <span class="keywordflow">while</span>( !<a class="code" href="a00199.html#a7">empty</a>() ) {
00395         T value;
00396         <a class="code" href="a00200.html#b5">internal_pop_if_present</a>(&amp;value);
00397     }
00398 }
00399 
00400 } <span class="comment">// namespace tbb</span>
00401 
00402 <span class="preprocessor">#endif </span><span class="comment">/* __TBB_concurrent_queue_H */</span>
</pre></div><hr>
<p></p>
Copyright &copy; 2005-2008 Intel Corporation.  All Rights Reserved.
<p></p>
Intel, Pentium, Intel Xeon, Itanium, Intel XScale and VTune are
registered trademarks or trademarks of Intel Corporation or its
subsidiaries in the United States and other countries.
<p></p>
* Other names and brands may be claimed as the property of others.
