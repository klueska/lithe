<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>tbb_machine.h Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.9.1 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="modules.html">Modules</a> | <a class="qindex" href="namespaces.html">Namespace List</a> | <a class="qindex" href="hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="annotated.html">Class&nbsp;List</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="namespacemembers.html">Namespace&nbsp;Members</a> | <a class="qindex" href="functions.html">Class&nbsp;Members</a> | <a class="qindex" href="globals.html">File&nbsp;Members</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a></div>
<h1>tbb_machine.h</h1><div class="fragment"><pre class="fragment">00001 <span class="comment">/*</span>
00002 <span class="comment">    Copyright 2005-2008 Intel Corporation.  All Rights Reserved.</span>
00003 <span class="comment"></span>
00004 <span class="comment">    The source code contained or described herein and all documents related</span>
00005 <span class="comment">    to the source code ("Material") are owned by Intel Corporation or its</span>
00006 <span class="comment">    suppliers or licensors.  Title to the Material remains with Intel</span>
00007 <span class="comment">    Corporation or its suppliers and licensors.  The Material is protected</span>
00008 <span class="comment">    by worldwide copyright laws and treaty provisions.  No part of the</span>
00009 <span class="comment">    Material may be used, copied, reproduced, modified, published, uploaded,</span>
00010 <span class="comment">    posted, transmitted, distributed, or disclosed in any way without</span>
00011 <span class="comment">    Intel's prior express written permission.</span>
00012 <span class="comment"></span>
00013 <span class="comment">    No license under any patent, copyright, trade secret or other</span>
00014 <span class="comment">    intellectual property right is granted to or conferred upon you by</span>
00015 <span class="comment">    disclosure or delivery of the Materials, either expressly, by</span>
00016 <span class="comment">    implication, inducement, estoppel or otherwise.  Any license under such</span>
00017 <span class="comment">    intellectual property rights must be express and approved by Intel in</span>
00018 <span class="comment">    writing.</span>
00019 <span class="comment">*/</span>
00020 
00021 <span class="preprocessor">#ifndef __TBB_machine_H</span>
00022 <span class="preprocessor"></span><span class="preprocessor">#define __TBB_machine_H</span>
00023 <span class="preprocessor"></span>
00024 <span class="preprocessor">#include "tbb_stddef.h"</span>
00025 
00026 <span class="preprocessor">#if _WIN32||_WIN64</span>
00027 <span class="preprocessor"></span>
00028 <span class="preprocessor">#ifdef _MANAGED</span>
00029 <span class="preprocessor"></span><span class="preprocessor">#pragma managed(push, off)</span>
00030 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00031 <span class="preprocessor"></span>
00032 <span class="preprocessor">#if defined(_M_IX86)</span>
00033 <span class="preprocessor"></span><span class="preprocessor">#include "machine/windows_ia32.h"</span>
00034 <span class="preprocessor">#elif defined(_M_AMD64) </span>
00035 <span class="preprocessor"></span><span class="preprocessor">#include "machine/windows_em64t.h"</span>
00036 <span class="preprocessor">#else</span>
00037 <span class="preprocessor"></span><span class="preprocessor">#error Unsupported platform</span>
00038 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00039 <span class="preprocessor"></span>
00040 <span class="preprocessor">#ifdef _MANAGED</span>
00041 <span class="preprocessor"></span><span class="preprocessor">#pragma managed(pop)</span>
00042 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00043 <span class="preprocessor"></span>
00044 <span class="preprocessor">#elif __linux__ || __FreeBSD__</span>
00045 <span class="preprocessor"></span>
00046 <span class="preprocessor">#if __i386__</span>
00047 <span class="preprocessor"></span><span class="preprocessor">#include "machine/linux_ia32.h"</span>
00048 <span class="preprocessor">#elif __x86_64__</span>
00049 <span class="preprocessor"></span><span class="preprocessor">#include "machine/linux_em64t.h"</span>
00050 <span class="preprocessor">#elif __ia64__</span>
00051 <span class="preprocessor"></span><span class="preprocessor">#include "machine/linux_itanium.h"</span>
00052 <span class="preprocessor">#endif</span>
00053 <span class="preprocessor"></span>
00054 <span class="preprocessor">#elif __APPLE__</span>
00055 <span class="preprocessor"></span>
00056 <span class="preprocessor">#if __i386__</span>
00057 <span class="preprocessor"></span><span class="preprocessor">#include "machine/linux_ia32.h"</span>
00058 <span class="preprocessor">#elif __x86_64__</span>
00059 <span class="preprocessor"></span><span class="preprocessor">#include "machine/linux_em64t.h"</span>
00060 <span class="preprocessor">#elif __POWERPC__</span>
00061 <span class="preprocessor"></span><span class="preprocessor">#include "machine/mac_ppc.h"</span>
00062 <span class="preprocessor">#endif</span>
00063 <span class="preprocessor"></span>
00064 <span class="preprocessor">#elif _AIX</span>
00065 <span class="preprocessor"></span>
00066 <span class="preprocessor">#include "machine/ibm_aix51.h"</span>
00067 
00068 <span class="preprocessor">#elif __sun || __SUNPRO_CC</span>
00069 <span class="preprocessor"></span>
00070 <span class="preprocessor">#define __asm__ asm </span>
00071 <span class="preprocessor"></span><span class="preprocessor">#define __volatile__ volatile</span>
00072 <span class="preprocessor"></span><span class="preprocessor">#if __i386  || __i386__</span>
00073 <span class="preprocessor"></span><span class="preprocessor">#include "machine/linux_ia32.h"</span>
00074 <span class="preprocessor">#elif __x86_64__</span>
00075 <span class="preprocessor"></span><span class="preprocessor">#include "machine/linux_em64t.h"</span>
00076 <span class="preprocessor">#endif</span>
00077 <span class="preprocessor"></span>
00078 <span class="preprocessor">#endif</span>
00079 <span class="preprocessor"></span>
00080 <span class="preprocessor">#if !defined(__TBB_CompareAndSwap4) || !defined(__TBB_CompareAndSwap8) || !defined(__TBB_Yield)</span>
00081 <span class="preprocessor"></span><span class="preprocessor">#error Minimal requirements for tbb_machine.h not satisfied </span>
00082 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00083 <span class="preprocessor"></span>
00084 <span class="preprocessor">#ifndef __TBB_load_with_acquire</span>
00085 <span class="preprocessor"></span>
00086     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;
00087     <span class="keyword">inline</span> T __TBB_load_with_acquire(<span class="keyword">const</span> <span class="keyword">volatile</span> T&amp; location) {
00088         T temp = location;
00089 <span class="preprocessor">#ifdef __TBB_fence_for_acquire </span>
00090 <span class="preprocessor"></span>        __TBB_fence_for_acquire();
00091 <span class="preprocessor">#endif </span><span class="comment">/* __TBB_fence_for_acquire */</span>
00092         <span class="keywordflow">return</span> temp;
00093     }
00094 <span class="preprocessor">#endif</span>
00095 <span class="preprocessor"></span>
00096 <span class="preprocessor">#ifndef __TBB_store_with_release</span>
00097 <span class="preprocessor"></span>
00098     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> V&gt;
00099     <span class="keyword">inline</span> <span class="keywordtype">void</span> __TBB_store_with_release(<span class="keyword">volatile</span> T&amp; location, V value) {
00100 <span class="preprocessor">#ifdef __TBB_fence_for_release</span>
00101 <span class="preprocessor"></span>        __TBB_fence_for_release();
00102 <span class="preprocessor">#endif </span><span class="comment">/* __TBB_fence_for_release */</span>
00103         location = T(value); 
00104     }
00105 <span class="preprocessor">#endif</span>
00106 <span class="preprocessor"></span>
00107 <span class="preprocessor">#ifndef __TBB_Pause</span>
00108 <span class="preprocessor"></span>    <span class="keyword">inline</span> <span class="keywordtype">void</span> __TBB_Pause(int32_t) {
00109         __TBB_Yield();
00110     }
00111 <span class="preprocessor">#endif</span>
00112 <span class="preprocessor"></span>
00113 <span class="keyword">namespace </span>tbb {
00114 <span class="keyword">namespace </span>internal {
00115 
00117 
<a name="l00118"></a><a class="code" href="a00187.html">00118</a> <span class="keyword">class </span><a class="code" href="a00187.html">AtomicBackoff</a> {
00120 
00122     <span class="keyword">static</span> <span class="keyword">const</span> int32_t LOOPS_BEFORE_YIELD = 16;
00123     int32_t count;
00124 <span class="keyword">public</span>:
00125     <a class="code" href="a00187.html">AtomicBackoff</a>() : count(1) {}
00126 
<a name="l00128"></a><a class="code" href="a00187.html#a1">00128</a>     <span class="keywordtype">void</span> pause() {
00129         <span class="keywordflow">if</span>( count&lt;=LOOPS_BEFORE_YIELD ) {
00130             __TBB_Pause(count);
00131             <span class="comment">// Pause twice as long the next time.</span>
00132             count*=2;
00133         } <span class="keywordflow">else</span> {
00134             <span class="comment">// Pause is so long that we might as well yield CPU to scheduler.</span>
00135             __TBB_Yield();
00136         }
00137     }
00138 
00139     <span class="comment">// pause for a few times and then return false immediately.</span>
00140     <span class="keywordtype">bool</span> bounded_pause() {
00141         <span class="keywordflow">if</span>( count&lt;=LOOPS_BEFORE_YIELD ) {
00142             __TBB_Pause(count);
00143             <span class="comment">// Pause twice as long the next time.</span>
00144             count*=2;
00145             <span class="keywordflow">return</span> <span class="keyword">true</span>;
00146         } <span class="keywordflow">else</span> {
00147             <span class="keywordflow">return</span> <span class="keyword">false</span>;
00148         }
00149     }
00150 
00151     <span class="keywordtype">void</span> reset() {
00152         count = 1;
00153     }
00154 };
00155 
00156 <span class="comment">// T should be unsigned, otherwise sign propagation will break correctness of bit manipulations.</span>
00157 <span class="comment">// S should be either 1 or 2, for the mask calculation to work correctly.</span>
00158 <span class="comment">// Together, these rules limit applicability of Masked CAS to unsigned char and unsigned short.</span>
00159 <span class="keyword">template</span>&lt;size_t S, <span class="keyword">typename</span> T&gt;
00160 <span class="keyword">inline</span> T __TBB_MaskedCompareAndSwap (<span class="keyword">volatile</span> T *ptr, T value, T comparand ) {
00161     <span class="keyword">volatile</span> uint32_t * base = (uint32_t*)( (uintptr_t)ptr &amp; ~(uintptr_t)0x3 );
00162 <span class="preprocessor">#if __TBB_BIG_ENDIAN</span>
00163 <span class="preprocessor"></span>    <span class="keyword">const</span> uint8_t bitoffset = uint8_t( 8*( 4-S - (uintptr_t(ptr) &amp; 0x3) ) );
00164 <span class="preprocessor">#else</span>
00165 <span class="preprocessor"></span>    <span class="keyword">const</span> uint8_t bitoffset = uint8_t( 8*((uintptr_t)ptr &amp; 0x3) );
00166 <span class="preprocessor">#endif</span>
00167 <span class="preprocessor"></span>    <span class="keyword">const</span> uint32_t mask = ( (1&lt;&lt;(S*8)) - 1 )&lt;&lt;bitoffset;
00168     AtomicBackoff b;
00169     uint32_t result;
00170     <span class="keywordflow">for</span>(;;) {
00171         result = *base; <span class="comment">// reload the base value which might change during the pause</span>
00172         uint32_t old_value = ( result &amp; ~mask ) | ( comparand &lt;&lt; bitoffset );
00173         uint32_t new_value = ( result &amp; ~mask ) | ( value &lt;&lt; bitoffset );
00174         <span class="comment">// __TBB_CompareAndSwap4 presumed to have full fence. </span>
00175         result = __TBB_CompareAndSwap4( base, new_value, old_value );
00176         <span class="keywordflow">if</span>(  result==old_value               <span class="comment">// CAS succeeded</span>
00177           || ((result^old_value)&amp;mask)!=0 )  <span class="comment">// CAS failed and the bits of interest have changed</span>
00178             <span class="keywordflow">break</span>;
00179         <span class="keywordflow">else</span>                                 <span class="comment">// CAS failed but the bits of interest left unchanged</span>
00180             b.pause();
00181     }
00182     <span class="keywordflow">return</span> T((result &amp; mask) &gt;&gt; bitoffset);
00183 }
00184 
00185 <span class="keyword">template</span>&lt;size_t S, <span class="keyword">typename</span> T&gt;
00186 <span class="keyword">inline</span> T __TBB_CompareAndSwapGeneric (<span class="keyword">volatile</span> <span class="keywordtype">void</span> *ptr, T value, T comparand ) { 
00187     <span class="keywordflow">return</span> __TBB_CompareAndSwapW((T *)ptr,value,comparand);
00188 }
00189 
00190 <span class="keyword">template</span>&lt;&gt;
00191 <span class="keyword">inline</span> uint8_t __TBB_CompareAndSwapGeneric &lt;1,uint8_t&gt; (<span class="keyword">volatile</span> <span class="keywordtype">void</span> *ptr, uint8_t value, uint8_t comparand ) {
00192 <span class="preprocessor">#ifdef __TBB_CompareAndSwap1</span>
00193 <span class="preprocessor"></span>    <span class="keywordflow">return</span> __TBB_CompareAndSwap1(ptr,value,comparand);
00194 <span class="preprocessor">#else</span>
00195 <span class="preprocessor"></span>    <span class="keywordflow">return</span> __TBB_MaskedCompareAndSwap&lt;1,uint8_t&gt;((<span class="keyword">volatile</span> uint8_t *)ptr,value,comparand);
00196 <span class="preprocessor">#endif</span>
00197 <span class="preprocessor"></span>}
00198 
00199 <span class="keyword">template</span>&lt;&gt;
00200 <span class="keyword">inline</span> uint16_t __TBB_CompareAndSwapGeneric &lt;2,uint16_t&gt; (<span class="keyword">volatile</span> <span class="keywordtype">void</span> *ptr, uint16_t value, uint16_t comparand ) {
00201 <span class="preprocessor">#ifdef __TBB_CompareAndSwap2</span>
00202 <span class="preprocessor"></span>    <span class="keywordflow">return</span> __TBB_CompareAndSwap2(ptr,value,comparand);
00203 <span class="preprocessor">#else</span>
00204 <span class="preprocessor"></span>    <span class="keywordflow">return</span> __TBB_MaskedCompareAndSwap&lt;2,uint16_t&gt;((<span class="keyword">volatile</span> uint16_t *)ptr,value,comparand);
00205 <span class="preprocessor">#endif</span>
00206 <span class="preprocessor"></span>}
00207 
00208 <span class="keyword">template</span>&lt;&gt;
00209 <span class="keyword">inline</span> uint32_t __TBB_CompareAndSwapGeneric &lt;4,uint32_t&gt; (<span class="keyword">volatile</span> <span class="keywordtype">void</span> *ptr, uint32_t value, uint32_t comparand ) { 
00210     <span class="keywordflow">return</span> __TBB_CompareAndSwap4(ptr,value,comparand);
00211 }
00212 
00213 <span class="keyword">template</span>&lt;&gt;
00214 <span class="keyword">inline</span> uint64_t __TBB_CompareAndSwapGeneric &lt;8,uint64_t&gt; (<span class="keyword">volatile</span> <span class="keywordtype">void</span> *ptr, uint64_t value, uint64_t comparand ) { 
00215     <span class="keywordflow">return</span> __TBB_CompareAndSwap8(ptr,value,comparand);
00216 }
00217 
00218 <span class="keyword">template</span>&lt;size_t S, <span class="keyword">typename</span> T&gt;
00219 <span class="keyword">inline</span> T __TBB_FetchAndAddGeneric (<span class="keyword">volatile</span> <span class="keywordtype">void</span> *ptr, T addend) {
00220     AtomicBackoff b;
00221     T result;
00222     <span class="keywordflow">for</span>(;;) {
00223         result = *reinterpret_cast&lt;volatile T *&gt;(ptr);
00224         <span class="comment">// __TBB_CompareAndSwapGeneric presumed to have full fence. </span>
00225         <span class="keywordflow">if</span>( __TBB_CompareAndSwapGeneric&lt;S,T&gt; ( ptr, result+addend, result )==result ) 
00226             <span class="keywordflow">break</span>;
00227         b.pause();
00228     }
00229     <span class="keywordflow">return</span> result;
00230 }
00231 
00232 <span class="keyword">template</span>&lt;size_t S, <span class="keyword">typename</span> T&gt;
00233 <span class="keyword">inline</span> T __TBB_FetchAndStoreGeneric (<span class="keyword">volatile</span> <span class="keywordtype">void</span> *ptr, T value) {
00234     AtomicBackoff b;
00235     T result;
00236     <span class="keywordflow">for</span>(;;) {
00237         result = *reinterpret_cast&lt;volatile T *&gt;(ptr);
00238         <span class="comment">// __TBB_CompareAndSwapGeneric presumed to have full fence.</span>
00239         <span class="keywordflow">if</span>( __TBB_CompareAndSwapGeneric&lt;S,T&gt; ( ptr, value, result )==result ) 
00240             <span class="keywordflow">break</span>;
00241         b.pause();
00242     }
00243     <span class="keywordflow">return</span> result;
00244 }
00245 
00246 <span class="comment">// Macro __TBB_TypeWithAlignmentAtLeastAsStrict(T) should be a type with alignment at least as </span>
00247 <span class="comment">// strict as type T.  Type type should have a trivial default constructor and destructor, so that</span>
00248 <span class="comment">// arrays of that type can be declared without initializers.  </span>
00249 <span class="comment">// It is correct (but perhaps a waste of space) if __TBB_TypeWithAlignmentAtLeastAsStrict(T) expands</span>
00250 <span class="comment">// to a type bigger than T.</span>
00251 <span class="comment">// The default definition here works on machines where integers are naturally aligned and the</span>
00252 <span class="comment">// strictest alignment is 16.</span>
00253 <span class="preprocessor">#ifndef __TBB_TypeWithAlignmentAtLeastAsStrict</span>
00254 <span class="preprocessor"></span>
00255 <span class="preprocessor">#if __GNUC__ || __SUNPRO_CC</span>
00256 <span class="preprocessor"></span><span class="keyword">struct </span>__TBB_machine_type_with_strictest_alignment {
00257     <span class="keywordtype">int</span> member[4];
00258 } __attribute__((aligned(16)));
00259 <span class="preprocessor">#elif _MSC_VER</span>
00260 <span class="preprocessor"></span>__declspec(align(16)) struct __TBB_machine_type_with_strictest_alignment {
00261     <span class="keywordtype">int</span> member[4];
00262 };
00263 <span class="preprocessor">#else</span>
00264 <span class="preprocessor"></span><span class="preprocessor">#error Must define __TBB_TypeWithAlignmentAtLeastAsStrict(T) or __TBB_machine_type_with_strictest_alignment</span>
00265 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00266 <span class="preprocessor"></span>
00267 <span class="keyword">template</span>&lt;size_t N&gt; <span class="keyword">struct </span>type_with_alignment {__TBB_machine_type_with_strictest_alignment member;};
00268 <span class="keyword">template</span>&lt;&gt; <span class="keyword">struct </span>type_with_alignment&lt;1&gt; { <span class="keywordtype">char</span> member; };
00269 <span class="keyword">template</span>&lt;&gt; <span class="keyword">struct </span>type_with_alignment&lt;2&gt; { uint16_t member; };
00270 <span class="keyword">template</span>&lt;&gt; <span class="keyword">struct </span>type_with_alignment&lt;4&gt; { uint32_t member; };
00271 <span class="keyword">template</span>&lt;&gt; <span class="keyword">struct </span>type_with_alignment&lt;8&gt; { uint64_t member; };
00272 
00273 <span class="preprocessor">#if _MSC_VER||defined(__GNUC__)&amp;&amp;__GNUC__==3 &amp;&amp; __GNUC_MINOR__&lt;=2  </span>
00274 <span class="preprocessor"></span>
00275 
00277 <span class="keyword">template</span>&lt;size_t Size, <span class="keyword">typename</span> T&gt; 
<a name="l00278"></a><a class="code" href="a00273.html">00278</a> <span class="keyword">struct </span><a class="code" href="a00273.html">work_around_alignment_bug</a> {
00279 <span class="preprocessor">#if _MSC_VER</span>
00280 <span class="preprocessor"></span>    <span class="keyword">static</span> <span class="keyword">const</span> size_t alignment = __alignof(T);
00281 <span class="preprocessor">#else</span>
00282 <span class="preprocessor"></span>    <span class="keyword">static</span> <span class="keyword">const</span> size_t alignment = __alignof__(T);
00283 <span class="preprocessor">#endif</span>
00284 <span class="preprocessor"></span>};
00285 <span class="preprocessor">#define __TBB_TypeWithAlignmentAtLeastAsStrict(T) tbb::internal::type_with_alignment&lt;tbb::internal::work_around_alignment_bug&lt;sizeof(T),T&gt;::alignment&gt;</span>
00286 <span class="preprocessor"></span><span class="preprocessor">#elif __GNUC__ || __SUNPRO_CC</span>
00287 <span class="preprocessor"></span><span class="preprocessor">#define __TBB_TypeWithAlignmentAtLeastAsStrict(T) tbb::internal::type_with_alignment&lt;__alignof__(T)&gt;</span>
00288 <span class="preprocessor"></span><span class="preprocessor">#else</span>
00289 <span class="preprocessor"></span><span class="preprocessor">#define __TBB_TypeWithAlignmentAtLeastAsStrict(T) __TBB_machine_type_with_strictest_alignment</span>
00290 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00291 <span class="preprocessor"></span><span class="preprocessor">#endif  </span><span class="comment">/* ____TBB_TypeWithAlignmentAtLeastAsStrict */</span>
00292 
00293 } <span class="comment">// namespace internal</span>
00294 } <span class="comment">// namespace tbb</span>
00295 
00296 <span class="preprocessor">#ifndef __TBB_CompareAndSwap1</span>
00297 <span class="preprocessor"></span><span class="preprocessor">#define __TBB_CompareAndSwap1 tbb::internal::__TBB_CompareAndSwapGeneric&lt;1,uint8_t&gt;</span>
00298 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00299 <span class="preprocessor"></span>
00300 <span class="preprocessor">#ifndef __TBB_CompareAndSwap2 </span>
00301 <span class="preprocessor"></span><span class="preprocessor">#define __TBB_CompareAndSwap2 tbb::internal::__TBB_CompareAndSwapGeneric&lt;2,uint16_t&gt;</span>
00302 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00303 <span class="preprocessor"></span>
00304 <span class="preprocessor">#ifndef __TBB_CompareAndSwapW</span>
00305 <span class="preprocessor"></span><span class="preprocessor">#define __TBB_CompareAndSwapW tbb::internal::__TBB_CompareAndSwapGeneric&lt;sizeof(ptrdiff_t),ptrdiff_t&gt;</span>
00306 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00307 <span class="preprocessor"></span>
00308 <span class="preprocessor">#ifndef __TBB_FetchAndAdd1</span>
00309 <span class="preprocessor"></span><span class="preprocessor">#define __TBB_FetchAndAdd1 tbb::internal::__TBB_FetchAndAddGeneric&lt;1,uint8_t&gt;</span>
00310 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00311 <span class="preprocessor"></span>
00312 <span class="preprocessor">#ifndef __TBB_FetchAndAdd2</span>
00313 <span class="preprocessor"></span><span class="preprocessor">#define __TBB_FetchAndAdd2 tbb::internal::__TBB_FetchAndAddGeneric&lt;2,uint16_t&gt;</span>
00314 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00315 <span class="preprocessor"></span>
00316 <span class="preprocessor">#ifndef __TBB_FetchAndAdd4</span>
00317 <span class="preprocessor"></span><span class="preprocessor">#define __TBB_FetchAndAdd4 tbb::internal::__TBB_FetchAndAddGeneric&lt;4,uint32_t&gt;</span>
00318 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00319 <span class="preprocessor"></span>
00320 <span class="preprocessor">#ifndef __TBB_FetchAndAdd8</span>
00321 <span class="preprocessor"></span><span class="preprocessor">#define __TBB_FetchAndAdd8 tbb::internal::__TBB_FetchAndAddGeneric&lt;8,uint64_t&gt;</span>
00322 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00323 <span class="preprocessor"></span>
00324 <span class="preprocessor">#ifndef __TBB_FetchAndAddW</span>
00325 <span class="preprocessor"></span><span class="preprocessor">#define __TBB_FetchAndAddW tbb::internal::__TBB_FetchAndAddGeneric&lt;sizeof(ptrdiff_t),ptrdiff_t&gt;</span>
00326 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00327 <span class="preprocessor"></span>
00328 <span class="preprocessor">#ifndef __TBB_FetchAndStore1</span>
00329 <span class="preprocessor"></span><span class="preprocessor">#define __TBB_FetchAndStore1 tbb::internal::__TBB_FetchAndStoreGeneric&lt;1,uint8_t&gt;</span>
00330 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00331 <span class="preprocessor"></span>
00332 <span class="preprocessor">#ifndef __TBB_FetchAndStore2</span>
00333 <span class="preprocessor"></span><span class="preprocessor">#define __TBB_FetchAndStore2 tbb::internal::__TBB_FetchAndStoreGeneric&lt;2,uint16_t&gt;</span>
00334 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00335 <span class="preprocessor"></span>
00336 <span class="preprocessor">#ifndef __TBB_FetchAndStore4</span>
00337 <span class="preprocessor"></span><span class="preprocessor">#define __TBB_FetchAndStore4 tbb::internal::__TBB_FetchAndStoreGeneric&lt;4,uint32_t&gt;</span>
00338 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00339 <span class="preprocessor"></span>
00340 <span class="preprocessor">#ifndef __TBB_FetchAndStore8</span>
00341 <span class="preprocessor"></span><span class="preprocessor">#define __TBB_FetchAndStore8 tbb::internal::__TBB_FetchAndStoreGeneric&lt;8,uint64_t&gt;</span>
00342 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00343 <span class="preprocessor"></span>
00344 <span class="preprocessor">#ifndef __TBB_FetchAndStoreW</span>
00345 <span class="preprocessor"></span><span class="preprocessor">#define __TBB_FetchAndStoreW tbb::internal::__TBB_FetchAndStoreGeneric&lt;sizeof(ptrdiff_t),ptrdiff_t&gt;</span>
00346 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00347 <span class="preprocessor"></span>
00348 <span class="preprocessor">#if __TBB_DECL_FENCED_ATOMICS</span>
00349 <span class="preprocessor"></span>
00350 <span class="preprocessor">#ifndef __TBB_CompareAndSwap1__TBB_full_fence</span>
00351 <span class="preprocessor"></span><span class="preprocessor">#define __TBB_CompareAndSwap1__TBB_full_fence __TBB_CompareAndSwap1</span>
00352 <span class="preprocessor"></span><span class="preprocessor">#endif </span>
00353 <span class="preprocessor"></span><span class="preprocessor">#ifndef __TBB_CompareAndSwap1acquire</span>
00354 <span class="preprocessor"></span><span class="preprocessor">#define __TBB_CompareAndSwap1acquire __TBB_CompareAndSwap1__TBB_full_fence</span>
00355 <span class="preprocessor"></span><span class="preprocessor">#endif </span>
00356 <span class="preprocessor"></span><span class="preprocessor">#ifndef __TBB_CompareAndSwap1release</span>
00357 <span class="preprocessor"></span><span class="preprocessor">#define __TBB_CompareAndSwap1release __TBB_CompareAndSwap1__TBB_full_fence</span>
00358 <span class="preprocessor"></span><span class="preprocessor">#endif </span>
00359 <span class="preprocessor"></span>
00360 <span class="preprocessor">#ifndef __TBB_CompareAndSwap2__TBB_full_fence</span>
00361 <span class="preprocessor"></span><span class="preprocessor">#define __TBB_CompareAndSwap2__TBB_full_fence __TBB_CompareAndSwap2</span>
00362 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00363 <span class="preprocessor"></span><span class="preprocessor">#ifndef __TBB_CompareAndSwap2acquire</span>
00364 <span class="preprocessor"></span><span class="preprocessor">#define __TBB_CompareAndSwap2acquire __TBB_CompareAndSwap2__TBB_full_fence</span>
00365 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00366 <span class="preprocessor"></span><span class="preprocessor">#ifndef __TBB_CompareAndSwap2release</span>
00367 <span class="preprocessor"></span><span class="preprocessor">#define __TBB_CompareAndSwap2release __TBB_CompareAndSwap2__TBB_full_fence</span>
00368 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00369 <span class="preprocessor"></span>
00370 <span class="preprocessor">#ifndef __TBB_CompareAndSwap4__TBB_full_fence</span>
00371 <span class="preprocessor"></span><span class="preprocessor">#define __TBB_CompareAndSwap4__TBB_full_fence __TBB_CompareAndSwap4</span>
00372 <span class="preprocessor"></span><span class="preprocessor">#endif </span>
00373 <span class="preprocessor"></span><span class="preprocessor">#ifndef __TBB_CompareAndSwap4acquire</span>
00374 <span class="preprocessor"></span><span class="preprocessor">#define __TBB_CompareAndSwap4acquire __TBB_CompareAndSwap4__TBB_full_fence</span>
00375 <span class="preprocessor"></span><span class="preprocessor">#endif </span>
00376 <span class="preprocessor"></span><span class="preprocessor">#ifndef __TBB_CompareAndSwap4release</span>
00377 <span class="preprocessor"></span><span class="preprocessor">#define __TBB_CompareAndSwap4release __TBB_CompareAndSwap4__TBB_full_fence</span>
00378 <span class="preprocessor"></span><span class="preprocessor">#endif </span>
00379 <span class="preprocessor"></span>
00380 <span class="preprocessor">#ifndef __TBB_CompareAndSwap8__TBB_full_fence</span>
00381 <span class="preprocessor"></span><span class="preprocessor">#define __TBB_CompareAndSwap8__TBB_full_fence __TBB_CompareAndSwap8</span>
00382 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00383 <span class="preprocessor"></span><span class="preprocessor">#ifndef __TBB_CompareAndSwap8acquire</span>
00384 <span class="preprocessor"></span><span class="preprocessor">#define __TBB_CompareAndSwap8acquire __TBB_CompareAndSwap8__TBB_full_fence</span>
00385 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00386 <span class="preprocessor"></span><span class="preprocessor">#ifndef __TBB_CompareAndSwap8release</span>
00387 <span class="preprocessor"></span><span class="preprocessor">#define __TBB_CompareAndSwap8release __TBB_CompareAndSwap8__TBB_full_fence</span>
00388 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00389 <span class="preprocessor"></span>
00390 <span class="preprocessor">#ifndef __TBB_FetchAndAdd1__TBB_full_fence</span>
00391 <span class="preprocessor"></span><span class="preprocessor">#define __TBB_FetchAndAdd1__TBB_full_fence __TBB_FetchAndAdd1</span>
00392 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00393 <span class="preprocessor"></span><span class="preprocessor">#ifndef __TBB_FetchAndAdd1acquire</span>
00394 <span class="preprocessor"></span><span class="preprocessor">#define __TBB_FetchAndAdd1acquire __TBB_FetchAndAdd1__TBB_full_fence</span>
00395 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00396 <span class="preprocessor"></span><span class="preprocessor">#ifndef __TBB_FetchAndAdd1release</span>
00397 <span class="preprocessor"></span><span class="preprocessor">#define __TBB_FetchAndAdd1release __TBB_FetchAndAdd1__TBB_full_fence</span>
00398 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00399 <span class="preprocessor"></span>
00400 <span class="preprocessor">#ifndef __TBB_FetchAndAdd2__TBB_full_fence</span>
00401 <span class="preprocessor"></span><span class="preprocessor">#define __TBB_FetchAndAdd2__TBB_full_fence __TBB_FetchAndAdd2</span>
00402 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00403 <span class="preprocessor"></span><span class="preprocessor">#ifndef __TBB_FetchAndAdd2acquire</span>
00404 <span class="preprocessor"></span><span class="preprocessor">#define __TBB_FetchAndAdd2acquire __TBB_FetchAndAdd2__TBB_full_fence</span>
00405 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00406 <span class="preprocessor"></span><span class="preprocessor">#ifndef __TBB_FetchAndAdd2release</span>
00407 <span class="preprocessor"></span><span class="preprocessor">#define __TBB_FetchAndAdd2release __TBB_FetchAndAdd2__TBB_full_fence</span>
00408 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00409 <span class="preprocessor"></span>
00410 <span class="preprocessor">#ifndef __TBB_FetchAndAdd4__TBB_full_fence</span>
00411 <span class="preprocessor"></span><span class="preprocessor">#define __TBB_FetchAndAdd4__TBB_full_fence __TBB_FetchAndAdd4</span>
00412 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00413 <span class="preprocessor"></span><span class="preprocessor">#ifndef __TBB_FetchAndAdd4acquire</span>
00414 <span class="preprocessor"></span><span class="preprocessor">#define __TBB_FetchAndAdd4acquire __TBB_FetchAndAdd4__TBB_full_fence</span>
00415 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00416 <span class="preprocessor"></span><span class="preprocessor">#ifndef __TBB_FetchAndAdd4release</span>
00417 <span class="preprocessor"></span><span class="preprocessor">#define __TBB_FetchAndAdd4release __TBB_FetchAndAdd4__TBB_full_fence</span>
00418 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00419 <span class="preprocessor"></span>
00420 <span class="preprocessor">#ifndef __TBB_FetchAndAdd8__TBB_full_fence</span>
00421 <span class="preprocessor"></span><span class="preprocessor">#define __TBB_FetchAndAdd8__TBB_full_fence __TBB_FetchAndAdd8</span>
00422 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00423 <span class="preprocessor"></span><span class="preprocessor">#ifndef __TBB_FetchAndAdd8acquire</span>
00424 <span class="preprocessor"></span><span class="preprocessor">#define __TBB_FetchAndAdd8acquire __TBB_FetchAndAdd8__TBB_full_fence</span>
00425 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00426 <span class="preprocessor"></span><span class="preprocessor">#ifndef __TBB_FetchAndAdd8release</span>
00427 <span class="preprocessor"></span><span class="preprocessor">#define __TBB_FetchAndAdd8release __TBB_FetchAndAdd8__TBB_full_fence</span>
00428 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00429 <span class="preprocessor"></span>
00430 <span class="preprocessor">#ifndef __TBB_FetchAndStore1__TBB_full_fence</span>
00431 <span class="preprocessor"></span><span class="preprocessor">#define __TBB_FetchAndStore1__TBB_full_fence __TBB_FetchAndStore1</span>
00432 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00433 <span class="preprocessor"></span><span class="preprocessor">#ifndef __TBB_FetchAndStore1acquire</span>
00434 <span class="preprocessor"></span><span class="preprocessor">#define __TBB_FetchAndStore1acquire __TBB_FetchAndStore1__TBB_full_fence</span>
00435 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00436 <span class="preprocessor"></span><span class="preprocessor">#ifndef __TBB_FetchAndStore1release</span>
00437 <span class="preprocessor"></span><span class="preprocessor">#define __TBB_FetchAndStore1release __TBB_FetchAndStore1__TBB_full_fence</span>
00438 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00439 <span class="preprocessor"></span>
00440 <span class="preprocessor">#ifndef __TBB_FetchAndStore2__TBB_full_fence</span>
00441 <span class="preprocessor"></span><span class="preprocessor">#define __TBB_FetchAndStore2__TBB_full_fence __TBB_FetchAndStore2</span>
00442 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00443 <span class="preprocessor"></span><span class="preprocessor">#ifndef __TBB_FetchAndStore2acquire</span>
00444 <span class="preprocessor"></span><span class="preprocessor">#define __TBB_FetchAndStore2acquire __TBB_FetchAndStore2__TBB_full_fence</span>
00445 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00446 <span class="preprocessor"></span><span class="preprocessor">#ifndef __TBB_FetchAndStore2release</span>
00447 <span class="preprocessor"></span><span class="preprocessor">#define __TBB_FetchAndStore2release __TBB_FetchAndStore2__TBB_full_fence</span>
00448 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00449 <span class="preprocessor"></span>
00450 <span class="preprocessor">#ifndef __TBB_FetchAndStore4__TBB_full_fence</span>
00451 <span class="preprocessor"></span><span class="preprocessor">#define __TBB_FetchAndStore4__TBB_full_fence __TBB_FetchAndStore4</span>
00452 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00453 <span class="preprocessor"></span><span class="preprocessor">#ifndef __TBB_FetchAndStore4acquire</span>
00454 <span class="preprocessor"></span><span class="preprocessor">#define __TBB_FetchAndStore4acquire __TBB_FetchAndStore4__TBB_full_fence</span>
00455 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00456 <span class="preprocessor"></span><span class="preprocessor">#ifndef __TBB_FetchAndStore4release</span>
00457 <span class="preprocessor"></span><span class="preprocessor">#define __TBB_FetchAndStore4release __TBB_FetchAndStore4__TBB_full_fence</span>
00458 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00459 <span class="preprocessor"></span>
00460 <span class="preprocessor">#ifndef __TBB_FetchAndStore8__TBB_full_fence</span>
00461 <span class="preprocessor"></span><span class="preprocessor">#define __TBB_FetchAndStore8__TBB_full_fence __TBB_FetchAndStore8</span>
00462 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00463 <span class="preprocessor"></span><span class="preprocessor">#ifndef __TBB_FetchAndStore8acquire</span>
00464 <span class="preprocessor"></span><span class="preprocessor">#define __TBB_FetchAndStore8acquire __TBB_FetchAndStore8__TBB_full_fence</span>
00465 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00466 <span class="preprocessor"></span><span class="preprocessor">#ifndef __TBB_FetchAndStore8release</span>
00467 <span class="preprocessor"></span><span class="preprocessor">#define __TBB_FetchAndStore8release __TBB_FetchAndStore8__TBB_full_fence</span>
00468 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00469 <span class="preprocessor"></span>
00470 <span class="preprocessor">#endif // __TBB_DECL_FENCED_ATOMICS</span>
00471 <span class="preprocessor"></span>
00472 <span class="comment">// Special atomic functions</span>
00473 <span class="preprocessor">#ifndef __TBB_FetchAndAddWrelease</span>
00474 <span class="preprocessor"></span><span class="preprocessor">#define __TBB_FetchAndAddWrelease __TBB_FetchAndAddW</span>
00475 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00476 <span class="preprocessor"></span>
00477 <span class="preprocessor">#ifndef __TBB_FetchAndIncrementWacquire</span>
00478 <span class="preprocessor"></span><span class="preprocessor">#define __TBB_FetchAndIncrementWacquire(P) __TBB_FetchAndAddW(P,1)</span>
00479 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00480 <span class="preprocessor"></span>
00481 <span class="preprocessor">#ifndef __TBB_FetchAndDecrementWrelease</span>
00482 <span class="preprocessor"></span><span class="preprocessor">#define __TBB_FetchAndDecrementWrelease(P) __TBB_FetchAndAddW(P,(-1))</span>
00483 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00484 <span class="preprocessor"></span>
00485 <span class="preprocessor">#if __TBB_WORDSIZE==4</span>
00486 <span class="preprocessor"></span><span class="comment">// On 32-bit platforms, "atomic.h" requires definition of __TBB_Store8 and __TBB_Load8</span>
00487 <span class="preprocessor">#ifndef __TBB_Store8</span>
00488 <span class="preprocessor"></span><span class="keyword">inline</span> <span class="keywordtype">void</span> __TBB_Store8 (<span class="keyword">volatile</span> <span class="keywordtype">void</span> *ptr, int64_t value) {
00489     <a class="code" href="a00187.html">tbb::internal::AtomicBackoff</a> b;
00490     <span class="keywordflow">for</span>(;;) {
00491         int64_t result = *(int64_t *)ptr;
00492         <span class="keywordflow">if</span>( __TBB_CompareAndSwap8(ptr,value,result)==result ) <span class="keywordflow">break</span>;
00493         b.<a class="code" href="a00187.html#a1">pause</a>();
00494     }
00495 }
00496 <span class="preprocessor">#endif</span>
00497 <span class="preprocessor"></span>
00498 <span class="preprocessor">#ifndef __TBB_Load8</span>
00499 <span class="preprocessor"></span><span class="keyword">inline</span> int64_t __TBB_Load8 (<span class="keyword">const</span> <span class="keyword">volatile</span> <span class="keywordtype">void</span> *ptr) {
00500     int64_t result = *(int64_t *)ptr;
00501     result = __TBB_CompareAndSwap8((<span class="keyword">volatile</span> <span class="keywordtype">void</span> *)ptr,result,result);
00502     <span class="keywordflow">return</span> result;
00503 }
00504 <span class="preprocessor">#endif</span>
00505 <span class="preprocessor"></span><span class="preprocessor">#endif </span><span class="comment">/* __TBB_WORDSIZE==4 */</span>
00506 
00507 <span class="preprocessor">#ifndef __TBB_Log2</span>
00508 <span class="preprocessor"></span><span class="keyword">inline</span> intptr_t __TBB_Log2( uintptr_t x ) {
00509     <span class="keywordtype">long</span> result = -1;
00510     <span class="keywordflow">for</span>(; x; x&gt;&gt;=1 ) ++result;
00511     <span class="keywordflow">return</span> result;
00512 }
00513 <span class="preprocessor">#endif</span>
00514 <span class="preprocessor"></span>
00515 <span class="preprocessor">#ifndef __TBB_AtomicOR</span>
00516 <span class="preprocessor"></span><span class="keyword">inline</span> <span class="keywordtype">void</span> __TBB_AtomicOR( <span class="keyword">volatile</span> <span class="keywordtype">void</span> *operand, uintptr_t addend ) {
00517     <a class="code" href="a00187.html">tbb::internal::AtomicBackoff</a> b;
00518     <span class="keywordflow">for</span>(;;) {
00519         uintptr_t tmp = *(<span class="keyword">volatile</span> uintptr_t *)operand;
00520         uintptr_t result = __TBB_CompareAndSwapW(operand, tmp|addend, tmp);
00521         <span class="keywordflow">if</span>( result==tmp ) <span class="keywordflow">break</span>;
00522         b.<a class="code" href="a00187.html#a1">pause</a>();
00523     }
00524 }
00525 <span class="preprocessor">#endif</span>
00526 <span class="preprocessor"></span>
00527 <span class="preprocessor">#ifndef __TBB_AtomicAND</span>
00528 <span class="preprocessor"></span><span class="keyword">inline</span> <span class="keywordtype">void</span> __TBB_AtomicAND( <span class="keyword">volatile</span> <span class="keywordtype">void</span> *operand, uintptr_t addend ) {
00529     <a class="code" href="a00187.html">tbb::internal::AtomicBackoff</a> b;
00530     <span class="keywordflow">for</span>(;;) {
00531         uintptr_t tmp = *(<span class="keyword">volatile</span> uintptr_t *)operand;
00532         uintptr_t result = __TBB_CompareAndSwapW(operand, tmp&amp;addend, tmp);
00533         <span class="keywordflow">if</span>( result==tmp ) <span class="keywordflow">break</span>;
00534         b.<a class="code" href="a00187.html#a1">pause</a>();
00535     }
00536 }
00537 <span class="preprocessor">#endif</span>
00538 <span class="preprocessor"></span>
00539 <span class="preprocessor">#ifndef __TBB_TryLockByte</span>
00540 <span class="preprocessor"></span><span class="keyword">inline</span> <span class="keywordtype">bool</span> __TBB_TryLockByte( <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> &amp;flag ) {
00541     <span class="keywordflow">return</span> __TBB_CompareAndSwap1(&amp;flag,1,0)==0;
00542 }
00543 <span class="preprocessor">#endif</span>
00544 <span class="preprocessor"></span>
00545 <span class="preprocessor">#ifndef __TBB_LockByte</span>
00546 <span class="preprocessor"></span><span class="keyword">inline</span> uintptr_t __TBB_LockByte( <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>&amp; flag ) {
00547     <span class="keywordflow">if</span> ( !__TBB_TryLockByte(flag) ) {
00548         <a class="code" href="a00187.html">tbb::internal::AtomicBackoff</a> b;
00549         <span class="keywordflow">do</span> {
00550             b.<a class="code" href="a00187.html#a1">pause</a>();
00551         } <span class="keywordflow">while</span> ( !__TBB_TryLockByte(flag) );
00552     }
00553     <span class="keywordflow">return</span> 0;
00554 }
00555 <span class="preprocessor">#endif</span>
00556 <span class="preprocessor"></span>
00557 <span class="preprocessor">#endif </span><span class="comment">/* __TBB_machine_H */</span>
</pre></div><hr>
<p></p>
Copyright &copy; 2005-2008 Intel Corporation.  All Rights Reserved.
<p></p>
Intel, Pentium, Intel Xeon, Itanium, Intel XScale and VTune are
registered trademarks or trademarks of Intel Corporation or its
subsidiaries in the United States and other countries.
<p></p>
* Other names and brands may be claimed as the property of others.
